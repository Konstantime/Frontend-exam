<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Костин Сайт-шпора</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <h1>Правила экзамена</h1>
    </header>

    <section>
      <p id="testLearningJS">Начало</p>
      <button id="changeTest">Поменяем текст на "изменено"</button>
      <button id="btnTest">Кликни</button>

      <input id="input" type="text" />
      <p id="output"></p>

      <div id="box">Box</div>

      <input id="task" type="text" />
      <button id="btnAdd">Добавить</button>
      <ul id="list"></ul>
    </section>

    <section>
      <p>Оценка 5 (автомат):</p>
      <ul>
        <li>сдан контрольный срез;</li>
        <li>проект сдан в установленный срок;</li>
        <li>выполнены все задания по Vue.js.</li>
      </ul>

      <p>Оценка 4 (автомат):</p>

      <ul>
        <li>сдан контрольный срез;</li>
        <li>проект сдан (срок сдачи не учитывается);</li>
        <li>выполнены все или не менее 5 из 6 заданий по Vue.js.</li>
      </ul>

      <p>Оценка 3 (автомат):</p>
      <ul>
        <li>сдан контрольный срез;</li>
        <li>выполнена часть заданий по Vue.js.</li>
      </ul>

      <p>
        Тут список, студентов, который сдали срез и которые сдали проект (в срок
        и без учета срока) https://e.sfu-kras.ru/mod/assign/view.php?id=1935273
        <br />
        <br />
        Если идете на экзамен, формат экзамена зависит от ранее выполненных
        работ: <br />
        Контрольный срез не сдан - на экзамене добавляются дополнительные
        теоретические вопросы по HTML и CSS. <br />
        Проект не сдан - на экзамене предусмотрено практическое задание по
        методологии БЭМ. <br />
        Большинство заданий по Vue.js не выполнено - на экзамене предусмотрено
        практическое задание по Vue.js.
      </p>
    </section>

    <section>
      <h2>Вопросы по HTML и CSS</h2>
      <div>
        <div>
          <section>
            <h4>
              1. Что такое doctype? Рассказать про head, meta, title, body.
            </h4>
            <h5>Doctype</h5>
            <p>
              это инструкция в начале HTML-документа, которая указывает браузеру
              версию HTML и активирует стандартный режим рендеринга.
            </p>
            <h5>Head</h5>
            <p>
              Элемент содержит метаданные страницы, невидимые пользователю. Он
              включает информацию о кодировке, стилях, скриптах и других
              ресурсах. Размещается сразу после doctype и перед body.
            </p>
            <h5>Meta</h5>
            <p>
              Теги meta внутри head передают метаданные: например,
              charset="UTF-8" для кодировки, viewport для мобильной адаптации
              или description для поисковиков. Они не отображаются на странице,
              но влияют на SEO и поведение браузера.
            </p>
            <h5>Title</h5>
            <p>
              Задаёт заголовок страницы, видимый во вкладке браузера и поисковой
              выдаче.
            </p>
            <h5>Body</h5>
            <p>
              Элемент body содержит весь видимый контент: текст, изображения,
              формы и другие элементы.
            </p>
          </section>

          <section>
            <h4>
              2. Для чего нужны атрибуты name и value в элементах формы (в
              input, select и т.д).
            </h4>
            <p>
              Формы в HTML — это блоки для сбора данных от пользователя (логин,
              пароль, выбор опций), которые отправляются на сервер для
              обработки. Элемент form оборачивает все поля, а атрибуты name и
              value определяют, как данные передаются: name — ключ (имя поля),
              value — значение.
            </p>
          </section>

          <section>
            <h4>
              3. Что такое HTML-формы? Опишите основные элементы формы (form,
              label, fieldset, legend) и их роль. Как работает отправка формы
              (method: GET/POST, action). Как сделать так, чтоб можно было
              отправлять файлы на сервер.
            </h4>
            <p>
              HTML‑форма — это контейнер, который собирает значения полей
              (input, select и т.д.) и отправляет их на сервер по HTTP‑запросу.
            </p>
            <p>
              form — блок, внутри которого находятся элементы формы. action и
              method - его обязательные атрибуты. <br />
              action — URL обработчика на сервере(Скрипта) (куда пойдёт запрос).
              <br />
              method — HTTP‑метод отправки: GET или POST. Пример: <br />
              &lt;form action="/submit" method="post"&gt; <br />
              ... <br />
              &lt;/form &gt;
            </p>

            <h5>Элементы формы</h5>
            <p>
              &lt;label&gt; — подпись для поля ввода. Кликаешь по надписи —
              фокус попадает в соответствующий input, плюс это критично для
              пользователей с особенностями восприятия. Без связки for и id
              скриптридеры не смогут с ними работать. Связь делается через for и
              id: <br />

              fieldset — логическая группа полей внутри формы. <br />
              Используется, когда много связанных полей (например, «Личные
              данные», «Адрес»). <br />

              legend — заголовок группы полей; должен быть первым ребёнком
              внутри fieldset. <br />
            </p>

            <p>
              &lt;fieldset&gt;<br />
                  &lt;legend&gt;Выбор по радио&lt;/legend&gt;<br />
                  &lt;label for=&quot;sex&quot;&gt;Выберите пол&lt;/label&gt;<br />
                  <br />
                  &lt;p&gt;<br />
                      &lt;label for=&quot;man&quot;&gt;Мужчина&lt;/label&gt;<br />
                      &lt;input type=&quot;radio&quot; id=&quot;man&quot;
              name=&quot;sexUser&quot; value=&quot;Мужчина&quot; /&gt;<br />
                  &lt;/p&gt;<br />
                  &lt;p&gt;<br />
                      &lt;label
              for=&quot;women&quot;&gt;Женщина&lt;/label&gt;<br />
                      &lt;input type=&quot;radio&quot; id=&quot;woman&quot;
              name=&quot;sexUser&quot; value=&quot;Женщина&quot; /&gt;<br />
                  &lt;/p&gt;<br />
              &lt;/fieldset&gt;
            </p>

            <h5>Как работает отправка формы (GET / POST, action)</h5>
            <p>
              Когда нажимаешь &lt;button type="submit"&gt; или &lt;input
              type="submit"&gt;, браузер: ​ &lt;&gt; 1. Берёт все элементы с
              атрибутом name внутри form. <br />
              2. Собирает пары name=значение. <br />
              3. Посылает HTTP‑запрос на URL из action с методом из method.
              <br />
            </p>

            <h5>method="GET"</h5>
            <p>
              Данные кодируются в URL после ?: /submit?name=Alex&age=25.
              Используется для простых запросов (поиск, фильтрация). Плохо для
              паролей и больших данных.
            </p>

            <h5>method="POST"</h5>

            <p>
              Данные идут в теле HTTP‑запроса, URL остаётся чистым. Подходит для
              логина, регистрации, отправки больших форм. ​
            </p>

            <p>Пример:</p>

            <p>
              &lt;form action=&quot;/handle-form&quot;
              method=&quot;post&quot;&gt;<br />
                  &lt;label for=&quot;login&quot;&gt;Логин:&lt;/label&gt;<br />
                  &lt;input id=&quot;login&quot; name=&quot;login&quot;
              type=&quot;text&quot;&gt;<br />
                  <br />
                  &lt;label for=&quot;password&quot;&gt;Пароль:&lt;/label&gt;<br />
                  &lt;input id=&quot;password&quot; name=&quot;password&quot;
              type=&quot;password&quot;&gt;<br />
                  <br />
                  &lt;button type=&quot;submit&quot;&gt;Войти&lt;/button&gt;<br />
              &lt;/form&gt; На сервер прилетит что‑то вроде:
              login=...&password=.... <br />
              Вот в действии
            </p>

            <form action="/handle-form" method="post">
              <label for="login">Логин:</label>
              <input id="login" name="login" type="text" />

              <label for="password">Пароль:</label>
              <input id="password" name="password" type="password" />

              <button type="submit">Войти</button>
            </form>

            <h5>Как отправлять файлы на сервер</h5>
            <p>
              Чтобы форма умела отправлять файл, нужно одновременно выполнить
              три условия: <br />

              1. Внутри формы — поле для выбора файла. Прописать type="text"
              <br />
              2. Метод формы обязательно POST. Потому что обычный GET не умеет
              нормально передавать большие бинарные данные через URL, а POST с
              enctype="multipart/form-data" как раз и создан для отправки файлов
              в теле запроса.
              <br />
              3. Добавить атрибут enctype="multipart/form-data": <br />

              &lt;form action=&quot;/upload&quot; method=&quot;post&quot;
              enctype=&quot;multipart/form-data&quot;&gt;<br />
                  &lt;label for=&quot;avatar&quot;&gt;Загрузите
              аватар:&lt;/label&gt;<br />
                  &lt;input id=&quot;avatar&quot; name=&quot;avatar&quot;
              type=&quot;file&quot;&gt;<br />
                  <br />
                  &lt;button
              type=&quot;submit&quot;&gt;Отправить&lt;/button&gt;<br />
              &lt;/form&gt; <br />

              enctype="multipart/form-data" говорит браузеру отправлять данные
              «частями» (multipart), что позволяет прикреплять бинарные файлы, а
              не только обычный текст. <br />

              Без этого атрибута файл нормально на сервер не дойдёт.
            </p>
          </section>

          <section>
            <h4>
              4. Что такое семантическая верстка, зачем нужна. Рассказать про
              article, section, footer, header, aside, nav, figure. Зачем нужны
              ul и ol, что верстают используя ul и ol.
            </h4>
            <p>
              Семантика - смысловое разделение кода страницы на блоки, на основе
              смысла их содержимого. Идея в том, чтобы код был понятен не только
              человеку на глаз, но и браузеру (для продвижения в поиске),
              скринридеру, поисковику и другим программам.
            </p>
            <h4>Теги</h4>
            <p>
              header - верхняя часть страницы (шапка), секции, блок и т.д.
              (Несколько на странице) <br />
              footer - нижняя часть страницы (шапка), секции, блок и т.д.
              (Несколько на странице) <br />
              main - основная часть страницы (Один на страницу) <br />
              section - независимые функциональные блоки. (Обязателен заголовок)
              <br />
              article - самодостаточный блок какой-либо сущности. (Типа если
              можно вынести как блок рекламы - то это он) <br />
              aside - блок с доп./косвенным содержимым. Типа боковая (не всегда)
              колонка/фильтры и т.д. <br />
              nav - блок навигации. (несколько на страницу) <br />
              figure - обозначение картинки, диаграммы, кода, таблицы и т.д.
              <br />
            </p>
            <img src="images\semanticCode.jpg" alt="Семантика кода" />

            <p>
              ul Типа: <br />
              &lt;ul&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;/ul&gt; <br />
            </p>

            <ul>
              <li>Я элемент маркированного спика</li>
              <li>Я элемент маркированного спика</li>
              <li>Я элемент маркированного спика</li>
            </ul>

            <p>
              ol Типа: <br />
              &lt;ol&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;/ol&gt; <br />
            </p>

            <ol>
              <li>Я элемент нумерованного спика</li>
              <li>Я элемент нумерованного спика</li>
              <li>Я элемент нумерованного спика</li>
            </ol>
          </section>

          <section>
            <h4>
              5. В контексте CSS. Что такое БЭМ, зачем нужен. Привести примеры.
              Что такое внешняя геометрия и почему БЕМ ее запрещает. Плюсы и
              минусы БЕМ.
            </h4>
            <p>
              БЭМ — компонентный подход к веб-разработке, в основе которого
              лежит принцип разделения интерфейса на независимые блоки.
              <br />
              <br />
              Он позволяет легко и быстро разрабатывать интерфейсы любой
              сложности и повторно использовать существующий код, избегая
              «Copy-Paste».
            </p>
            <h5>Блок</h5>
            <p>
              Функционально независимый компонент страницы, который может быть
              повторно использован. В HTML блоки представлены атрибутом class.
              <br />

              Название блока характеризует смысл («что это?» — «меню»: menu,
              «кнопка»: button), а не состояние («какой, как выглядит?» —
              «красный»: red, «большой»: big). <br />

              Пример <br />

              &lt;!-- Верно. Семантически осмысленный блок `error` --&gt;<br />
              &lt;div class=&quot;error&quot;&gt;&lt;/div&gt;<br />
              <br />
              &lt;!-- Неверно. Описывается внешний вид --&gt;<br />
              &lt;div class=&quot;red-text&quot;&gt;&lt;/div&gt; <br />
              <br />
              Блок не должен влиять на свое окружение, т. е. блоку не следует
              задавать внешнюю геометрию (в виде отступов, границ, влияющих на
              размеры) и позиционирование. <br />

              В CSS по БЭМ также не рекомендуется использовать селекторы по
              тегам или id. <br />

              Таким образом обеспечивается независимость, при которой возможно
              повторное использование или перенос блоков с места на место.
            </p>

            <h5>Элемент</h5>
            <p>
              Составная часть блока, которая не может использоваться в отрыве от
              него. <br />

              Название элемента характеризует смысл («что это?» — «пункт»: item,
              «текст»: text), а не состояние («какой, как выглядит?» —
              «красный»: red, «большой»: big). <br />

              Структура полного имени элемента соответствует схеме:
              имя-блока__имя-элемента. Имя элемента отделяется от имени блока
              двумя подчеркиваниями (__). <br />

              Пример <br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
                  &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;
            </p>

            <h5>Модификатор</h5>
            <p>
              Cущность, определяющая внешний вид, состояние или поведение блока
              либо элемента.
            </p>
            <p>
              &lt;!-- Блок `search-form` имеет булевый модификатор `focused`
              --&gt;<br />
              &lt;form class=&quot;search-form search-form_focused&quot;&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` имеет булевый модификатор `disabled`
              --&gt;<br />
                  &lt;button class=&quot;search-form__button
              search-form__button_disabled&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;
            </p>
            <h5>Вложенность</h5>
            <ul>
              <li>Элементы можно вкладывать друг в друга.</li>
              <li>Допустима любая вложенность элементов.</li>
              <li>
                Элемент — всегда часть блока, а не другого элемента. Это
                означает, что в названии элементов нельзя прописывать иерархию
                вида block__elem1__elem2.
              </li>
            </ul>
            <p>
              &lt;!-- Блок `header` --&gt;<br />
              &lt;header class=&quot;header&quot;&gt;<br />
                  &lt;!-- Вложенный блок `logo` --&gt;<br />
                  &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;<br />
                  <br />
                  &lt;!-- Вложенный блок `search-form` --&gt;<br />
                  &lt;form class=&quot;search-form&quot;&gt;&lt;/form&gt;<br />
              &lt;/header&gt;
            </p>

            <h5>Принадлежность</h5>
            <p>
              Элемент — всегда часть блока и не должен использоваться отдельно
              от него.
            </p>

            <p>
              &lt;!-- Верно. Элементы лежат внутри блока `search-form` --&gt;<br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
                  &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;<br />
              <br />
              &lt;!-- Неверно. Элементы лежат вне контекста блока `search-form`
              --&gt;<br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
              &lt;/form&gt;<br />
              <br />
              &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
              &lt;input class=&quot;search-form__input&quot;&gt;<br />
              <br />
              &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
              &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;
            </p>
            <h5>Необязательность</h5>
            <p>
              Элемент — необязательный компонент блока. Не у всех блоков должны
              быть элементы.
            </p>
            <p>
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;div class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Блок `input` --&gt;<br />
                  &lt;input class=&quot;input&quot;&gt;<br />
                  <br />
                  &lt;!-- Блок `button` --&gt;<br />
                  &lt;button class=&quot;button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/div&gt;
            </p>

            <h5>Внешняя геометрия</h5>
            <p>
              Внешняя геометрия - это всё что влияет на то как расположен блок
              относительно своих соседей (margin, position, float и т.п.): его
              отступы наружу и позиционирование относительно окружения. <br />
              ​Внутренняя геометрия — это наоборот padding, размеры, границы, то
              есть «как устроен блок изнутри». <br />
              Она запрещена в БЭМ так как способна повлиять при
              переиспользовании блока в других местах.
            </p>

            <h5>Плюсы и минусы БЭМ</h5>
            <p>
              Плюсы БЭМ — предсказуемая структура, независимые блоки, меньше
              конфликтов CSS, проще поддерживать и работать в команде. <br />
              Минусы — длинные классы, порог входа, привязка к структуре и
              необходимость строго соблюдать правила.
            </p>
          </section>

          <section>
            <h4>
              6. Каскад, Специфичность (таблица), Наследование. 3 фактора.
            </h4>
            <a href="https://youtu.be/PEQ3i9q3ez8?si=sp7y35Dj_kYj2Mxx"
              >Видос от Ламкова</a
            >
            <h5>Каскад</h5>
            <p>
              Каскад — это алгоритм выбора финального значения свойства, когда
              на один элемент действует несколько CSS‑правил.
            </p>

            <h6>Главные идеи</h6>
            <ul>
              <li>
                Правила приходят из разных источников (стили браузера, стили
                пользователя, стили автора страницы).
              </li>
              <li>
                Браузер сравнивает важность, специфичность и порядок объявления
                и решает, какое значение взять.
              </li>
            </ul>
            <h5>2. Специфичность (и «таблица»)</h5>
            <p>
              Специфичность — это «вес» селектора; чем он выше, тем правило
              важнее. <br />

              Упрощённая табличка (от меньшего к большему):
            </p>
            <ul>
              <li>Селектор по тегу: p, div, section — низкая специфичность.</li>
              <li>
                Класс, псевдокласс: .btn, .error, :hover, [type="text"] — выше.
              </li>
              <li>ID: #header — ещё выше.</li>
              <li>
                Стиль в атрибуте style="" — самый высокий среди обычных
                (inline‑стиль).
              </li>
            </ul>
            <p>
              Если на элемент действуют два правила с разной специфичностью,
              победит более специфичный селектор. ​
            </p>
            <img src="images/TableSpecific.jpg" alt="Таблица специфичности" />

            <div>
              <h5>Наследование</h5>
              <p>
                Наследование — это когда некоторые свойства CSS не задаются
                явно, а унаследуются от родителя.
              </p>
              <ul>
                <li>Наследуются, например: color, font-family, line-height.</li>
                <li>
                  Не наследуются: margin, padding, border, width, height и т.д.
                </li>
                <li>
                  Наследование можно управлять значениями inherit, initial,
                  unset.
                </li>
              </ul>

              <h5>«3 фактора» в каскаде</h5>

              <p>
                В упрощённом виде (для экзамена) три фактора, которыми браузер
                руководствуется:
              </p>
              <ol>
                <li>Важность (importance / origin)</li>
                <ul>
                  <li>!important побеждает обычные правила.</li>
                  <li>
                    Плюс источник: стили браузера < стили автора < !important и
                    т.п.
                  </li>
                </ul>
                <li>Специфичность селектора</li>
                <ul>
                  <li>ID > класс / псевдокласс > тег.</li>
                </ul>
                <li>Порядок объявления (source order)</li>
                <ul>
                  <li>
                    Если важность и специфичность совпали, выигрывает последнее
                    по порядку правило в CSS.
                  </li>
                </ul>
              </ol>
              <p>
                Наследование работает как дополнительный механизм: если элементу
                свойство не задано напрямую и нет более приоритетного правила,
                он берёт значение у родителя. ​
              </p>
            </div>
          </section>

          <section id="cascad-demo">
            <h2>Каскад спецефичность наследование</h2>

            <p class="text--cascad">Этот текста должен быть зеленым.</p>

            <p class="text special" id="important--text">
              А этот параграф поборется за размер и цвет шрифта
            </p>
          </section>

          <section>
            <h4>
              7. Блочная модель, строчные элементы. Стандартная блочная модель
              CSS. Альтернативная блочная модель CSS.
            </h4>
            <div>
              <h5>Блочная модель</h5>
              <p>
                Блочная модель - это алгоритм расчета размеров каждого отдельно
                взятого элемента страницы. Совокупность всех свойств влияющих на
                размеры элементов.
              </p>
              <div class="my--box">Я my--box</div>
              <img src="images/myBox.jpg" alt="Моя коробочка" />
              <img src="images/blockModel.jpg" alt="Блочная модель" />
              <p>Любой элемент в потоке — это прямоугольник из 4 слоёв:</p>
              <ul>
                <li>content — содержимое (текст, картинка).</li>
                <li>padding — внутренний отступ от контента до границы.</li>
                <li>border — рамка вокруг padding.</li>
                <li>margin — внешний отступ до соседних элементов.</li>
              </ul>
              <p>
                Схема: итоговый размер = content + padding + border + margin.
              </p>
            </div>
            <div>
              <h5>Блочные (block-level)</h5>
              <ul>
                <li>Всегда начинаются с новой строки.</li>
                <li>По умолчанию занимают всю доступную ширину родителя.</li>
                <li>
                  Можно задавать width/height, margin/padding по всем сторонам.
                </li>
                <li>Примеры: div, section, article, header, footer, ul, p</li>
              </ul>
              <h5>Строчные (inline-level)</h5>
              <ul>
                <li>Не начинают новую строку, идут «в строку» с текстом.</li>
                <li>Ширина = ширина содержимого.</li>
                <li>
                  width/height практически не работают; вертикальные
                  margin/padding ведут себя ограниченно.
                </li>
                <li>Примеры: span, a, strong, em, label.​</li>
              </ul>
              (Есть ещё inline-block, гибрид: стоит в строке, но ведёт себя как
              маленький блок — можно задавать width/height. )
              <h5>Альтернаятивная блочная модель</h5>
              Альтернативная модель включается через box-sizing: border-box: ​
              <ul>
                <li>
                  width и height задают размер всего видимого бокса: content +
                  padding + border.
                </li>
                <li>
                  При увеличении padding/border контентная область сжимается, но
                  визуальная ширина остаётся фиксированной.
                </li>
              </ul>

              Пример: <br />
              .box { <br />
              width: 200px; <br />
              padding: 20px; <br />
              border: 4px solid; <br />
              box-sizing: border-box; <br />
              } <br />

              Реальная видимая ширина будет ровно 200px, padding и border
              «влезают внутрь» этой ширины.

              <h5>Разница</h5>
              Разница только в том, как считается width/height относительно
              padding и border.
              <ul>
                <li>
                  Стандартная блочная модель (box-sizing: content-box)
                  (добавляет размер, "заботиться о контенте"): width/height
                  задают только контент. Padding и border добавляются сверху и
                  увеличивают реальный размер блока.
                </li>
                <li>
                  Альтернативная блочная модель (box-sizing: border-box)
                  (отжирает место у контента): width/height задают всю коробку
                  целиком (content + padding + border). При изменении
                  padding/border внешняя ширина не меняется, уменьшается только
                  область контента.
                </li>
              </ul>
            </div>
          </section>

          <div>
            <h4>
              8. Рассказать про свойство border, margin, padding, схлопывание,
              max(min)-width-height.
            </h4>
            <div>
              <h5>padding</h5>
              Внутренние рамки (от рамки к контенту) <br />

              Одно значение (padding 10px):
              <ol>
                <li>отступ будет добавлен со всех сторон одинаковый</li>
              </ol>
              Два значение (padding 10px 20px):
              <ol>
                <li>первое по вертикали</li>
                <li>второе по горизонтали</li>
              </ol>
              Три значения (padding 10px 20px 30px):
              <ol>
                <li>первое сверху</li>
                <li>горизонталь</li>
                <li>снизу</li>
              </ol>
              Четыре значения (padding 10px 20px 30px 40px). То (по часовой):
              <ol>
                <li>сверху</li>
                <li>справа</li>
                <li>снизу</li>
                <li>слева</li>
              </ol>
              Дополнительно:
              <ul>
                <li>padding-block - по вертикали</li>
                <li>padding-top - по горизонтали</li>
                <li>padding-top - сверху</li>
                <li>padding-left - слева</li>
                <li>padding-right - справа</li>
                <li>padding-bottom - снизу</li>
              </ul>

              Единицы измерения - доступны множество пиксели, проценты, въюмы,
              ремы. Но чаще всего приходится работать именно с пикселями
            </div>
            <div>
              <h5>margin</h5>
              название тегов одинаковое и аналогично padding. (Например,
              padding-top аналогично margin-top и так далее) <br />

              Но сама логика другая. margin отталкивает от себя рядом стояющие
              блоки.
              <h5>Схлопывание отступов. (Относится к margin)</h5>
              Если например, у одного рядомстоящего блока будет отступ 30px, у
              второго 40px, то они будут находиться друг от друга на расстоянии
              40px, а не 70px - это и называется схлопыванием отступов. <br />
              Также расстояние может быть отрицательным (margin: -40px) из-за
              чего блоки могут даже залезать друг на друга. В этом случае
              выбирается самый отрицательный margin.
            </div>
            <div>
              <h5>border (рамка элемента)</h5>
              border (рамка) — сущность между "настоящей" границей блока и
              padding. <br />
              <br />

              .box { <br />
              border: 2px solid #fff; <br />
              } <br />

              Это сразу задаёт: ​
              <ul>
                <li>border-width — толщину (2px).</li>
                <li>
                  border-style — стиль линии (solid, dashed, dotted, double,
                  none и т.д.).
                </li>
                <li>border-color — цвет.</li>
              </ul>
            </div>
            <div>
              <h5>min-width, max-width, min-height, max-height</h5>
              Эти свойства задают ограничения на размеры блока относительно
              обычных width/height.
              <ul>
                <li>
                  min - не позволяет блоку сжаться меньше определенного размера
                  по высоте/ширине.
                </li>
                <li>
                  max - не позволяет блоку стать больше указанного значения.
                </li>
              </ul>
            </div>
          </div>
          <div>
            <h4>
              9. Привести примеры: Селекторы, псевдоклассы, псевдоэлементы.
            </h4>
            <p>
              Псевдоэлементы - элементы которые несуществуют в HTML разметке, а
              задаются с помощью CSS с помощью специальных селекторов.
            </p>
            <p>
              Универсальные псевдоэлементы <br />
              before и after - позволяют прицепить к любому элементу страницы
              вспомогательный элемент. <br />
              Пример из этого сайта:
            </p>
            <img src="images/sBeforemCode.jpg" alt="Код с бефорем из HTML" />
            <img src="images/sBeforemStyle.jpg" alt="Стиль с бефорем" />
            <p class="with--before">Я элемент с бефорем.</p>

            <h5>Другие псевдоэлементы</h5>
            <ul>
              <li>
                placeholder - текст подсказка. (Пример меняющий все
                placeholderы)
              </li>

              &lt;input placeholder=&quot;&quot;&gt;
              <br />
              <br />
              input::placeholder{
              <br />
              color: grow;
              <br />
              }

              <li>
                file button (Загрузка файлов). Пример меняющий только для
                классов
              </li>
              &lt;input class=&quot;example--psevdo&quot;
              type=&quot;file&quot;&gt;
              <br />
              <br />
              .example--psevdo::file{
              <br />
              color: yellow;
              <br />
              }
              <li>first-letter - первая буква слова</li>
              <li>first-line - первая строка</li>
              <li>selection - кастомное выделение текста</li>
              <li class="custom--marker">
                marker - маркеры у ненумерованных списков.
              </li>
            </ul>
            <h5>псевдоклассы</h5>
            <p>
              Псевдоклассы - это такие селекторы к элементам которые
              эдовлетворяют определенным условиям.
            </p>
            <ul>
              <li>
                Наведение курсора<br />
                a:hover { <br />
                text-decoration: underline;<br />
                }
              </li>
              <li>
                Фокус в поле ввода. (Это когда tabом бегаешь по кнопкам)<br />
                input:focus {<br />
                outline: 2px solid #2563eb;<br />
                }
              </li>
              <li>
                Первый ребёнок<br />
                li:first-child {<br />
                font-weight: bold;<br />
                }
              </li>
              <li>
                Каждый второй элемент<br />
                tr:nth-child(2n) {<br />
                background: #f3f4f6;<br />
                }
              </li>
              <li>
                Элемент, который НЕ имеет класс .active<br />
                button:not(.active) {<br />
                opacity: 0.6;<br />
                }
              </li>
              <li>
                disabled. Помогает состояние интерактивного элемента когда с ним
                нельзя провзаимодействовать.
              </li>
              <li>checked характерно только для type = checkbox/redio</li>
            </ul>
            <p>
              Псевдокласс - это состояние элемента. <br />
              Псевдоэлемент - это часть элемента.
            </p>
          </div>

          <div>
            <h4>10. Перечислить единицы измерения. Различия em и rem.</h4>
            <h5>Относительные (те что измеряются относительно чего-либо)</h5>
            <ul>
              <li>% - проценты</li>
              <ul>
                <li>width (высота) - вычисляется от родительского элемента</li>
                <li>
                  height (высота) - сработает только если у родительского
                  элемента указана конкретная высота <br />
                  если прописан (position: absolut) - то вычисляется от
                  ближайшего нестатического родителя
                </li>
              </ul>
              <li>
                em - относительно размера шрифта
                <p>
                  браузер возьмет родительский элемент с текстом, найдет размер
                  этого текста, и умножит его на значение указанное в em (если
                  0.5em - то размер = размер шрифта родителя * 0.5).
                </p>
              </li>
              <li>
                rem - относительно корневого элемента разметки для тега html.
                <br />
                Пример: <br />
                html { <br />
                font-size: 10px; <br />
                } <br />
                .small{ <br />
                font-size: 0.75rem (т. е. 7.5 пикселя) <br />
                }
              </li>
              <li>
                vw - проценты от ширины вьюпорта (окна браузера). <br />
                (10vw = 10% от текущей ширины окна браузера)
              </li>
              <li>vh - проценты от высоты вьюпорта (окна браузера)</li>
              <li>fr — доля свободного пространства в CSS Grid.</li>
            </ul>
            <h5>Абсолютные (те что ни от чего не зависят)</h5>
            <ul>
              <li>
                px - пиксели. на самом деле довольно адаптивен, так как размер
                пикселя завист от экрана и устройства
              </li>
              <li>
                cm, mm, in, pt, pc — (миллиметры, сантиметры и т.д.)
                используются в печати, физические единицы.
              </li>
            </ul>
          </div>
          <div>
            <h4>
              11. Рассказать про Flexbox. flex-container, flex Items, shrink,
              grow.
            </h4>
            <a href="https://youtu.be/YG8Vhz1pAsU?si=nv_xtbo28VxSPUyt"
              >Видос "CSS Flexbox Layout. Флексы в CSS."</a
            >
            <p>
              Flexbox — это режим раскладки, в котором родитель (flex‑container)
              управляет расположением и размером своих детей (flex‑items) в
              одном направлении и может «растягивать» или «сжимать» их под
              доступное пространство. ​
            </p>
            <h5>Flex‑container</h5>
            Flex‑контейнер — элемент, у которого display: flex (типа
            классического блока, когда всю ширину занимает) или display:
            inline-flex (типа строки, занимает только требуемый для контента
            объем). <br />
            ​ Пример: <br />
            css <br />
            .container { <br />
            display: flex; (делаем контейнер flex‑контейнером) <br />
            flex-direction: row; /* ось: по горизонтали (по умолчанию) */ <br />
            gap: 16px; (расстояние между элементами) <br />
            } <br />

            Все прямые дети .container > * становятся flex‑items. <br />

            Можно легко выравнивать и распределять элементы (justify-content,
            align-items, gap).
            <ul>
              <li>
                justify-content — распределение элементов по главной оси (обычно
                горизонталь: слева, справа, по центру, с равными промежутками).
                <br />
                justify-content: center; (по главной оси в центр)
              </li>
              <li>
                align-items — по второстепенной оси (обычно вертикаль: сверху,
                снизу, по центру, растянуть). <br />
                align-items: flex-start; (по перекрёстной оси к верху)
              </li>
              <li>
                gap — расстояние между самими элементами (горизонтальные и
                вертикальные “промежутки” внутри flex/grid‑контейнера). <br />
                gap: 16px;
              </li>
            </ul>

            <div>
              <h5>Flex‑items</h5>
              Flex‑элементы — прямые дети flex‑контейнера. <br />
              <br />

              &lt;div class=&quot;container&quot;&gt;     &lt;div <br />
              class=&quot;item item--1&quot;&gt;1&lt;/div&gt;     &lt;div <br />
              class=&quot;item item--2&quot;&gt;2&lt;/div&gt;     &lt;div <br />
              class=&quot;item item--3&quot;&gt;3&lt;/div&gt; &lt;/div&gt;
              <br />
              <br />
              css <br />
              <br />
              .item { <br />
              flex-basis: 200px; (базовая ширина/высота вдоль главной оси)
              <br />
              }
            </div>
            ​ Для каждого flex‑item можно настроить:
            <ul>
              <li>
                flex-grow — как он будет расти, если есть свободное место.
              </li>
              <li>
                flex-shrink — как он будет сжиматься, если места не хватает.
              </li>
              <li>flex-basis — базовый размер до растягивания/сжатия.</li>
            </ul>

            <div>
              <h5>flex-grow (растягивание)</h5>
              flex-grow — коэффициент, который показывает, какую долю свободного
              пространства получит элемент по сравнению с соседями. <br />
              css <br />
              .item--1 { flex-grow: 1; } (получит 1 «долю») <br />
              .item--2 { flex-grow: 2; } (2 доли (в два раза больше, чем
              первый))
              <br />
              .item--3 { flex-grow: 0; } (не будет расширяться) <br />
            </div>

            <div>
              <h5>flex-shrink (сжатие)</h5>
              flex-shrink — коэффициент, который показывает, как сильно элемент
              готов сжиматься, когда контейнеру не хватает места. ​ css <br />
              .item--1 { flex-shrink: 1; } /* стандартное сжатие */ <br />
              .item--2 { flex-shrink: 0; } /* не сжимать */ <br />
              .item--3 { flex-shrink: 2; } /* можно сжимать активнее */ <br />

              Когда суммарная ширина flex‑items > ширины контейнера: <br />
              <ul>
                <li>элементы с большим flex-shrink ужимаются сильнее,</li>
                <li>
                  с flex-shrink: 0 стараются не сужать вообще (пока можно).
                </li>
              </ul>
            </div>
          </div>

          <div>
            <h4>12. Рассказать про CSS Grid.</h4>
            <a href="https://youtu.be/JrKOHNRnRMg?si=h0XrAtxVMVmOF9C8"
              >Видос про Gridы</a
            >
            CSS Grid — это система двумерной раскладки (строки + столбцы) для
            построения сеток и макетов страниц.

            <h5>Основные понятия</h5>

            <ul>
              <li>Grid‑контейнер — элемент с display: grid или inline-grid.</li>
              <li>
                Grid‑элементы — прямые дети контейнера, автоматически становятся
                «ячейками» сетки.
              </li>
              <li>Сетка состоит из:</li>
              <ul>
                <li>столбцов (columns);</li>
                <li>строк (rows);</li>
                <li>промежутков (gaps).</li>
              </ul>
            </ul>

            <h5>Как задать сетку (Минимальный пример):</h5>

            css <br />
            .grid { <br />
            display: grid; /* включаем Grid */ <br />
            grid-template-columns: 1fr 1fr 1fr; /* три равных столбца */ <br />
            grid-template-rows: auto auto; /* две строки по контенту */ <br />
            gap: 16px; /* расстояние между ячейками */ <br />
            } <br />
            <br />

            &lt;div class="grid"&gt; <br />
            &lt;div&gt;1&lt;/div&gt; <br />
            &lt;div&gt;2&lt;/div&gt; <br />
            &lt;div&gt;3&lt;/div&gt; <br />
            &lt;div&gt;4&lt;/div&gt; <br />
            &lt;div&gt;5&lt;/div&gt; <br />
            &lt;div&gt;6&lt;/div&gt; <br />
            &lt;/div&gt; <br />
            <br />

            <ul>
              <li>
                grid-template-columns / grid-template-rows задают количество и
                размер треков (1fr, 200px, repeat(3, 1fr) и т.д.).
              </li>
              <li>
                gap (или row-gap/column-gap) задаёт отступы между ячейками, не
                трогая margin.
              </li>
            </ul>

            <h5>Управление позиционированием элементов</h5>

            Каждый grid‑item можно растянуть на несколько рядов/колонок: <br />
            <br />
            ​ .item1 { <br />
            grid-column: 1 / 3; /* от линии 1 до 3 по колонкам (занять 2
            столбца) */ <br />
            grid-row: 1 / 2; /* первая строка */ <br />
            } <br />
            <br />

            .item2 { <br />
            grid-column: 3 / 4; /* третий столбец */ <br />
            grid-row: 1 / 3; /* растянуть на две строки */ <br />
            } <br />
            <br />

            <h5>Коротко:</h5>
            <ul>
              <li>
                grid-column-start, grid-column-end, grid-row-start, grid-row-end
                — управляют началом/концом по линиям сетки.
              </li>
              <li>
                Шорт‑запись: grid-column: start / end, grid-row: start / end.
              </li>
              <li>
                Плюс есть grid-template-areas, где макет можно описать текстовой
                «картой» (шпаргалочно можно просто упомянуть).
              </li>
            </ul>
            <h5>Разница Grid и Flexbox (можно фразой для билета)</h5>
            <ul>
              <li>
                Flexbox — одномерный (управляет либо строкой, либо колонкой).
              </li>
              <li>
                Grid — двумерный (строки и столбцы одновременно, удобно для
                сложных макетов).
              </li>
            </ul>
          </div>

          <div>
            <h4>
              13. Позиционирование. (absolute, relative, sticky, fixed).
              Нормальный поток в документе
            </h4>
            <a href="https://youtu.be/jQCzxM2dPWU?si=5JpAh59Iqtie0qDJ"
              >Видос про позиционирование</a
            >
            Позиционирование — это способ изменить, как элемент участвует в
            нормальном потоке и относительно чего считаются
            top/right/bottom/left.
            <h5>Нормальный поток документа (flow layout)</h5>

            <ul>
              <li>Блочные элементы идут сверху вниз, занимая всю ширину.</li>
              <li>Строчные — слева направо в строке.</li>
              <li>
                Элементы учитывают друг друга: следующий становится после
                предыдущего.
              </li>
            </ul>
            Любое «особое» позиционирование (absolute, fixed, частично sticky)
            может вытащить элемент из нормального потока.

            <div>
              <h5>position: relative</h5>
              <p>
                .box { <br />
                position: relative; <br />
                top: 10px; <br />
                left: 20px; <br />
                } <br />
              </p>
              <ul>
                <li>
                  Элемент остаётся в нормальном потоке, место за ним
                  сохраняется.
                </li>
                <li>
                  Сдвигается относительно своего исходного положения на
                  top/left/right/bottom.
                </li>
                <li>
                  Часто используется как «опорный» контейнер для position:
                  absolute внутри.
                </li>
              </ul>
            </div>
            ​

            <div>
              <h5>position: absolute</h5>
              <p>
                .child { <br />
                position: absolute; <br />
                top: 0; <br />
                right: 0; <br />
                }
              </p>
              <ul>
                <li>
                  Элемент вынут из нормального потока: соседние его «не видят».
                </li>
                <li>
                  Координаты считаются от ближайшего предка с position ≠ static
                  (обычно relative, absolute, fixed), а если такого нет — от
                  вьюпорта/страницы.
                </li>
                <li>
                  Используется для попапов, бейджей, плавающих элементов внутри
                  блока.
                </li>
              </ul>
            </div>
            <div>
              <h5>position: fixed</h5>
              <div>
                .banner { <br />
                position: fixed; <br />
                top: 0; <br />
                right: 0; <br />
                }
              </div>
              <ul>
                <li>Тоже вне нормального потока.</li>
                <li>
                  Закреплён относительно вьюпорта: не двигается при скролле.
                </li>
                <li>
                  Типичные примеры: фиксированное меню сверху, плавающая кнопка
                  «вверх».
                </li>
              </ul>
            </div>

            <div>
              <h5>position: sticky</h5>
              <div>
                .header { <br />
                position: sticky; <br />
                top: 0; <br />
                } <br />
              </div>
              <ul>
                <li>Гибрид relative и fixed.</li>
                <li>
                  Пока не доскроллили до заданного порога (top/bottom) — ведёт
                  себя как relative и остаётся в потоке.
                </li>
                <li>
                  Как только пересекли порог — «прилипает» и ведёт себя как
                  fixed в пределах своего контейнера (когда контейнер ушёл —
                  элемент тоже уходит).
                </li>
                <li>
                  Используется для липких заголовков секций, таблиц, сайдбаров.
                </li>
              </ul>
            </div>

            <div>
              <h5>Кратко для билета:</h5>
              <ul>
                <li>
                  Нормальный поток — стандартное размещение блоков и строк без
                  особого позиционирования.
                </li>
                <li>
                  relative — остаётся в потоке, но можно сдвигать от исходного
                  места.
                </li>
                <li>
                  absolute — выпадает из потока, позиционируется относительно
                  ближайшего спозиционированного предка.
                </li>
                <li>
                  fixed — выпадает из потока, приклеен к вьюпорту, не
                  скроллится.
                </li>
                <li>
                  sticky — сначала как relative, после порога скролла — как
                  fixed внутри своего контейнера.
                </li>
              </ul>
            </div>
          </div>

          <div>
            <h4>
              14. Рассказать про z-index, контекст наложения и свойство
              overflow.
            </h4>

            <img
              class="standart--pictures"
              src="images/contecstNalojeniya.jpg"
              alt="Контекст наложения"
            />

            <div>
              <h5>z-index (порядок наложения)</h5>
              <p>z-index управляет тем, кто поверх кого при перекрытии.</p>
              <ul>
                <li>
                  Работает для элементов с position, отличным от static
                  (relative, absolute, fixed, sticky) и для flex/grid‑элементов.
                </li>
                <li>
                  Чем больше z-index, тем выше слой внутри своего контекста
                  наложения: элемент с z-index: 10 будет над z-index: 1.
                </li>
              </ul>
              <p>Пример:</p>
              <pre><code>.box1 { position: absolute; z-index: 1; }
.box2 { position: absolute; z-index: 2; } /* будет сверху box1 */</code></pre>
            </div>

            <div>
              <h5>Контекст наложения (stacking context)</h5>
              <p>
                Stacking context — это локальная трёхмерная «сцена», внутри
                которой сравниваются z-index.
              </p>

              <p>Важно:</p>
              <ul>
                <li>
                  Каждый контекст наложения ведёт себя как самостоятельный слой.
                </li>
                <li>
                  Дети не могут вылезти выше элементов из других контекстов, чем
                  их родитель, даже с большим z-index.
                </li>
              </ul>

              <p>Новый контекст создаётся, если:</p>
              <ul>
                <li>элемент — корень документа (&lt;html&gt;);</li>
                <li>элемент имеет position ≠ static и z-index ≠ auto;</li>
                <li>
                  или некоторые другие свойства: opacity &lt; 1, transform,
                  filter, isolation: isolate и т.п.
                </li>
              </ul>

              <p>
                Типичный сценарий: поставил родителю position: relative;
                z-index: 1; — создал контекст; дети с z-index: 9999 всё равно не
                перепрыгнут другие блоки вне этого родителя, если сам родитель
                ниже.
              </p>
            </div>

            <div>
              <h5>overflow</h5>
              <p>
                overflow управляет тем, что делать с содержимым, которое вылезло
                за границы блока.
              </p>

              <p>Основные значения:</p>
              <ul>
                <li>
                  visible (по умолчанию) — контент спокойно вылезает наружу,
                  ничего не обрезается.
                </li>
                <li>
                  hidden — лишнее обрезается, без полос прокрутки; можно прятать
                  «хвосты» или делать маски.
                </li>
                <li>
                  scroll — всегда показываются полосы прокрутки, даже если
                  контент помещается.
                </li>
                <li>
                  auto — добавляет полосы прокрутки, только если контент
                  действительно не помещается.
                </li>
              </ul>

              <p>
                Есть отдельные оси: <br />
                box { <br />
                overflow-x: auto; /* только по горизонтали */ <br />
                overflow-y: hidden; /* по вертикали обрезаем */ <br />
                } <br />
              </p>

              <p>
                Это используют, например, для горизонтальных списков с
                прокруткой.
              </p>
            </div>
          </div>

          <div>
            <h4>
              15. CSS для типографии. (font-size, line-height и т.д) Как
              подключать шрифты на сайт.
            </h4>
            <div>
              <p>
                CSS‑типографика управляет тем, как выглядит и ведёт себя текст:
                шрифты, размеры, интервалы, переносы, декор и подключение
                нестандартных гарнитур.
              </p>
              <h5>Основные свойства для текста</h5>
              <ul>
                <li>
                  <p>
                    font-family — семейство шрифта. <br />
                    Можно указать несколько через запятую, от более конкретного
                    к запасным: <br />

                    body { <br />
                    font-family: "Roboto", "Helvetica Neue", Arial, "Noto Sans",
                    sans-serif; <br />
                    } <br />
                    Браузер берёт первый доступный шрифт; базовые семейства:
                    serif, sans-serif, monospace.
                  </p>
                </li>
                <li>
                  font-size — размер шрифта (px, em, rem, %, vw, vh и т.д.).
                </li>
                <li>
                  font-weight — жирность (обычно 100–900; 400 — normal, 700 —
                  bold).
                </li>
                <li>font-style — начертание: normal, italic, oblique.</li>
                <li>
                  line-height — интерлиньяж, расстояние между строками; часто
                  задают без единиц (коэффициент, например 1.5).
                </li>
                <li>letter-spacing — кернинг, расстояние между буквами.</li>
                <li>
                  text-indent — отступ первой строки абзаца (красная строка).
                </li>
                <li>color — цвет текста.</li>
                <li>
                  text-align — выравнивание текста: left/right/center/justify
                  (или start/end).
                </li>
                <li>
                  text-transform — преобразование регистра: uppercase,
                  lowercase, capitalize, none.
                </li>
                <li>
                  <p>
                    text-decoration — декор текста (подчёркивание, зачёркивание
                    и т.п.), шорт‑запись для:
                  </p>
                  <ul>
                    <li>
                      text-decoration-line — underline, overline, line-through,
                      none;
                    </li>
                    <li>text-decoration-color;</li>
                    <li>
                      text-decoration-style — solid, double, dotted, dashed,
                      wavy;
                    </li>
                    <li>text-decoration-thickness.</li>
                  </ul>
                  ​
                  <p>
                    .underline { <br />
                    text-decoration: underline red wavy 2px; <br />
                    }
                  </p>
                </li>
                <li>
                  text-underline-offset — расстояние от подчёркивания до текста.
                </li>
                <li>
                  text-decoration-skip-ink — как линия проходит через «хвосты»
                  букв (p, g): auto / none.
                </li>
              </ul>
            </div>
            <div>
              <h5>Переносы, обрезка и пробелы</h5>
              <ul>
                <li>
                  overflow-wrap — как переносить длинные слова:
                  <ul>
                    <li>normal — не ломать слово;</li>
                    <li>
                      break-word / anywhere — можно разрывать слово, чтобы оно
                      влезло в контейнер. Очень полезно, чтобы текст не
                      «разъезжал» верстку.
                    </li>
                  </ul>
                </li>
                <li>
                  text-overflow — как показать, что текст обрезан:
                  <ul>
                    <li>clip — просто отрезать;</li>
                    <li>ellipsis — добавить ….</li>
                  </ul>
                </li>
                <li>
                  white-space — как обрабатывать пробелы и переносы:
                  <ul>
                    <li>
                      normal — схлопывать пробелы, переносить строки (по
                      умолчанию);
                    </li>
                    <li>nowrap — не переносить строки;</li>
                    <li>
                      pre — как в &lt;pre&gt;: сохранять пробелы и переносы;
                    </li>
                    <li>
                      pre-wrap, pre-line — комбинации сохранения
                      пробелов/переносов.
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>Типичный паттерн «truncate в одну строку»:</h5>
              <p>
                .truncate { <br />
                overflow: hidden; <br />
                text-overflow: ellipsis; <br />
                white-space: nowrap; <br />
                }
              </p>
            </div>
            <div>
              <h5>Направление и ориентация текста</h5>
              <ul>
                <li>
                  writing-mode — направление строк и блоков:
                  <ul>
                    <li>
                      например, vertical-lr — текст сверху вниз, столбцы слева
                      направо.
                    </li>
                  </ul>
                </li>
                <li>
                  text-orientation — ориентация символов во вертикальном режиме
                  (upright, mixed).
                </li>
              </ul>
              <p>
                Используется для вертикальных заголовков, восточноазиатских
                текстов и т.п.
              </p>
            </div>
            <div>
              <h5>Подключение шрифтов: системные, @font-face, Google Fonts</h5>
              <p>
                Системные и базовые семейства <br />
                Браузер всегда имеет набор стандартных шрифтов:
              </p>
              <ul>
                <li>serif — с засечками;</li>
                <li>sans-serif — без засечек;</li>
                <li>monospace — моноширинные (обычно в редакторах кода).</li>
              </ul>
              <p>Через запятую описывается цепочка fallback:</p>

              <p>
                body { <br />
                font-family: "Montserrat", "Roboto", "Helvetica Neue", Arial,
                sans-serif; <br />
                }
              </p>

              <h5>Свой шрифт через @font-face</h5>
              <p>
                Когда встроенных шрифтов мало, используют @font-face и шрифты
                как файлы (.woff2, .woff).
              </p>

              <p>
                @font-face { <br />
                font-family: "Montserrat"; <br />
                font-style: normal; /* обычное начертание */ <br />
                font-weight: 400; /* нормальная жирность */ <br />
                src: <br />
                local("Montserrat"), <br />
                url("./fonts/Montserrat.woff2") format("woff2"); <br />
                font-display: swap; <br />
                } <br />
                <br />
                @font-face { <br />
                font-family: "Montserrat"; <br />
                font-style: italic; <br />
                font-weight: 400; <br />
                src: url("./fonts/MontserratItalic.woff2") format("woff2");
                <br />
                font-display: swap; <br />
                } <br />
                <br />
                body { <br />
                font-family: "Montserrat", sans-serif; <br />
                } <br />
              </p>

              <p>Ключевые моменты:</p>

              <ul>
                <li>
                  Для каждой комбинации font-weight + font-style нужен свой
                  @font-face и свой файл.
                </li>
                <li>
                  src: local(...) позволяет не качать файл, если шрифт уже есть
                  в системе пользователя.
                </li>
                <li>
                  font-display: swap — сначала показываем текст запасным
                  шрифтом, потом плавно переключаемся на загруженный; это
                  улучшает UX и перформанс.
                </li>
              </ul>
              <p>Перфоманс:</p>
              <ul>
                <li>
                  Много файлов шрифтов (например, 9 весов × 2 стиля = 18 файлов)
                  сильно бьют по загрузке.
                </li>
                <li>
                  На практике обычно используют 1–2 семейства, ограниченный
                  набор весов (например, 400 и 700) и комбинируют их в дизайне.
                </li>
              </ul>

              <p>Подключение через Google Fonts и другие сервисы</p>
              <ol>
                <li>На Google Fonts выбирается семейство, веса и стили.</li>
                <li>
                  <p>
                    Сервис даёт <link />: <br />
                    <br />
                    &lt; link <br />
                    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;1,100&display=swap"
                    <br />
                    rel="stylesheet" <br />
                    /&gt; <br />
                    <br />
                  </p>
                </li>
                <li>
                  <p>
                    В CSS: <br />
                    css <br />
                    body { <br />
                    font-family: "Roboto", sans-serif; <br />
                    }
                  </p>
                </li>
              </ol>

              <p>
                Фактически по этому URL лежит CSS с @font-face, его можно
                открыть и посмотреть. <br />

                Если шрифт не из Google Fonts (купленный, корпоративный) —
                подключают как статические файлы через @font-face, как в примере
                выше.
              </p>
            </div>
          </div>

          <div>
            <h4>
              16. CSS custom properties - CSS calc (функции сalc и var). Функции
              сlamp() для fluid typography, min(), max(). Как они помогают в
              адаптивном дизайне без медиа-запросов.
            </h4>
            <h5>CSS custom properties и var()</h5>
            <p>
              CSS‑переменные (custom properties) — это собственные значения в
              CSS, которые можно переиспользовать и переопределять. Они
              объявляются как `--имя` и читаются через `var()`.
            </p>
            <p>
              :root { <br />
              --primary-color: red; <br />
              --header-height: 80px; <br />
              } <br />

              .button { <br />
              background-color: var(--primary-color); <br />
              } <br />

              .banner { <br />
              height: calc(var(--header-height) * 2); <br />
              }
            </p>
            <h6>Особенности:</h6>
            <ul>
              <li>
                Область видимости: переменные наследуются — объявленные в
                `:root` доступны везде; можно переопределять на уровне
                блока/темы.
              </li>
              <li>
                <p>Можно делать «темы» через переопределение переменных:</p>
                <p>
                  .posts-wrapper { <br />
                  --main-color: red; <br />
                  } <br />

                  .posts-wrapper--dark { <br />
                  --main-color: black; <br />
                  } <br />

                  .post-header { <br />
                  color: var(--main-color); <br />
                  }
                </p>
              </li>
              <li>
                <p>
                  `var(--name, fallback)` — второе значение используется, если
                  переменная не определена. Допускается вложенный fallback:
                </p>
                <p>
                  .posts-wrapper { <br />
                  color: var(--primary-color, red); <br />
                  } <br />

                  .title { <br />
                  color: var(--primary-color, var(--main-color, black)); <br />
                  }
                </p>
              </li>
            </ul>
            <p>CSS‑переменные удобно использовать для:</p>
            <ul>
              <li>палитры (цвета темы, тёмная/светлая);</li>
              <li>типографики (база шрифта, scale‑фактор);</li>
              <li>отступов, размеров блоков;</li>
              <li>
                - адаптивных формул (через `calc`, `min`, `max`, `clamp`).
              </li>
            </ul>
            <div>
              <h5>Функция calc()</h5>
              <p>
                `calc()` вычисляет значение свойства по математическому
                выражению.
              </p>
              <ul>
                <li>Поддерживаются `+`, `-`, `*`, `/`.</li>
                <li>
                  Можно мешать разные единицы: `px`, `%`, `em`, `rem`, `vw`,
                  `vh` и т.д.
                </li>
                <li>
                  У **`+` и `-` обязательно должны быть пробелы** с обеих
                  сторон: `calc(100% - 20px)`, иначе браузер может воспринять
                  `-20px` как одно число.
                </li>
                <li>
                  Хотя бы у одного операнда должна быть единица измерения.
                </li>
              </ul>
              <p>Примеры:</p>
              <p>
                width: calc(100% - 20px); <br />
                width: calc(100% + (20px * 2)); <br />
                width: calc(150px / 2);
              </p>
              <p>
                (пример `calc(150px * 20px)` теоретически валиден как синтаксис,
                но на практике размеры так не задают). <br /><br />

                Практическое применение — адаптивная ширина колонок:
              </p>
              <p>
                .container { display: flex; gap: 10px; } .elem1, .elem2, .elem3
                { width: calc(100% / 3); }
              </p>
              <p>
                Раньше писали «33.333%» руками, теперь браузер сам посчитает
                точно.
              </p>
            </div>
            <div>
              <h5>min() и max()</h5>
              <ul>
                <li>`min(a, b, c)` — берёт **минимальное** значение.</li>
                <li>`max(a, b, c)` — берёт **максимальное** значение.</li>
              </ul>
              <p>Примеры:</p>
              <p>
                .selector { <br />
                width: min(70%, 800px); /* не шире 800px, но до этого — 70% */
                <br />
                } <br />

                .container { <br />
                width: max(70%, 800px); /* не уже 800px, но может быть шире
                (70%) */ <br />
                }
              </p>
              <p>Использование:</p>
              <ul>
                <li>ограничение максимальной ширины контентной области;</li>
                <li>
                  гарантия минимальной ширины/отступа на больших/маленьких
                  экранах.
                </li>
              </ul>
            </div>
            <div>
              <h5>clamp() и fluid typography</h5>
              <p>
                `clamp(min, preferred, max)` — задаёт значение, которое
                **зажато** между минимумом и максимумом, но внутри может
                меняться по формуле.
              </p>
              <p>Пример из СФУ:</p>
              <p>
                h1 { <br />
                font-size: clamp(24px, 5vw + 1rem, 64px); <br />
                }
              </p>
              <ul>
                <li>min = `24px` — заголовок никогда не станет меньше 24px.</li>
                <li>
                  preferred = `5vw + 1rem` — плавно растёт с шириной окна:
                </li>
                <ul>
                  <li>`5vw` — 5% ширины viewport;</li>
                  <li>`1rem` — базовый шрифт (обычно 16px).</li>
                </ul>
                <li>max = `64px` — заголовок никогда не станет больше 64px.</li>
              </ul>
              <p>Поведение:</p>
              <ul>
                <li>
                  На маленьких экранах, когда `5vw + 1rem < 24px`, размер =
                  24px.
                </li>
                <li>
                  На средних — размер = `5vw + 1rem`, плавная fluid‑типографика.
                </li>
                <li>
                  На больших, когда `5vw + 1rem > 64px`, размер фиксируется на
                  64px.
                </li>
              </ul>
              <p>То же можно применять к:</p>
              <ul>
                <li>отступам (`padding: clamp(...)`);</li>
                <li>ширинам/высотам блоков;</li>
                <li>gap в сетках.</li>
              </ul>
            </div>
            <div>
              <h5>Функция attr()</h5>
              <p>
                `attr()` позволяет использовать значения HTML‑атрибутов в CSS
                (ограниченно, в основном в `content` псевдоэлементов). <br />
                <br />
                Пример:
              </p>
              <p>
                .tooltip::after { <br />
                content: attr(data-tooltip); <br />
                }
              </p>
              <p>
                В контексте билета достаточно **упомянуть**, что такая функция
                есть, и что основная тема — всё же `var`, `calc`,
                `min/max/clamp`.
              </p>
            </div>
            <div>
              <h5>Как это помогает в адаптивном дизайне без медиа‑запросов</h5>
              <p>Комбинация:</p>
              <ul>
                <li>CSS‑переменных (централизованные значения);</li>
                <li>`calc()` (формулы с разными единицами);</li>
                <li>
                  `min()`, `max()`, `clamp()` (ограничения и «гибкие» размеры)
                </li>
              </ul>
              <p>позволяет:</p>
              <ul>
                <li>
                  делать **fluid typography** — размер шрифта плавно меняется от
                  ширины экрана, но не меньше/больше заданных границ;
                </li>
                <li>
                  задавать адаптивные отступы и ширины блоков, которые сами
                  подстраиваются под viewport;
                </li>
                <li>
                  ограничивать размеры без большого количества `@media` (часто
                  достаточно 1–2 правил вместо 3–5 брейкпоинтов).
                </li>
              </ul>
              <p>Типичный пример, который можно привести на экзамене:</p>
              <p>
                :root { <br />
                --space: 1.5rem; <br />
                } <br />

                .page { <br />
                padding-inline: clamp(1rem, 4vw, 3rem); <br />
                max-width: min(100% - 2 * var(--space), 1200px); <br />
                }
              </p>
              <p>Здесь без единого медиазапроса:</p>
              <ul>
                <li>отступы растут с шириной окна, но в разумных пределах;</li>
                <li>
                  контентная область не становится уже, чем надо, и не
                  разъезжается шире 1200px.
                </li>
              </ul>
              <h5>Фраза для билета:</h5>
              <p>
                > CSS custom properties (`var`) позволяют хранить значения
                (цвета, размеры, базовый font-size) и переопределять их,
                например для тёмной темы. `calc()` даёт математические выражения
                с разными единицами. `min()`, `max()` и особенно `clamp()`
                позволяют задавать «гибкие» размеры с нижней и верхней границей.
                Вместе они дают fluid‑типографику и адаптивную вёрстку, которая
                подстраивается под ширину экрана без большого числа
                медиазапросов.
              </p>
            </div>
          </div>

          <div>
            <h4>
              17. Что такое Адаптивная верстка, резиновая верстка. Breakpoints.
              В чем различия desktop first и mobile first. Что такое
              контейнерные запросы, зачем они нужны - какие проблемы решают.
            </h4>
            <div>
              <h5>Адаптивная верстка</h5>
              <p>
                Адаптивная верстка основывается на использовании медиа-запросов
                и CSS-правил. С ее помощью можно изменять стили и расположение
                элементов на странице в зависимости от размера экрана
                устройства, на котором сайт отображается. В результате сайт
                может лучше адаптироваться к различным размерам экранов, что
                повышает удобство использования сайта на мобильных устройствах.
                <br />
                Например, на компьютере, сетка, которая состоит из 3 колонок, а
                на мобильных устройствах, колонка будет одна.
              </p>
              <img
                class="standart--pictures"
                src="images/adaptivFerst.jpg"
                alt="Пример адаптивной верстки"
              />

              <p>
                .container{ <br />
                display: grid; <br />
                grid-template-columns: repeat(3, minmax(0, 1fr)); <br />
                } <br />
                @media (max-width: 768px) <br />
                .container{ <br />
                grid-template-columns: repeat(1, minmax(0, 1fr)); <br />
                }
              </p>
            </div>
            <div>
              <h5>Медиа запросы</h5>
              <p>
                Медиа-выражения - это условия, которые проверяются в CSS, чтобы
                определить, должны ли быть применены определенные стили к
                элементам на странице. Например, медиа-выражение может проверять
                ширину экрана устройства и применять соответствующие стили.
              </p>
              <p>
                Медиа-запросы - это блоки CSS-кода, которые определяют, какие
                стили должны применяться к элементам на странице в зависимости
                от результатов проверки медиа-выражений. <br />
                В этом примере медиа-запрос, который выделен синим цветов,
                содержит стили, которые будут применяться к элементам на экранах
                с максимальной шириной 768 пикселей. <br />
                В данном случае, стили изменяют размер шрифта и ширину
                контейнера. Красным цветом выделено медиа-выражение, которое
                проверяет условие. <br />
                В медиа-выражениях, при проверке ширины или высоты экрана,
                размеры обычно указываются в пикселях.
              </p>
              <p class="red--text">@media (max-width: 768px) {</p>
              <p class="blue--text">
                body { <br />
                font-size: 16px; <br />
                } <br />
                .container { <br />
                width: 100%; <br />
                } <br />
                }
              </p>
              <p>
                Типы носителей описывают общую категорию устройства. За
                исключением случаев использования логических операторов not или
                only, тип носителя является необязательным, а тип all
                предполагаемым.
              </p>
              <ul>
                <li>all - подходит для всех устройств.</li>
                <li>screen - предназначен в первую очередь для экранов.</li>
                <li>
                  print - предназначен для постраничного материала и документов.
                </li>
              </ul>
              <p>
                Иными словами, с помощью print можно задать медиазапросы для
                печати, например, убрать ненужные блоки на веб-странице, перед
                ее печатью.
              </p>
              <h5>Логические операторы запросов</h5>
              <ul>
                <li>
                  <h6>AND</h6>
                  <p>Оба условия должны соблюдаться.</p>
                  <p>
                    @media (max-width: 767px) and (orientation: portrait) {
                    <br />
                    <br />
                    }
                  </p>
                </li>

                <li>
                  <h6>OR логическое или</h6>
                  <p>
                    @media (max-width: 767px), (min-width: 768px) and
                    (max-width: 1024px) { <br />
                    <br />
                    }
                  </p>
                </li>

                <li>
                  <h6>NOT Логическое отрицание</h6>
                  <p>
                    @media not screen and (color) { <br />
                    <br />
                    }
                  </p>
                </li>
              </ul>

              <p>
                Узконаправленные @media помогают учитывать тип ввода и тему ОС
                без JS.
              </p>
              <h5>hover и pointer (тип устройства)</h5>
              <ul>
                <li>
                  hover — умеет ли основное устройство ввода «наводить»
                  указатель.
                  <ul>
                    <li>
                      @media (hover: hover) — есть нормальный hover (мышь,
                      тачпад).
                    </li>
                    <li>
                      @media (hover: none) — hover‑эффекты недоступны (чистый
                      тач).
                    </li>
                  </ul>
                </li>
                <li>
                  pointer — точность указателя.
                  <ul>
                    <li>coarse — грубый ввод (палец по экрану).</li>
                    <li>fine — точный (мышь, стилус).</li>
                    <li>none — указателя нет.</li>
                  </ul>
                </li>
              </ul>
              <p>
                Примеры: <br />
                <br />
                css <br />
                /* Палец: смартфоны / грубый тач */ <br />
                @media (hover: none) and (pointer: coarse) {} <br />
                <br />
                /* Стилус: тач с точным вводом */ <br />
                @media (hover: none) and (pointer: fine) {} <br />
                <br />
                /* Мышь/тачпад: есть hover и точный указатель */ <br />
                @media (hover: hover) and (pointer: fine) {} <br />
              </p>
              <p>
                Можно, например, анимировать цвет по :hover только на
                устройствах с мышью, а на тач‑экранах менять состояние по клику.
              </p>
              <div>
                <h5>prefers-color-scheme (тёмная/светлая тема)</h5>
                <p>prefers-color-scheme читает системную тему пользователя.</p>
                <ul>
                  <li>light — пользователь предпочитает светлую тему.</li>
                  <li>dark — тёмную.</li>
                </ul>
                <p>
                  Пример: <br />
                  <br />

                  @media (prefers-color-scheme: dark) { <br />
                  body { <br />
                  background: #020617; <br />
                  color: #e5e7eb; <br />
                  } <br />
                  } <br />
                  <br />

                  @media (prefers-color-scheme: light) { <br />
                  body { <br />
                  background: #ffffff; <br />
                  color: #020617; <br />
                  } <br />
                  } <br />
                  Так можно автоматически подстраивать сайт под тёмную/светлую
                  тему ОС без переключателя.
                </p>
              </div>
            </div>
            <div>
              <h5>Резиновая верстка</h5>
              <p>
                Она, в свою очередь, основывается на использовании относительных
                единиц измерения, таких как %, rem, em и так далее, вместо
                фиксированных значений, для задания размеров элементов на
                странице. <br />
                Например, контейнер, с шириной 100%, который содержит текст и
                при изменении размеров окна браузера контейнер будет становится
                меньше. Ну или размер текста, который можно настроить таким
                образом, чтобы он зависел от размеров окна браузера. При верстке
                эти два подхода применяются совместно. <br />
              </p>
              <p>
                .container { <br />
                width: 100%; <br />
                } <br />
                .text { <br />
                font-size: 5vw; <br />
                }
              </p>
            </div>
            <div>
              <h5>Mobile first</h5>
              <p>
                Mobile first - это подход, при котором верстка сайта
                разрабатываются с учетом мобильных устройств, то есть верстка
                начинается с самой минимальной ширины, а потом увеличивается.
                <br />
                Разберем пример, для элемента title на мобильных устройствах,
                размер шрифта будет равен 16px, <br />
                дальше, когда ширина экрана будет больше или равна 640px, размер
                шрифта будет равен 18px <br />
                и когда ширина экрана будет больше или равна 1280px, размер
                шрифта будет равен 40px <br />
                Важно заметить в mobile first подходе, в условиях, используется
                свойство - минимальная ширина
              </p>
              <p>
                От меньшего к большему <br />
                .title{ <br />
                font-size: 16px; <br />
                } <br />
                ширина экрана >= 640px <br />
                @media (min-width: 640px) <br />
                .title{ <br />
                font-size: 18px; <br />
                } <br />
                } <br />
                ширина экрана >= 1280px <br />
                @media (min-width: 1280px) <br />
                .title{ <br />
                font-size: 40px; <br />
                } <br />
                }
              </p>
            </div>
            <div>
              <h5>Desktop first</h5>
              <p>
                Desktop first - это подход, при котором дизайн и верстка сайта
                разрабатываются с учетом десктопных компьютеров, то есть верстка
                начинается с самой максимальной ширины, а потом уменьшается.
                <br />
                Разберем пример, для элемента title на компьютерах размер шрифта
                будет равен 40px, <br />
                дальше, когда ширина экрана будет меньше или равна 1280px,
                размер шрифта будет равен 18px <br />
                и когда ширина экрана будет меньше или равна 640px, размер
                шрифта будет равен 16px <br />
                Важно заметить в Desktop first подходе, в условиях, используется
                свойство - максимальная ширина <br />
              </p>
              <p>
                От большего к меньшему <br />
                .title{ <br />
                font-size: 40px; <br />
                } <br />

                ширина экрана < 1280px <br />
                @media (max-width: 1279px) <br />
                .title{ <br />
                font-size: 18px; <br />
                } <br />
                } <br />
                ширина экрана < 640px <br />
                @media (max-width: 639px) <br />
                .title{ <br />
                font-size: 16px; <br />
                } <br />
                }
              </p>
            </div>
            <div>
              <h5>Breakpoint</h5>
              <p>
                Breakpoints - это настраиваемая ширина, которая определяет, как
                адаптивный макет ведет себя на разных устройствах или размерах
                области просмотра. <br />
                Самые популярные размеры, которые используются в адаптивной
                верстке, это <br />
                640,768,1024,1280,1536px <br />
                576,768,992,1200,1400px <br />
                и другие.
              </p>
              <p>
                Обсудим, как найти контентную область, то есть как создать
                контейнер и отцентрировать его. <br />
                Практически все сайты, которые вы посещаете, отцентрированы,
                значит, есть пустое пространство слева и справа <br />
                На данном изображении, в синей метке, вы видите размер в 1260px,
                то есть дизайнер, при создании дизайна, определяет основную
                область контента, еще правильный дизайнер, создает дизайн с
                помощью системы сеток, это розовые колонки, они помогают при
                верстке сайтов.
              </p>
              <img
                src="images/centrovka.jpg"
                alt="Пример центрирования контента"
              />
              <p>
                И для того, чтоб отцентрировать контент, нужно использовать
                такие css свойства:
              </p>
              <ul>
                <li>задать максимальную ширину</li>
                <li>внутренние отступы - padding</li>
                <li>
                  внешние отступы - margin слева и справа задать на значение
                  auto
                </li>
              </ul>
              <p>
                Почему же 1292px? Потому что при верстке, нужно задавать
                безопасные отступы, например по 16px, а в мобильной версии,
                например по 10, <br />
                Иначе, при изменении размеров окна браузера, контент будет
                соприкасаться с окном браузера, по левую и правую сторону.
                <br />
                Нужно обязательно задавать минимальный отступ, иными словами -
                задавать пустое пространство. <br />
              </p>
              <p>
                .container { <br />
                max-width: 1292px; 1260 + 16 + 16 <br />
                padding-left: 16px; <br />
                padding-right: 16px; <br />
                width: 100%; <br />
                margin-right: auto; <br />
                margin-left: auto; <br />
                }
              </p>
            </div>
            <div>
              <h5>Контейнерные запросы</h5>
              <p>
                Контейнерные запросы позволяют применять стили к компоненту в
                зависимости от размера его родительского контейнера, а не от
                ширины всего экрана (как в обычных media‑запросах).
              </p>
              <h6>Что такое контейнерные запросы</h6>
              <p>Механика:</p>
              <ol>
                <li>
                  <p>
                    Сначала помечаем блок как «контейнер»: <br />

                    .card-list { <br />
                    container-type: inline-size; /* смотреть на ширину
                    контейнера */ <br />
                    container-name: cards; /* опциональное имя */ <br />
                    }
                  </p>
                </li>
                <li>
                  <p>
                    Потом внутри пишем @container (аналог @media, но не по
                    viewport, а по контейнеру): <br />
                    <br />

                    .card { <br />
                    padding: 16px; <br />
                    } <br />
                    <br />

                    @container cards (min-width: 600px) { <br />
                    .card { <br />
                    display: grid; <br />
                    grid-template-columns: 120px 1fr; <br />
                    gap: 16px; <br />
                    } <br />
                    }
                  </p>
                </li>
              </ol>
              <p>
                Если .card-list стала шире 600px, карточки сами перестраиваются
                в более сложный вид; если .card-list узкая (например, в
                сайдбаре) — карточки остаются компактными. Формально:
              </p>
              <ul>
                <li>
                  container-type: inline-size / size включает
                  «контейнер‑контекст», по которому можно делать запросы.
                </li>
                <li>
                  @container (min-width: 500px) { ... } — условие, завязанное на
                  размер контейнера, а не viewport.
                </li>
              </ul>
              <h5>Какую проблему они решают</h5>
              <p>
                Проблема обычных @media: Media‑запросы смотрят только на окно
                браузера, а не на то, куда именно вставлен компонент.
              </p>
              <p>Один и тот же компонент может быть:</p>
              <ul>
                <li>широкой карточкой в контенте;</li>
                <li>
                  узким виджетом в боковой колонке. <br />
                  При подходе только с @media он «подстраивается под экран в
                  целом», а не под реальную ширину своего блока, и ломается.
                </li>
              </ul>
              <p>Контейнерные запросы решают это:</p>
              <ul>
                <li>
                  Компонент делает свою адаптацию, глядя на свой контейнер, а не
                  глобальные breakpoints.
                </li>
                <li>
                  Можно сделать по‑настоящему переиспользуемые компоненты: один
                  и тот же блок карточки/меню/таблицы корректно ведёт себя в
                  разных местах макета (узкая колонка, широкая область, карточка
                  в сетке и т.д.).
                </li>
              </ul>
              <h6>Кратко для билета:</h6>
              <p>
                Контейнерные запросы (@container) — это «media‑запросы для
                элементов»: они применяют стили к дочерним элементам в
                зависимости от размеров их контейнера (container-type:
                inline-size/size). Они решают проблему классической адаптивной
                верстки, где @media смотрят только на ширину viewport, из‑за
                чего компонент не знает, в узком он блоке или в широком. С
                контейнерными запросами компоненты становятся по‑настоящему
                адаптивными и переиспользуемыми без жёсткой привязки к
                глобальным breakpoint’ам.
              </p>
            </div>
          </div>

          <div>
            <h4>
              18. Изображения. Рассказать про основные атрибуты, зачем указывать
              width - height, alt. Адаптивные изображения (srcset и sizes).
            </h4>
            <div>
              <h5>Основные атрибуты изображений</h5>
              <p>
                &lt;img src=&quot;photo.jpg&quot; alt=&quot;Описание
                изображения&quot; width=&quot;600&quot;
                height=&quot;400&quot;&gt;
              </p>
              <ul>
                <li>`src` — путь к файлу изображения.</li>
                <li>
                  `alt` — текстовое описание картинки:
                  <ul>
                    <li>читается скринридерами (доступность);</li>
                    <li>показывается, если картинка не загрузилась;</li>
                    <li>
                      используется поисковиками. <br />
                      Для декоративных картинок `alt=""`.
                    </li>
                  </ul>
                </li>
                <li>
                  `width` / `height` — исходные размеры изображения в пикселях.
                  Зачем указывать:
                  <ul>
                    <li>
                      браузер заранее резервирует нужное место под картинку и
                      **не дёргает верстку** при загрузке (меньше layout shift,
                      лучше Core Web Vitals);
                    </li>
                    <li>
                      пропорции сохраняются, даже если дальше картинка
                      масштабируется через CSS.
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>Адаптивные изображения: srcset и sizes</h5>
              <p>
                Задача: один тег `<img />`, но разные файлы для разных экранов и
                плотностей пикселей, чтобы не грузить лишние мегабайты.
              </p>
              <p>
                &lt;img <br />
                  src=&quot;elva-fairy-800w.jpg&quot;<br />
                  srcset=&quot;<br />    elva-fairy-320w.jpg 320w,<br />   
                elva-fairy-480w.jpg 480w,<br />
                elva-fairy-800w.jpg 800w<br />  &quot;<br />  sizes=&quot;<br /> 
                  (max-width: 320px) 280px,<br />
                (max-width: 480px) 440px,<br />    800px<br />  &quot;<br /> 
                alt=&quot;Elva dressed as a fairy&quot;<br />/&gt;
              </p>
            </div>
            <div>
              <h5>srcset</h5>
              <p>
                `srcset` — список вариантов изображений с их реальной шириной:
              </p>
              <ul>
                <li>формат: `имя-файла ширинаw`;</li>
                <li>
                  `w` — это «ширина в CSS‑пикселях», не `px` в CSS‑свойстве.
                </li>
              </ul>
              <p>
                Пример: <br />
                <br />
                srcset="small.jpg 300w, medium.jpg 600w, large.jpg 1200w" <br />
                `src` остаётся обязательным (fallback), `srcset` дополняет его,
                давая браузеру выбор.
              </p>
            </div>
            <div>
              <h5>sizes</h5>
              <p>
                `sizes` говорит браузеру: **какую ширину слот под изображение
                примерно будет занимать** при разных ширинах вьюпорта. <br />
                <br />
                Формат: список `&lt;media&gt; &lt;slot-width&gt;`, последняя
                запись — значение по умолчанию.
              </p>
              <p>
                sizes="(max-width: 600px) 100vw, <br />
                (max-width: 1200px) 50vw, <br />
                33vw"
              </p>
              <p>Читается так:</p>
              <ul>
                <li>
                  до 600px ширины экрана — изображение ≈ 100% ширины окна;
                </li>
                <li>от 600 до 1200 — ≈ 50vw;</li>
                <li>выше 1200 — ≈ 33vw.</li>
              </ul>
              <p>Алгоритм выбора браузером:</p>
              <ol>
                <li>Берёт текущую ширину viewport.</li>
                <li>
                  По `sizes` вычисляет ожидаемую ширину слота (например, `370px`
                  или `50vw`).
                </li>
                <li>
                  Умножает на плотность пикселей (DPR, например 2 для Retina).
                </li>
                <li>
                  Из `srcset` выбирает файл, чья `w` ближе всего к полученному
                  значению, но **не меньше**, чтобы не терять качество.
                </li>
              </ol>
            </div>
            <div>
              <h5>Пример более короткий из СФУ:</h5>
              <p>
                &lt;img<br />
                  src=&quot;/img/image.jpg&quot;<br />
                  srcset=&quot;/img/image1.jpg 370w,<br />
                          /img/image2.jpg 600w,<br />
                          /img/image3.jpg 1920w&quot;<br />
                  sizes=&quot;(max-width: 991px) 370px, 600px&quot;<br />
                  alt=&quot;Пример изображения&quot;<br />/&gt;
              </p>
              <ul>
                <li>при viewport ≤ 991px слот ≈ 370px;</li>
                <li>при viewport > 991px — 600px;</li>
                <li>
                  для Retina‑экрана браузер выберет более крупное изображение
                  (чтобы не выглядело мыльно).
                </li>
              </ul>
            </div>
            <div>
              <h5>decoding и минимальный набор атрибутов</h5>
              <p>Рекомендуемый минимальный набор:</p>
              <p>
                &lt;img<br />
                  decoding=&quot;async&quot;<br />
                  loading=&quot;lazy&quot;<br />
                  src=&quot;/img-1920.jpg&quot;<br />
                  srcset=&quot;<br />    /img-640.jpg 640w,<br />
                /img-920.jpg 920w,<br />
                /img-1280.jpg 1280w,<br />
                /img-1560.jpg 1560w<br />  &quot;<br />
                  sizes=&quot;50vw&quot;<br />
                  alt=&quot;Описание&quot;<br />/&gt;
              </p>
              <ul>
                <li>
                  `decoding="async"` — браузер может декодировать картинку
                  асинхронно, не блокируя рендер.
                </li>
                <li>
                  `loading="lazy"` — отложенная загрузка (можно упомянуть, но не
                  обязательно для билета).
                </li>
                <li>`sizes="50vw"` — слоту примерно половина ширины окна.</li>
              </ul>
            </div>
            <div>
              <h5>Адаптивные изображения в CSS: image-set</h5>
              <p>
                Для фоновых картинок (через `background-image`) есть похожая
                функция `image-set()`:
              </p>
              <p>
                .hero { <br />
                background-image: image-set( <br />
                "image1.jpg" 1x, <br />
                "image2.jpg" 2x, <br />
                "image3.webp" 3x type("image/webp") <br />
                ); <br />
                }
              </p>
              <ul>
                <li>
                  Браузер сам выбирает подходящее изображение по плотности
                  пикселей и поддержке формата (например, WebP).
                </li>
              </ul>
            </div>
            <div>
              <h5>Если сжать до формулировки для билета:</h5>
              <p>
                > Основные атрибуты: `src` — путь к картинке, `alt` — текстовое
                описание (доступность, SEO), `width`/`height` — исходный размер,
                чтобы браузер заранее зарезервировал место и не дёргал верстку.
                Адаптивные изображения делаются через `srcset` и `sizes`:
                `srcset` даёт браузеру список файлов с их шириной (`300w`,
                `600w`, `1200w`), `sizes` — описывает, какую ширину слот под
                изображение занимает при разных ширинах экрана. Браузер смотрит
                на viewport и плотность пикселей и сам выбирает самый подходящий
                вариант, не загружая лишние большие файлы. Для фоновых
                изображений похожую задачу решает функция `image-set()` в CSS.
              </p>
            </div>
          </div>

          <div>
            <h4>
              19. Ссылки в HTML: атрибуты href, target, rel (nofollow,
              noopener). Что такое якорные ссылки (#id) и как они работают.
              Безопасность ссылок (XSS).
            </h4>
            <p>
              Ссылка в HTML — это тег &lt;a&gt;, у которого через атрибуты
              управляется адрес, способ открытия и безопасность.
            </p>
            <div>
              <h5>href и target</h5>
              <p>
                &lt;a href=&quot;https://example.com&quot;
                target=&quot;_blank&quot;&gt;Открыть сайт&lt;/a&gt;
              </p>
              <ul>
                <li>`href` — адрес, куда ведёт ссылка (URL или `#якорь`).</li>
                <li>
                  `target` — где открыть:
                  <ul>
                    <li>`_self` — в этом же окне (по умолчанию);</li>
                    <li>`_blank` — в новой вкладке/окне;</li>
                    <li>реже `_parent`, `_top`.</li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>rel: nofollow, noopener (и немного noreferrer)</h5>
              <p>
                Атрибут `rel` описывает отношение текущей страницы к целевой.
                Для билета важны:
              </p>
              <p>
                &lt;a<br />
                  href=&quot;https://external.com&quot;<br />
                  target=&quot;_blank&quot;<br />
                  rel=&quot;nofollow noopener noreferrer&quot;<br />>   Внешняя
                ссылка<br />
                &lt;/a&gt;
              </p>
              <ul>
                <li>
                  `rel="nofollow"` — рекомендует поисковикам **не передавать
                  SEO‑вес** по этой ссылке и не учитывать её как «доверенную
                  рекомендацию». Часто ставят на рекламные, пользовательские или
                  нежелательные внешние ссылки.
                </li>
                <li>
                  `rel="noopener"` — защита от reverse tabnabbing:
                  <ul>
                    <li>
                      при `target="_blank"` новая вкладка получает доступ к
                      `window.opener` и теоретически может изменить исходную
                      страницу (подменить URL, внедрить фишинг);
                    </li>
                    <li>
                      `noopener` запрещает доступ к `window.opener`, новая
                      вкладка живёт отдельно.
                    </li>
                  </ul>
                </li>
                <li>
                  `rel="noreferrer"` (можно упомянуть коротко) — дополнительно
                  скрывает заголовок `Referer`, целевой сайт не знает, откуда
                  пришёл пользователь.
                </li>
              </ul>
              <p>
                На практике безопасные внешние ссылки с `_blank` оформляют так:
                <br />
                <br />

                &lt;a href=&quot;https://example.com&quot;
                target=&quot;_blank&quot; rel=&quot;noopener
                noreferrer&quot;&gt;...&lt;/a&gt;
              </p>
            </div>
            <div>
              <h5>Якорные ссылки (#id)</h5>
              <p>
                Якорная ссылка ведёт **на определённое место на странице**, а не
                на новый URL.
              </p>
              <ol>
                <li>
                  Элементу присваивается `id`:
                  <p>&lt;h2 id=&quot;forms&quot;&gt;Формы&lt;/h2&gt;</p>
                </li>
                <li>
                  Ссылка ссылается на этот id через `#`:
                  <p>
                    &lt;a href=&quot;#forms&quot;&gt;Перейти к разделу
                    «Формы»&lt;/a&gt;
                  </p>
                </li>
              </ol>
              <p>При клике: <br /></p>
              <ul>
                <li>браузер скроллит до элемента с указанным `id`;</li>
                <li>в адресной строке появляется `#forms` (фрагмент URL).</li>
              </ul>
              <p>
                Якорь может вести и на другой документ:
                `href="/page.html#section-2"`.
              </p>
            </div>
            <div>
              <h5>Безопасность ссылок и XSS</h5>
              <p>
                XSS (cross‑site scripting) — когда злоумышленник добивается
                выполнения своего JavaScript‑кода в браузере пользователя.
                Ссылки тоже могут быть каналом атаки. <br />
                <br />
                Опасные моменты:
              </p>
              <ul>
                <li>
                  Динамическое подставление `href` из пользовательского ввода
                  без проверки:
                  <ul>
                    <li>
                      злоумышленник может подставить
                      `href="javascript:alert(1)"` или URL с вредоносным
                      скриптом;
                    </li>
                    <li>при клике такой код выполнится в контексте сайта.</li>
                  </ul>
                </li>
              </ul>
              <p>Основные меры:</p>
              <ul>
                <li>
                  Никогда не вставлять пользовательский ввод напрямую в `href`
                  без валидации и экранирования.
                </li>
                <li>
                  Разрешать только безопасные протоколы (`http`, `https`, при
                  необходимости `mailto`, `tel`), отфильтровывать `javascript:`,
                  `data:` и т.п. (часто через проверку `URL.protocol`).
                </li>
                <li>
                  Для внешних ссылок с `_blank` добавлять `rel="noopener"` (и по
                  желанию `noreferrer`) против tabnabbing.
                </li>
              </ul>
            </div>
            <div>
              <h5>Формулировка для билета:</h5>
              <p>
                > Якорные ссылки (`href="#id"`) ведут к элементу с заданным `id`
                на текущей странице. Для безопасности ссылок важно: не
                подставлять пользовательские данные в `href` без проверки
                (защита от XSS через `javascript:`‑URL) и при `target="_blank"`
                использовать `rel="noopener"`/`noreferrer`, чтобы новая вкладка
                не могла управлять исходной страницей и не получала лишнюю
                информацию.
              </p>
            </div>
          </div>

          <div>
            <h4>
              20. Как встраивать SVG в HTML. Преимущества SVG над растровыми
              изображениями. Анимация SVG с CSS.
            </h4>
            <div>
              <h5>SVG</h5>
              <p>
                SVG — это **векторная графика** в виде XML‑разметки, которая
                отлично подходит для иконок, логотипов и иллюстраций в вебе.
              </p>
            </div>
            <div>
              <h5>Преимущества SVG</h5>
              <ul>
                <li>
                  Масштабируется без потери качества на любых экранах и DPI
                  (всегда чёткий логотип/иконка).
                </li>
                <li>
                  Обычно маленький размер файла для простых форм и иконок
                  (меньше, чем PNG/JPEG для того же логотипа).
                </li>
                <li>
                  Текстовый формат: можно править в редакторе кода, хранить в
                  Git, генерировать.
                </li>
                <li>
                  Стилизуется через CSS (`fill`, `stroke`, `transform`) и
                  управляется JS, поддерживает анимацию.
                </li>
                <li>
                  Удобен для иконок, логотипов, диаграмм, карт, схем. Растровые
                  форматы лучше для сложных фотографий.
                </li>
              </ul>
            </div>
            <div>
              <h5>Как встраивать SVG в HTML</h5>
              <ol>
                <li>
                  **Встроенный (inline SVG)** — максимальный контроль (для
                  анимаций и стилей):
                  <p>
                    &lt;svg width=&quot;100&quot; height=&quot;100&quot;
                    viewBox=&quot;0 0 100 100&quot;
                    xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  
                    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot;
                    r=&quot;40&quot; fill=&quot;red&quot; /&gt; &lt;/svg&gt;
                  </p>
                  <div>
                    <svg
                      width="100"
                      height="100"
                      viewBox="0 0 100 100"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <circle cx="50" cy="50" r="40" fill="red" />
                    </svg>
                  </div>
                  <ul>
                    <li>
                      Доступен как обычный DOM — можно менять атрибуты CSS/JS.
                    </li>
                  </ul>
                </li>
                <li>
                  Через &lt;img&gt; (статика, кеширование):
                  <p>
                    &lt;img src=&quot;icon.svg&quot; alt=&quot;Логотип
                    компании&quot; width=&quot;120&quot;
                    height=&quot;120&quot;&gt;
                  </p>
                  <div>
                    <img
                      src="icon.svg"
                      alt="Логотип компании"
                      width="120"
                      height="120"
                    />
                  </div>
                  <ul>
                    <li>
                      Просто как картинка, хорошо кешируется браузером, но
                      внутренние элементы нельзя анимировать/красить по CSS.
                    </li>
                  </ul>
                </li>
                <li>
                  Фоном в CSS:
                  <p>
                    .logo { <br />
                    background-image: url("icon.svg"); <br />
                    }
                  </p>
                </li>
                <li>
                  &lt;object&gt;/&lt;embed&gt; обычно для отдельных сложных
                  SVG‑документов, реже для иконок.
                </li>
              </ol>
            </div>
            <div>
              <h5>Базовая теория по &lt;svg&gt;</h5>
              <p>Главное, что нужно для билета:</p>
              <ul>
                <li>
                  <p>
                    &lt;svg&gt; — корневой контейнер, задаёт область рисования.
                    <br />
                    Важные атрибуты:
                  </p>
                  <ul>
                    <li>`width` / `height` — отображаемый размер;</li>
                    <li>
                      `viewBox="minX minY width height"` — внутренняя система
                      координат для масштабирования.
                    </li>
                  </ul>
                </li>
                <li>
                  Теги фигур (знать по названию и назначению):
                  <ul>
                    <li>&lt;rect&gt; — прямоугольник;</li>
                    <li>&lt;circle&gt; — круг;</li>
                    <li>&lt;ellipse&gt; — эллипс;</li>
                    <li>&lt;line&gt; — линия;</li>
                    <li>
                      &lt;polyline&gt; / &lt;polygon&gt; — ломаная /
                      многоугольник;
                    </li>
                    <li>
                      &lt;path&gt; — произвольный контур, самый универсальный.
                    </li>
                  </ul>
                </li>
              </ul>
              <p>Общие атрибуты оформления:</p>
              <ul>
                <li>fill — цвет заливки;</li>
                <li>stroke — цвет обводки;</li>
                <li>stroke-width — толщина контура.</li>
              </ul>
              <p>
                Этого набора достаточно, чтобы объяснить, что SVG — именно язык
                разметки, а не просто картинка.
              </p>
            </div>
            <div>
              <h5>Анимация SVG с помощью CSS</h5>
              <p>
                Чтобы анимировать SVG через CSS, его обычно **встраивают
                инлайном**, чтобы элементы были в DOM. <br />
                <br />
                Пример простой анимации круга:
              </p>
              <p>
                &lt;svg width=&quot;100&quot; height=&quot;100&quot;
                viewBox=&quot;0 0 100 100&quot;&gt;   &lt;circle    
                class=&quot;pulse&quot;     cx=&quot;50&quot;    
                cy=&quot;50&quot;     r=&quot;40&quot;     fill=&quot;red&quot;
                  /&gt; &lt;/svg&gt;
              </p>
              <div>
                <svg width="100" height="100" viewBox="0 0 100 100">
                  <circle class="pulse" cx="50" cy="50" r="40" fill="red" />
                </svg>
              </div>
              <p>
                .pulse { <br />
                animation: pulse 2s infinite; <br />
                } <br />
                <br />
                @keyframes pulse { <br />
                0% { r: 40; } <br />
                50% { r: 50; } <br />
                100% { r: 40; } <br />
                }
              </p>
              <ul>
                <li>
                  Анимируются SVG‑атрибуты (`r`, `stroke-dashoffset`,
                  `transform` и т.п.) как обычные анимируемые свойства.
                </li>
              </ul>
              <p>
                Частый паттерн — эффект «рисования» линий для `path` через
                `stroke-dasharray` и `stroke-dashoffset`:
              </p>
              <p>
                .path { <br />
                stroke-dasharray: 300; <br />
                stroke-dashoffset: 300; <br />
                animation: draw 2s linear forwards; <br />
                } <br />
                <br />
                @keyframes draw { <br />
                to { stroke-dashoffset: 0; } <br />
                }
              </p>
              <p>Можно также:</p>
              <ul>
                <li>добавлять hover‑эффекты (смена `fill`, `stroke`);</li>
                <li>
                  комбинировать с трансформациями (`transform: rotate`, `scale`)
                  прямо на SVG‑элементах.
                </li>
              </ul>
            </div>
            <div>
              <h5>Краткая формулировка для билета:</h5>
              <p>
                > SVG — это векторная XML‑графика, которая масштабируется без
                потери качества и хорошо подходит для иконок и логотипов.
                Встраивать SVG можно инлайном (&lt;svg&gt;...&lt;/svg&gt; — даёт
                доступ к отдельным элементам для CSS/JS), как обычную картинку в
                &lt;img src="icon.svg" /&gt; или фоном через `background-image`.
                SVG легко анимировать CSS: например, инлайн‑SVG позволяет менять
                радиус круга, цвет заливки, параметры обводки, а для линий часто
                анимируют `stroke-dasharray`/`stroke-dashoffset`, создавая
                эффект «рисования» контура.
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h3>Вопросы по JS</h3>
      <div>
        <h4>Function Declaration - Function Expression. Стрелочные функции.</h4>
        <div>
          <h5>Function Declaration</h5>
          <p>
            это объявление функции отдельной инструкцией `function`, её можно
            вызывать **до и после** места объявления из того же блока, потому
            что она поднимается (hoisting).
          </p>
          <p>
            Синтаксис: <br />
            <br />

            function sum(a, b) { <br />
            return a + b; <br />
            } <br />
            console.log(sum(2, 3)); // 5
          </p>
          <ul>
            <li>Всегда есть имя функции.</li>
            <li>
              Декларации обрабатываются до исполнения кода, поэтому `sum()`
              можно вызвать выше по файлу.
            </li>
          </ul>
        </div>
        <div>
          <h5>Function Expression</h5>
          <p>
            это когда функция создаётся как значение в выражении и, например,
            присваивается в переменную. Работает как обычное значение; функцию
            можно передавать, хранить в массиве и т.д. Вызывать можно **только
            после** строки, где она создана.
          </p>
          <p>
            Синтаксис: <br />
            <br />

            const sum = function (a, b) { <br />
            return a + b; <br />
            };<br />

            console.log(sum(2, 3)); // 5
          </p>
          <p>Ключевые моменты для ответа:</p>
          <ul>
            <li>Функция становится значением переменной `sum`.</li>
            <li>
              Не поднимается как декларация: если вызвать `sum()` до этой
              строки, будет ошибка.
            </li>
            <li>
              <p>
                Бывает анонимной (без имени) и именованной (редко нужно):
                <br /><br />
                const sum = function sumImpl(a, b) { <br />
                return a + b;<br />
                };
              </p>
            </li>
          </ul>
        </div>
        <div>
          <h5>Стрелочные функции</h5>
          <p>
            это укороченный синтаксис function expression, всегда выражение,
            пишется через `=>`, часто используется как коллбэк (в `map`,
            `filter`, обработчиках событий). У стрелочных функций **нет своего
            `this`**, `arguments`, `new`, они берут `this` снаружи.
          </p>
          <p>
            Синтаксис: <br /><br />

            Обычный вариант: <br />
            <br />

            const sum = (a, b) => { <br />
            return a + b;<br />
            };
          </p>
          <p>
            Короткая запись (одно выражение → не нужны `return` и фигурные
            скобки): <br /><br />

            const sum = (a, b) => a + b;
          </p>
          <p>
            Если один параметр, скобки можно опустить: <br /><br />

            const square = x => x * x;<br /><br />

            Если нет параметров: <br /><br />

            const sayHi = () => console.log("Hi");
          </p>
        </div>
        <div>
          <h4>Что важно подчеркнуть на экзамене</h4>
          <ol>
            <li>
              Function Declaration
              <ul>
                <li>Объявляется как `function name(...) { ... }`.</li>
                <li>Поднимается (hoisting): доступна до места объявления.</li>
              </ul>
            </li>
            <li>
              Function Expression
              <ul>
                <li>
                  Функция создаётся внутри выражения, чаще всего присваивается в
                  переменную: `const f = function(...) {}`.
                </li>
                <li>
                  Не поднимается как декларация: её можно вызывать только после
                  строки объявления.
                </li>
              </ul>
            </li>
            <li>
              Стрелочные функции
              <ul>
                <li>
                  Это всегда **function expression**: `const f = (...) => { ...
                  }`.
                </li>
                <li>Более короткий синтаксис, удобно для коллбэков.</li>
                <li>
                  Нет собственного `this` и `arguments`, они берутся из внешнего
                  окружения. Это важно для работы в методах и коллбэках
                  (например, в `setTimeout`).
                </li>
              </ul>
            </li>
          </ol>
        </div>
      </div>
      <div>
        <h4>
          Функция высшего порядка. Чистая функция. Побочный эффект. Колбэки.
          Замыкание.
        </h4>
        <div>
          <h5>Функция высшего порядка (Higher-order function)</h5>
          <p>
            Определение: функция высшего порядка — это функция, которая либо
            **принимает другую функцию как аргумент**, либо **возвращает функцию
            как результат** (или и то, и другое).
          </p>
          <p>
            Пример 1 — принимает функцию (колбэк): <br /><br />

            function repeat(times, callback) { <br />
            for (let i = 0; i < times; i++) { <br />
            callback(i); <br />
            } <br />
            } <br />
            <br />

            repeat(3, (i) => { <br />
            console.log(`Итерация ${i}`); <br />
            });
          </p>
          <p>
            `repeat` — функция высшего порядка, потому что принимает другую
            функцию `callback`.
          </p>
          <p>
            Пример 2 — возвращает функцию: <br />
            <br />

            function makeMultiplier(k) { <br />
            return function (x) { <br />
            return x * k; <br />
            }; <br />
            } <br />

            const double = makeMultiplier(2); <br />
            console.log(double(5)); // 10 <br />
          </p>
          <p>
            `makeMultiplier` — функция высшего порядка, возвращающая другую
            функцию.
          </p>
        </div>
        <div>
          <h5>Чистая функция (Pure function)</h5>
          <p>Определение: чистая функция — это функция, которая:</p>
          <ol>
            <li>
              при одних и тех же входных данных всегда возвращает один и тот же
              результат;
            </li>
            <li>
              не имеет побочных эффектов (не меняет внешние данные, не лезет в
              DOM, сеть, консоль и т.д.).
            </li>
          </ol>
          <p>
            Пример чистой функции: <br />
            <br />

            function sum(a, b) { <br />
            return a + b; <br />
            }
          </p>
          <ul>
            <li>Всегда `sum(2, 3) === 5`.</li>
            <li>Ничего вне себя не трогает.</li>
          </ul>
        </div>
        <div>
          <h5>Нечистая функция (антипример):</h5>
          <p>
            let count = 0; <br />
            <br />

            function increment() { <br />
            count++; // меняет внешнюю переменную → побочный эффект <br />
            console.log(count); // вывод в консоль → тоже побочный эффект <br />
            }
          </p>
        </div>
        <div>
          <h5>Побочный эффект (Side effect)</h5>
          <p>
            Определение: побочный эффект — это любое изменение вне локальной
            области функции или взаимодействие с внешним миром: изменение
            глобальных переменных, аргументов по ссылке, DOM, запросы к серверу,
            логирование, рандом, работа с временем и т.д.
          </p>
          <p>
            Примеры побочных эффектов: <br /><br />

            let state = 0; <br />
            function bad(x) { <br />
            state = x; // мутируем внешнее состояние <br />
            document.body.textContent = x; // меняем DOM <br />
            console.log('done'); // выводим в консоль <br />
            } <br />
            <br />

            Все эти действия делают функцию нечистой.
          </p>
        </div>
        <div>
          <h5>Колбэк (Callback)</h5>
          <p>
            Определение: колбэк — это функция, которую передают в другую функцию
            как аргумент, чтобы та вызвала её позже (как «обратный вызов»).
          </p>
          <p>
            Пример с `setTimeout`: <br />
            <br />

            setTimeout(() => { <br />
            console.log('Прошло 1 секунда'); <br />
            }, 1000); <br />
            <br />

            Анонимная стрелочная функция `() => { ... }` здесь — колбэк, который
            `setTimeout` вызовет спустя 1000 мс.
          </p>
          <p>
            Пример с массивом: <br />
            <br />

            const arr = [1, 2, 3]; <br />
            const doubled = arr.map(x => x * 2); // x => x * 2 — колбэк <br />
            <br />

            `map` — функция высшего порядка, `x => x * 2` — колбэк.
          </p>
        </div>
        <div>
          <h5>Замыкание (Closure)</h5>
          <p>
            Замыкание — это функция, которая запоминает переменные из внешней
            (родительской) области видимости и может использовать их даже после
            того, как внешняя функция завершила выполнение.
          </p>
          <p>
            Классический пример: <br />
            <br />

            function makeCounter() { <br />
            let count = 0; <br />
            <br />

            return function () { <br />
            count++; <br />
            return count; <br />
            }; <br />
            } <br />
            <br />

            const counter = makeCounter(); <br />

            console.log(counter()); // 1 <br />
            console.log(counter()); // 2 <br />
            console.log(counter()); // 3
          </p>
          <ul>
            <li>
              makeCounter вызвали один раз, она вернула внутреннюю функцию.
            </li>
            <li>
              Внутренняя функция «замыкает» переменную `count` и продолжает к
              ней иметь доступ.
            </li>
          </ul>
          <p>
            Ещё короткий пример с параметром: <br />
            <br />

            function makeAdder(a) { <br />
            return function (b) { <br />
            return a + b; <br />
            }; <br />
            } <br />
            <br />

            const add5 = makeAdder(5); <br />
            console.log(add5(10)); // 15 <br />
            <br />

            Внутренняя функция помнит `a` из внешней.
          </p>
        </div>
        <div>
          <h5>Как связать всё в один ответ</h5>
          <ul>
            <li>
              Функция высшего порядка — это функция, которая принимает или
              возвращает другую функцию, например `map`, `filter`, или своя
              `repeat(callback)`.
            </li>
            <li>
              Чистая функция — всегда даёт один и тот же результат при
              одинаковых аргументах и не имеет побочных эффектов, то есть не
              меняет ничего вне себя.
            </li>
            <li>
              Побочный эффект — это любое изменение внешнего состояния:
              изменение глобальной переменной, изменение DOM, лог в консоль,
              запрос к серверу и т.д.
            </li>
            <li>
              Колбэк — функция, которую передают в другую функцию как аргумент,
              чтобы вызвать позже, например в `setTimeout` или `array.map`.
            </li>
            <li>
              Замыкание — это функция, которая запоминает переменные из внешней
              области видимости и может использовать их после завершения внешней
              функции; пример — `makeCounter` с внутренней функцией, которая
              увеличивает `count`.
            </li>
          </ul>
        </div>
      </div>

      <div>
        <h3>Способы создания объектов.</h3>
        <div>
          <h4>Литерал объекта</h4>
          <p>
            Определение: самый простой и популярный способ создания объекта —
            через фигурные скобки с парами «ключ: значение».
          </p>
          <p>
            const user = { <br />
            name: "Костя", <br />
            age: 20 <br />
            }; <br />
            <br />
            const empty = {};
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              Это основной способ создания обычных объектов в современном JS.
            </li>
            <li>Удобен для конфигов, данных, простых сущностей.</li>
          </ul>
        </div>
        <div>
          <h4>Конструктор `Object` и `new Object()`</h4>
          <p>
            Определение: создание объекта через встроенный конструктор `Object`.
            Сейчас используется редко, больше для теории.
          </p>
          <p>
            const user = new Object(); <br />
            user.name = "Костя"; <br />
            user.age = 20; <br />
            <br />

            или: <br />
            <br />

            const user = new Object({ name: "Костя", age: 20 });
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>Работает, но проще и короче `{}`.</li>
            <li>На экзамене достаточно упомянуть как один из способов.</li>
          </ul>
        </div>
        <div>
          <h4>Функция‑конструктор + `new`</h4>
          <p>
            Определение: функция, которая используется как «шаблон» для создания
            однотипных объектов. Вызывается с `new`.
          </p>
          <p>
            function User(name, age) { <br />
            this.name = name; <br />
            this.age = age; <br />
            } <br />
            <br />

            const user1 = new User("Костя", 20); <br />
            const user2 = new User("Аня", 25);
          </p>
          <p>Что важно сказать:</p>
          <ul>
            <li>Имя конструктора обычно с заглавной буквы.</li>
            <li>
              `new User(...)` создаёт новый объект, привязывает `this` и
              возвращает его.
            </li>
            <li>
              Раньше это был основной способ «классовоподобных» объектов до
              появления `class`.
            </li>
          </ul>
        </div>
        <div>
          <h4>`class` (синтаксический сахар над прототипами)</h4>
          <p>
            Определение: ES6‑синтаксис для описания «класса» — более привычный
            для тех, кто из C#/Java. Внутри всё равно используется прототипное
            наследование.
          </p>
          <p>
            class User { <br />
            constructor(name, age) { <br />
            this.name = name; <br />
            this.age = age; <br />
            } <br />
            <br />

            sayHi() { <br />
            console.log(`Привет, я ${this.name}`); <br />
            } <br />
            } <br />
            <br />

            const user1 = new User("Костя", 20); <br />
            user1.sayHi(); // Привет, я Костя
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              `class` — удобный синтаксис для работы с объектами и
              наследованием.
            </li>
            <li>
              Используется вместе с `new` так же, как функция‑конструктор.
            </li>
            <li>В современном коде предпочтительнее конструкторных функций.</li>
          </ul>
        </div>
        <div>
          <h4>Object.create(proto)</h4>
          <p>
            Определение: создаёт объект с указанным прототипом. Полезно, когда
            нужно явно задать прототип или создать объект без прототипа.
          </p>
          <p>
            const personProto = { <br />
            sayHi() { <br />
            console.log(`Привет, я ${this.name}`); <br />
            } <br />
            }; <br />
            <br />

            const user = Object.create(personProto); <br />
            user.name = "Костя"; <br />
            user.sayHi(); // Привет, я Костя
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              `Object.create(proto)` создаёт объект, у которого в качестве
              прототипа используется `proto`.
            </li>
            <li>
              Удобен для ручной работы с прототипами и «чистым» прототипным
              наследованием.
            </li>
          </ul>
        </div>
        <div>
          <h4>Кратко, как говорить на экзамене</h4>
          <ol>
            <li>
              литерал объекта `{}` — самый простой и часто используемый способ;
            </li>
            <li>
              через конструктор `Object` — `new Object()`, сейчас почти не
              используется;
            </li>
            <li>
              через функцию‑конструктор с `new`, например `function User(...) {
              this... }`, `new User(...)`;
            </li>
            <li>
              через класс `class User { constructor(){...} }`, который внутри
              всё равно работает через прототипы;
            </li>
            <li>
              с помощью `Object.create(proto)`, когда нужно явно задать прототип
              для нового объекта.
            </li>
          </ol>
        </div>
      </div>

      <div>
        <h3>Способы клонирования объектов.</h3>
        <div>
          <h4>Поверхностное копирование (shallow copy)</h4>
          <p>
            Копируются только верхнеуровневые свойства; вложенные объекты и
            массивы остаются теми же ссылками.
          </p>
          <ol>
            <li>
              <h5>Оператор распространения (spread ...)</h5>
              <p>
                const user = { name: "Костя", info: { age: 20 } }; <br />
                <br />

                const copy = { ...user }; // поверхностная копия <br />
                <br />

                copy.name = "Петя"; // не влияет на user.name <br />
                copy.info.age = 30; // изменит и user.info.age тоже! <br />
                Создаётся новый объект, но вложенные объекты/массивы общие.
                <br />
                <br />

                Самый популярный способ сделать «копию на один уровень».
              </p>
            </li>
            <li>
              <h5>Object.assign</h5>
              <p>
                const user = { name: "Костя", info: { age: 20 } }; <br />
                <br />

                const copy = Object.assign({}, user); // поверхностная копия
                <br />
                <br />

                copy.info.age = 30; // затронет и оригинал <br />
                Работает аналогично spread: копирует только верхний уровень.
                <br />
                <br />

                Разница: Object.assign может дописывать в существующий объект.
              </p>
            </li>
          </ol>
        </div>
        <div>
          <h4>Глубокое копирование (deep copy)</h4>
          <p>
            Глубокая копия — когда всё дерево объекта копируется, и вложенные
            объекты/массивы не делят ссылки с оригиналом.
          </p>
          <ol>
            <li>
              <h5>structuredClone (современный стандарт)</h5>
              <p>
                const original = { <br />
                x: 1, <br />
                nested: { y: 2 }, <br />
                arr: [1, 2, 3] <br />
                }; <br />
                <br />

                const clone = structuredClone(original); <br />
                <br />

                clone.nested.y = 999; <br />
                clone.arr[0] = 100; <br />
                <br />

                console.log(original.nested.y); // 2 — оригинал не изменился
                <br />
              </p>
              <ul>
                <li>
                  Делает глубокую копию, поддерживает сложные типы: объекты,
                  массивы, Map, Set, Date и т.д.
                </li>
                <li>
                  Сейчас это рекомендуемый способ для deep copy в современных
                  браузерах и Node.
                </li>
              </ul>
            </li>
            <li>
              <h5>
                JSON.parse(JSON.stringify(obj)) (старый, но популярный хак)
              </h5>
              <p>
                const original = { x: 1, nested: { y: 2 } }; <br />
                <br />

                const clone = JSON.parse(JSON.stringify(original)); <br />
                <br />

                clone.nested.y = 999; <br />
                console.log(original.nested.y); // 2
              </p>
              <p>Минусы:</p>
              <ul>
                <li>
                  Теряются функции, undefined, Symbol, Date превращается в
                  строку.
                </li>
                <li>Не работает с циклическими ссылками.</li>
              </ul>
            </li>
            <p>
              Используется как простой deep copy для «чистых» данных (без
              функций и специальных типов).
            </p>
          </ol>
        </div>
        <div>
          <h4>Краткий ответ:</h4>
          <ul>
            <li>
              Есть поверхностное копирование (копируются только верхнеуровневые
              свойства, вложенные объекты остаются по ссылке) и глубокое
              копирование (полностью независимая копия структуры).
            </li>
            <li>
              Для поверхностного копирования объектов используют:

              <ul>
                <li>оператор spread: const copy = { ...obj };</li>
                <li>Object.assign({}, obj).</li>
              </ul>
            </li>
            <li>
              Для глубокого копирования:

              <ul>
                <li>
                  современный стандарт — structuredClone(obj), который делает
                  полноценную глубокую копию и работает с многими типами;
                </li>
                <li>
                  более старый подход — JSON.parse(JSON.stringify(obj)), но он
                  теряет функции и спецтипы.
                </li>
              </ul>
            </li>
          </ul>
        </div>
        ​
      </div>

      <div>
        <h3>
          Что такое this. Правила определения this. Рассказать про bind, call,
          apply.
        </h3>
        <div>
          <h4>this</h4>
          <p>
            this — это ссылка на контекст выполнения функции, то есть на тот
            объект, «от имени которого» функция вызвана.
          </p>
          <p>
            Примеры: <br />
            <br />

            const user = { <br />
            name: "Костя", <br />
            sayHi() { <br />
            console.log(this.name); <br />
            } <br />
            }; <br />
            <br />

            user.sayHi(); // this === user, выведет "Костя"
          </p>
          <ul>
            <li>В методах объекта this обычно указывает на сам объект.</li>
          </ul>
        </div>
        <div>
          <h4>Основные правила определения this</h4>
          <ol>
            <li>
              <h5>Глобальный контекст</h5>
              <p>
                В браузере снаружи функций: <br />
                <br />

                console.log(this === window); // true в браузере <br />
                Здесь this — глобальный объект (window / globalThis).
              </p>
            </li>
            <li>
              <h5>Обычный вызов функции</h5>
              <p>
                function show() { <br />
                console.log(this); <br />
                } <br />
                show();
              </p>
              <ul>
                <li>
                  В нестрогом режиме this внутри такой функции будет глобальным
                  объектом (window).
                </li>
                <li>В строгом режиме ('use strict') this будет undefined.</li>
              </ul>
            </li>
            <li>
              <h5>Вызов как метод объекта</h5>
              <p>
                const user = { <br />
                name: "Костя", <br />
                sayHi() { <br />
                console.log(this.name); <br />
                } <br />
                }; <br />
                <br />

                user.sayHi(); // this === user
              </p>
              <p>this указывает на объект перед точкой — user.</p>
            </li>
            <li>
              <h5>Конструктор с new</h5>
              <p>
                function User(name) { <br />
                this.name = name; <br />
                } <br />
                <br />

                const u = new User("Костя");
              </p>
              <p></p>
            </li>
            <p>При вызове с new:</p>
            <ul>
              <li>создаётся новый объект;</li>
              <li>this внутри конструктора указывает на этот новый объект;</li>
              <li>если явно не вернуть другой объект, возвращается this.</li>
            </ul>
            <li>
              <h5>Явное связывание: call / apply / bind</h5>
              <p>
                this можно принудительно задать с помощью call, apply, bind
                (ниже).
              </p>
            </li>
            <li>
              <h5>Стрелочные функции</h5>
              <p>
                Стрелочные функции не имеют своего this. <br /><br />

                const obj = { <br />
                name: "Костя", <br />
                sayHi: () => { <br />
                console.log(this.name); <br />
                } <br />
                }; <br />
                <br />

                obj.sayHi(); // this здесь НЕ obj, а внешнее окружение
              </p>
              <p>
                this внутри стрелочной берётся из внешней области (лексически),
                поэтому стрелки не подходят как методы, если нужен this к
                объекту.
              </p>
            </li>
          </ol>
        </div>
        ​
        <div>
          <h4>call, apply, bind</h4>
          <p>Все три метода нужны, чтобы задать this для функции.</p>
          <p>Возьмём базовую функцию:</p>
          <p>
            function greet(greeting, punctuation) { <br />
            console.log(greeting + ", " + this.name + punctuation); <br />
            } <br />
            <br />

            const user = { name: "Костя" };
          </p>
          <div>
            <h4>call</h4>
            <p>
              Вызывает функцию сразу, задавая this и передавая аргументы по
              одному. <br />
              <br />

              greet.call(user, "Привет", "!"); <br />
              // this === user → "Привет, Костя!" <br />
              Сигнатура: func.call(thisArg, arg1, arg2, ...).
            </p>
          </div>
          <div>
            <h4>apply</h4>
            <p>
              Тоже вызывает функцию сразу, но аргументы принимает массивом.
              <br />
              <br />

              greet.apply(user, ["Здравствуйте", "!!!"]); <br />
              // this === user → "Здравствуйте, Костя!!!"
            </p>
            <ul>
              <li>Сигнатура: func.apply(thisArg, [arg1, arg2, ...]).</li>
              <li>Удобно, когда аргументы уже лежат в массиве.</li>
            </ul>
          </div>
          <div>
            <h4>bind</h4>
            <p>
              Не вызывает функцию сразу, а возвращает новую функцию с жёстко
              привязанным this и (опционально) частично подставленными
              аргументами. <br />
              <br />

              const greetKostya = greet.bind(user, "Привет"); <br />
              <br />

              greetKostya("!"); // "Привет, Костя!" <br />
              greetKostya("!!!"); // "Привет, Костя!!!" <br />
            </p>
            <ul>
              <li>Сигнатура: func.bind(thisArg, arg1, arg2, ...).</li>
              <li>Возвращает новую функцию, которую можно вызывать позже.</li>
            </ul>
            <p>
              Типичный пример с потерей this: <br />
              <br />

              const user = { <br />
              name: "Костя", <br />
              sayHi() { <br />
              console.log(this.name); <br />
              } <br />
              }; <br />
              <br />

              const hi = user.sayHi; <br />
              hi(); // this потерян, в строгом режиме undefined <br />
              <br />

              const hiBound = user.sayHi.bind(user); <br />
              hiBound(); // "Костя"
            </p>
          </div>
        </div>
        <div>
          <h4>Кратко</h4>
          <ul>
            <li>
              this — это контекст выполнения функции, объект, от имени которого
              она вызвана. В методах объекта this ссылается на этот объект, при
              new — на создаваемый объект, в глобальной функции — на глобальный
              объект или undefined в strict.
            </li>
            <li>
              В стрелочных функциях нет своего this, он берётся из внешней
              области.
            </li>
            <li>
              call и apply вызывают функцию сразу с указанным this; разница —
              call принимает аргументы по одному, apply — массивом.
            </li>
            <li>
              bind не вызывает функцию, а возвращает новую функцию с привязанным
              this и, при желании, частью аргументов.
            </li>
          </ul>
        </div>
      </div>
      <div>
        <h3>
          Что такое DOM? DOM-коллекции. Навигация и поиск. Что такое BOM.
          Location, Cookie, Web Storage.
        </h3>
        <div>
          <h4>DOM</h4>
          <p>
            DOM (Document Object Model) — это объектное представление
            HTML-документа в виде дерева узлов, к которому JS получает доступ,
            чтобы читать и менять структуру, содержимое и стили страницы.
          </p>
          <ul>
            <li>
              Каждый тег становится узлом (node) и элементом (element) в дереве.
            </li>
            <li>
              Через DOM можно создавать, удалять, перемещать элементы, менять
              текст, атрибуты и вешать обработчики событий.
            </li>
          </ul>
        </div>
        <div>
          <h4>DOM-коллекции, навигация и поиск</h4>
          <p>
            Поиск элементов <br />
            Основные методы:
          </p>
          <ul>
            <li>document.getElementById(id) – один элемент по id.</li>
            <li>
              document.getElementsByClassName(class) – HTMLCollection элементов
              по классу.
            </li>
            <li>
              document.getElementsByTagName(tag) – HTMLCollection по тегу.
            </li>
            <li>
              document.querySelector(selector) – первый элемент по
              CSS‑селектору.
            </li>
            <li>
              document.querySelectorAll(selector) – NodeList всех подходящих
              элементов.
            </li>
          </ul>
        </div>
        <div>
          <h4>DOM-коллекции</h4>
          <ul>
            <li>
              HTMLCollection – «живое» (live) коллекция: меняется при изменении
              DOM, возвращается getElementsByClassName, getElementsByTagName.
            </li>
            <li>
              NodeList – «неживое» (statическое) чаще всего; возвращается
              querySelectorAll. Можно перебирать через for...of, forEach.
            </li>
          </ul>
          <p>Они похожи на массив, но это не полноценный Array.</p>
          <div>
            <h5>Навигация по DOM-дереву</h5>
            <p>Основные свойства навигации:</p>
            <ul>
              <li>Родитель: node.parentNode, node.parentElement.</li>
              <li>
                Дети: node.childNodes (все узлы), node.children (только
                элементы), node.firstChild, node.firstElementChild,
                node.lastElementChild.
              </li>
              <li>
                Соседи: node.previousElementSibling, node.nextElementSibling.
              </li>
            </ul>
            <p>Через эти ссылки можно ходить по дереву от любого узла.</p>
          </div>
        </div>
        <div>
          <h4>BOM</h4>
          <p>
            BOM (Browser Object Model) — это объектная модель браузера, набор
            объектов вокруг window, которые описывают сам браузер и вкладку, а
            не сам документ.
          </p>
          <ul>
            <li>
              Главный объект — window: в нём лежат document, location,
              navigator, history, localStorage, sessionStorage и т.д.
            </li>
            <li>
              DOM — это window.document, BOM — всё остальное, связанное с
              окном/вкладкой (адрес, история, размер окна, навигатор, хранение
              данных).
            </li>
          </ul>
        </div>
        <div>
          <h4>Location</h4>
          <p>
            location — объект, который описывает адрес текущей страницы (URL) и
            позволяет его менять/перезагружать.
          </p>
          <p>Основные свойства/методы:</p>
          <ul>
            <li>
              location.href – полный URL; можно читать и изменять
              (перенаправление).
            </li>
            <li>
              location.protocol, hostname, pathname, search, hash – части URL.
            </li>
            <li>location.reload() – перезагрузить страницу.</li>
          </ul>
        </div>
        <div>
          <h4>Cookie</h4>
          <p>
            Cookies — маленькие текстовые данные (пары ключ‑значение), которые
            браузер хранит обычно пер‑сайт и автоматически отправляет на сервер
            с HTTP‑запросами.
          </p>
          <ul>
            <li>
              В JS доступ через document.cookie (строка; установка через
              присваивание).
            </li>
            <li>
              Обычно используются для сессий, авторизации, настроек
              пользователя.
            </li>
            <li>
              Имеют ограничения по размеру и количеству, сроки жизни и флаги
              (expires, path, secure, httpOnly и т.д. — для понимания достаточно
              упомянуть, что есть срок жизни и настройки безопасности).
            </li>
          </ul>
        </div>
        <div>
          <h4>Web Storage: localStorage и sessionStorage</h4>
          <p>
            Web Storage — современный API для хранения данных в браузере в виде
            пары ключ → строка.
          </p>
          <p>localStorage</p>
          <ul>
            <li>
              Данные переживают закрытие вкладки и браузера, пока явно не
              очищены.
            </li>
            <li>
              Объём хранения больше, чем у cookies, и данные не отправляются на
              сервер каждые запросом.
            </li>
          </ul>
          <p>Основные методы:</p>
          <p class="code--block" data-lang="JS">
            localStorage.setItem("key", "value"); localStorage.getItem("key");
            // вернёт строку или null localStorage.removeItem("key");
            localStorage.clear(); localStorage.length; // количество записей
          </p>
        </div>
        <div>
          <h4>sessionStorage</h4>
          <ul>
            <li>
              Работает так же, как localStorage, но данные живут только в рамках
              одной вкладки/сессии.
            </li>
            <li>При закрытии вкладки/session — всё очищается.</li>
          </ul>
          <p>
            Использование аналогично:
            sessionStorage.setItem/getItem/removeItem/clear.
          </p>
        </div>
        <div>
          <h4>Кратко</h4>
          <ul>
            <li>
              DOM — это объектная модель документа, дерево узлов, через которое
              JS управляет HTML‑страницей: ищет элементы (getElementById,
              querySelector), ходит по дереву (parentNode, children) и работает
              с DOM‑коллекциями (HTMLCollection, NodeList).
            </li>
            <li>
              BOM — это объектная модель браузера: объект window и связанные с
              ним объекты вроде location, history, navigator, localStorage.
            </li>
            <li>
              location описывает текущий URL и позволяет управлять переходами и
              перезагрузкой.
            </li>
            <li>
              document.cookie — старый механизм хранения маленьких данных,
              которые также отправляются на сервер.
            </li>
            <li>
              Web Storage (localStorage, sessionStorage) — современный способ
              хранить ключ‑значение в браузере: localStorage — постоянно,
              sessionStorage — до закрытия вкладки.
            </li>
          </ul>
        </div>
      </div>

      <div>
        <h3>
          События - всплытие и погружение. Как к элементу прикрепить обработчик
          события click. Что такое event.target и event.currentTarget, отличия.
          Делегирование событий.
        </h3>
        <div>
          <h4>Всплытие и погружение</h4>
          <p>
            Событие в DOM проходит две основные фазы: погружение (capturing) и
            всплытие (bubbling). <br />
            <br />
            Представь структуру:
          </p>
          <p class="code--block" data-lang="HTML">
            &lt;div id=&quot;outer&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button
            id=&quot;inner&quot;&gt;Кликни&lt;/button&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
          </p>
          <p>Когда пользователь кликает по #inner:</p>
          <ol>
            <li>
              Погружение (capturing): событие идёт сверху вниз: document → html
              → body → outer → inner.
            </li>
            <li>Цель (target): событие достигает сам элемент inner.</li>
            <li>
              Всплытие (bubbling): поднимается снизу вверх: inner → outer → body
              → html → document.
            </li>
          </ol>
          <p>
            По умолчанию обработчики в addEventListener работают на фазе
            всплытия.
          </p>
        </div>
        <div>
          <h4>Как повесить обработчик click</h4>
          <p>Современный способ — addEventListener:</p>
          <p class="code--block" data-lang="JS">
            const button = document.getElementById("myBtn"); <br />
            <br />

            button.addEventListener("click", (event) => { <br />
            console.log("Клик по кнопке"); <br />
            });
          </p>
          <p>Синтаксис:</p>
          <p class="code--block" data-lang="JS">
            element.addEventListener(type, listener, useCapture);
          </p>
          <ul>
            <li>type — строка события: "click", "input", "submit" и т.д.</li>
            <li>listener — функция‑обработчик, обычно (event) => { ... }.</li>
            <li>
              useCapture (опционально) — false по умолчанию (всплытие), true —
              обработчик срабатывает на фазе погружения.
            </li>
          </ul>
          <p>Пример с погружением:</p>
          <p class="code--block" data-lang="JS">
            outer.addEventListener("click", handler, true); // capture <br />
            inner.addEventListener("click", handler, false); // bubble
          </p>
        </div>
        <div>
          <h4>event.target и event.currentTarget</h4>
          <p>Оба свойства есть у объекта события event.</p>
          <h5>event.target</h5>
          <p>
            event.target — конкретный элемент, на котором произошло событие (где
            пользователь кликнул).
          </p>
          <p class="code--block" data-lang="JS">
            document.addEventListener("click", (event) => { <br />
            console.log("target:", event.target); <br />
            });
          </p>
          <p>Если клик по button, event.target будет button.</p>
          <h5>event.currentTarget</h5>
          <p>
            event.currentTarget — элемент, на котором сейчас выполняется
            обработчик, т.е. куда повесили addEventListener.
          </p>
          <p class="code--block" data-lang="JS">
            const div = document.getElementById("container"); <br />
            <br />

            div.addEventListener("click", (event) => { <br />
            console.log("currentTarget:", event.currentTarget); // всегда div
            <br />
            console.log("target:", event.target); // конкретный вложенный
            элемент <br />
            });
          </p>
          <div>
            <h5>Разница:</h5>
            <ul>
              <li>target — «где реально кликнули».</li>
              <li>
                currentTarget — «на каком элементе сейчас выполняется этот
                обработчик».
              </li>
            </ul>
            <h5>При клике по вложенному элементу внутри контейнера:</h5>
            <ul>
              <li>event.target → этот вложенный элемент;</li>
              <li>
                event.currentTarget → контейнер, если обработчик висит на
                контейнере.
              </li>
            </ul>
          </div>
        </div>
        <div>
          <h4>Делегирование событий</h4>
          <p>
            Идея делегирования: вместо того чтобы вешать обработчик на каждый
            элемент отдельно, мы вешаем один обработчик на общего родителя и в
            нём смотрим, по какому именно ребёнку кликнули, используя
            event.target.
          </p>
          <p>Пример: есть список, и нам нужно реагировать на клики по li:</p>
          <p class="code--block" data-lang="HTML">
            &lt;ul id=&quot;list&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li
            data-id=&quot;1&quot;&gt;Элемент 1&lt;/li&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li
            data-id=&quot;2&quot;&gt;Элемент 2&lt;/li&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li
            data-id=&quot;3&quot;&gt;Элемент 3&lt;/li&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;
          </p>
          <p class="code--block" data-lang="JS">
            const list = document.getElementById("list"); <br />
            <br />

            list.addEventListener("click", (event) => { <br />
            const item = event.target.closest("li"); // ищем ближайший li <br />
            if (!item || !list.contains(item)) return; <br />
            <br />

            const id = item.dataset.id; <br />
            console.log("Клик по элементу с id =", id); <br />
            });
          </p>
          <p>Что тут важно:</p>
          <ul>
            <li>
              Обработчик висит только на ul, но ловит клики по любому li внутри
              — это и есть делегирование.
            </li>
            <li>event.target — элемент, по которому конкретно кликнули.</li>
            <li>
              Используем closest("li"), чтобы подняться до нужного предка.
            </li>
          </ul>
          <p>Плюсы делегирования:</p>
          <ul>
            <li>Меньше обработчиков → лучше производительность.</li>
            <li>
              Работает даже для динамически добавленных элементов, потому что
              событие всплывает до родителя.
            </li>
          </ul>
        </div>
        <div>
          <h4>Кратко</h4>
          <ul>
            <li>
              В браузере события проходят фазы: погружение сверху вниз и
              всплытие снизу вверх. По умолчанию addEventListener срабатывает на
              фазе всплытия, но можно включить погружение третьим параметром
              true.
            </li>
            <li>
              Обработчик click обычно вешают так:
              element.addEventListener("click", handler).
            </li>
            <li>
              event.target — элемент, где событие произошло, event.currentTarget
              — элемент, на котором висит обработчик. При делегировании вешаем
              обработчик на родителя, используем event.target, чтобы понять, по
              какому дочернему элементу кликнули.
            </li>
            <li>
              Делегирование событий — это приём, когда один обработчик на
              родителе обрабатывает события всех дочерних элементов за счёт
              всплытия, что оптимизирует код и упрощает работу с динамическим
              DOM.
            </li>
          </ul>
        </div>
      </div>

      <div>
        <h3>Что такое event loop? Макро и микро таски.</h3>
        <div>
          <h4>Что такое event loop</h4>
          <p>JavaScript однопоточен: в один момент времени выполняется только один фрагмент кода, а асинхронность реализуется через очереди задач и event loop.</p>
          <p>Event loop — это механизм, который:</p>
          <ol>
            <li>Выполняет весь синхронный код (то, что попало в call stack).</li>
            <li>Когда стек пуст, берёт задачи из очередей (микро‑ и макротаски) и выполняет их по определённым правилам.</li>
          </ol>
          <p>По сути, это цикл: «выполнил стек → обработал микротаски → взял следующую макротаску → снова обработал микротаски и т.д.».</p>
        </div>
        <div>
          <h4>Макротаски (macrotasks)</h4>
          <p>Макротаски (task queue) — это крупные асинхронные задачи, которые попадают в очередь «обычных» задач.</p>
          <p>Примеры макротасок:</p>
          <ul>
            <li>setTimeout, setInterval</li>
            <li>события DOM (click, load и т.п.)</li>
            <li>сетевые колбэки (XHR, fetch, I/O)</li>
          </ul>
          <p>Работа цикла:</p>
          <ol>
            <li>Выполняется весь синхронный код.</li>
            <li>Потом берётся одна макротаска из очереди и выполняется.</li>
            <li>После этого снова дают шанс микротаскам, и только потом переходят к следующей макротаске.</li>
          </ol>
        </div>
        <div>
          <h4>Микротаски (microtasks)</h4>
          <p>Микротаски — задачи более высокого приоритета, которые выполняются до перехода к следующей макротаске.</p>
          <p>Примеры микротасок:</p>
          <ul>
            <li>обработчики Promise.then, catch, finally</li>
            <li>queueMicrotask(...)</li>
            <li>(в браузере также mutation observer и др.)</li>
          </ul>
          <p>Правило: после выполнения синхронного кода и каждой макротаски движок полностью вычищает очередь микротасок, прежде чем брать следующую макротаску.</p>
        </div>

        <div>
          <h4>Почему Promise выполняется раньше setTimeout 0</h4>
          <p>Классический пример:</p>
          <p class="code--block" data-lang="JS">
            console.log("start"); <br> <br>

            setTimeout(() => { <br>
              console.log("timeout"); <br>
            }, 0); <br> <br>

            Promise.resolve().then(() => { <br>
              console.log("promise"); <br>
            }); <br> <br>

            console.log("end");
          </p>
          <p>Порядок вывода:</p>
          <ol>
            <li>start</li>
            <li>end</li>
            <li>promise</li>
            <li>timeout</li>
          </ol>
          <p>Объяснение:</p>
          <ol>
            <li>start и end — синхронный код, выполняется сразу.</li>
            <li>setTimeout(..., 0) → колбэк в очередь макротасок.</li>
            <li>Promise.resolve().then(...) → колбэк в очередь микротасок.</li>
            <li>После синхронного кода event loop сначала выполняет все микротаски → promise.</li>
            <li>Потом берёт первую макротаску → timeout.</li>
          </ol>
        </div>
        <div>
          <h4>Краткая формулировка для ответа</h4>
          <ul>
            <li>Event loop — это механизм в JS, который управляет выполнением кода: он берёт синхронный код, затем асинхронные задачи из очередей, чтобы однопоточный JS мог работать с асинхронностью.</li>
            <li>Есть две важные очереди: макротаски и микротаски. Макротаски — это setTimeout, события DOM и другие крупные задачи; микротаски — в основном обработчики промисов и queueMicrotask.</li>
            <li>После выполнения синхронного кода и каждой макротаски движок сначала полностью вычищает очередь микротасок, и только потом берёт следующую макротаску. Поэтому Promise.then выполняется раньше setTimeout(..., 0).</li>
          </ul>
        </div>
      </div>
    </section>

    <section>
      <h3>Вопросы по VUE</h3>
      <ol>
        <li>
          Чем отличается computed от обычной функции? Когда и зачем использовать
          watch, если есть computed? Что такое ref и reactive.
        </li>
        <li>
          Что делает директива v-model и как она работает? Как v-model работает
          на кастомных компонентах. Как передать данные от родительского
          компонента к дочернему и обратно?
        </li>
        <li>
          Что такое props drilling и почему он считается архитектурной
          проблемой? Какими способами можно решить эту проблему.
        </li>
        <li>
          Чем принципиально отличается механизм provide / inject от
          использования глобального состояния через Pinia?
        </li>
        <li>
          В чём принципиальная разница между состоянием приложения (App State -
          Pinia) и кэшем данных (Cache - TanStack Query)?
        </li>
        <li>Какие основные хуки жизненного цикла существуют в Vue?</li>
        <li>
          Что понимается под контролируемыми и неконтролируемыми компонентами?
          Объяснить разницу между умными и глупыми компонентами.
        </li>
        <li>
          Почему не рекомендуется использовать объект в качестве key в v-for?
        </li>
        <li>
          Как Vue отслеживает зависимости и определяет, какие компоненты
          необходимо обновить при изменении данных? (объяснить роль Proxy,
          описать механизм effect, раскрыть принципы track и trigger)
        </li>
        <li>
          Почему после изменения реактивных данных во Vue нельзя сразу работать
          с обновлённым DOM, и как nextTick() решает эту проблему?
        </li>
        <li>
          Сравните подход Virtual DOM и No Virtual DOM. Какую проблему
          изначально решал Virtual DOM. Почему отказываются от Virtual DOM
        </li>
        <li>Что такое slots и какие типы slots существуют?</li>
        <li>Что такое SSG, SSR, CSR? Что такое гидрация?</li>
      </ol>
    </section>

    <section>
      <h3>ПРАКТИКА</h3>
      <p>
        практический пример vue js: import { ref } from 'vue' <br />
        const count = ref(0) <br />
        function increment() { <br />
        count++ <br />
        } <br />

        Почему этот код не работает и как его исправить? <br />

        Практика будет в таком же духе. Поэтому потренируйтесь с llm на базовых
        примерах. <br />

        практический пример БЭМ: <br />

        Описать по БЭМ. Примеры на практике могут быть сложнее, включая CSS и
        внешнюю геометрию. <br />

        &lt;article&gt;<br />
        &lt;h3&gt;Заголовок поста&lt;/h3&gt;<br />
        &lt;p&gt;Текст краткого содержания поста. Здесь может быть несколько
        предложений, описывающих основную тему...&lt;/p&gt;<br />
        &lt;/article&gt;
      </p>
    </section>

    <section>
      <p class="red--text">И Вопросы со среза от Юли не забудь</p>
    </section>

    <section>
      <script src="main.js"></script>
      <script src="learning.js"></script>
    </section>
  </body>
</html>
