<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Костин Сайт-шпора</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <h1>Правила экзамена</h1>
    </header>

    <section>
      <p id="testLearningJS">Начало</p>
      <button id="changeTest">Поменяем текст на "изменено"</button>
      <button id="btnTest">Кликни</button>

      <input id="input" type="text" />
      <p id="output"></p>

      <div id="box">Box</div>

      <input id="task" type="text" />
      <button id="btnAdd">Добавить</button>
      <ul id="list"></ul>
    </section>

    <section>
      <p>Оценка 5 (автомат):</p>
      <ul>
        <li>сдан контрольный срез;</li>
        <li>проект сдан в установленный срок;</li>
        <li>выполнены все задания по Vue.js.</li>
      </ul>

      <p>Оценка 4 (автомат):</p>

      <ul>
        <li>сдан контрольный срез;</li>
        <li>проект сдан (срок сдачи не учитывается);</li>
        <li>выполнены все или не менее 5 из 6 заданий по Vue.js.</li>
      </ul>

      <p>Оценка 3 (автомат):</p>
      <ul>
        <li>сдан контрольный срез;</li>
        <li>выполнена часть заданий по Vue.js.</li>
      </ul>

      <p>
        Тут список, студентов, который сдали срез и которые сдали проект (в срок
        и без учета срока) https://e.sfu-kras.ru/mod/assign/view.php?id=1935273
        <br />
        <br />
        Если идете на экзамен, формат экзамена зависит от ранее выполненных
        работ: <br />
        Контрольный срез не сдан - на экзамене добавляются дополнительные
        теоретические вопросы по HTML и CSS. <br />
        Проект не сдан - на экзамене предусмотрено практическое задание по
        методологии БЭМ. <br />
        Большинство заданий по Vue.js не выполнено - на экзамене предусмотрено
        практическое задание по Vue.js.
      </p>
    </section>

    <section class="section html-css">
      <h2>Вопросы по HTML и CSS</h2>
      <div>
        <div>
          <div class="exam--card">
            <h4>
              1. Что такое doctype? Рассказать про head, meta, title, body.
            </h4>
            <h5>Doctype</h5>
            <p>
              это инструкция в начале HTML-документа, которая указывает браузеру
              версию HTML и активирует стандартный режим рендеринга.
            </p>
            <h5>Head</h5>
            <p>
              Элемент содержит метаданные страницы, невидимые пользователю. Он
              включает информацию о кодировке, стилях, скриптах и других
              ресурсах. Размещается сразу после doctype и перед body.
            </p>
            <h5>Meta</h5>
            <p>
              Теги meta внутри head передают метаданные: например,
              charset="UTF-8" для кодировки, viewport для мобильной адаптации
              или description для поисковиков. Они не отображаются на странице,
              но влияют на SEO и поведение браузера.
            </p>
            <h5>Title</h5>
            <p>
              Задаёт заголовок страницы, видимый во вкладке браузера и поисковой
              выдаче.
            </p>
            <h5>Body</h5>
            <p>
              Элемент body содержит весь видимый контент: текст, изображения,
              формы и другие элементы.
            </p>
          </div>

          <div class="exam--card">
            <h4>
              2. Для чего нужны атрибуты name и value в элементах формы (в
              input, select и т.д).
            </h4>
            <p>
              Формы в HTML — это блоки для сбора данных от пользователя (логин,
              пароль, выбор опций), которые отправляются на сервер для
              обработки. Элемент form оборачивает все поля, а атрибуты name и
              value определяют, как данные передаются: name — ключ (имя поля),
              value — значение.
            </p>
          </div>

          <div class="exam--card">
            <h4>
              3. Что такое HTML-формы? Опишите основные элементы формы (form,
              label, fieldset, legend) и их роль. Как работает отправка формы
              (method: GET/POST, action). Как сделать так, чтоб можно было
              отправлять файлы на сервер.
            </h4>
            <div class="subtopic">
              <p>
                HTML‑форма — это контейнер, который собирает значения полей
                (input, select и т.д.) и отправляет их на сервер по
                HTTP‑запросу.
              </p>
              <p>
                form — блок, внутри которого находятся элементы формы. action и
                method - его обязательные атрибуты. <br />
                action — URL обработчика на сервере(Скрипта) (куда пойдёт
                запрос).
                <br />
                method — HTTP‑метод отправки: GET или POST. Пример: <br />
                &lt;form action="/submit" method="post"&gt; <br />
                ... <br />
                &lt;/form &gt;
              </p>
            </div>
            <div class="subtopic">
              <h5>Элементы формы</h5>
              <p>
                &lt;label&gt; — подпись для поля ввода. Кликаешь по надписи —
                фокус попадает в соответствующий input, плюс это критично для
                пользователей с особенностями восприятия. Без связки for и id
                скриптридеры не смогут с ними работать. Связь делается через for
                и id: <br />

                fieldset — логическая группа полей внутри формы. <br />
                Используется, когда много связанных полей (например, «Личные
                данные», «Адрес»). <br />

                legend — заголовок группы полей; должен быть первым ребёнком
                внутри fieldset. <br />
              </p>

              <p>
                &lt;fieldset&gt;<br />
                    &lt;legend&gt;Выбор по радио&lt;/legend&gt;<br />
                    &lt;label for=&quot;sex&quot;&gt;Выберите
                пол&lt;/label&gt;<br />
                    <br />
                    &lt;p&gt;<br />
                        &lt;label
                for=&quot;man&quot;&gt;Мужчина&lt;/label&gt;<br />
                        &lt;input type=&quot;radio&quot; id=&quot;man&quot;
                name=&quot;sexUser&quot; value=&quot;Мужчина&quot; /&gt;<br />
                    &lt;/p&gt;<br />
                    &lt;p&gt;<br />
                        &lt;label
                for=&quot;women&quot;&gt;Женщина&lt;/label&gt;<br />
                        &lt;input type=&quot;radio&quot; id=&quot;woman&quot;
                name=&quot;sexUser&quot; value=&quot;Женщина&quot; /&gt;<br />
                    &lt;/p&gt;<br />
                &lt;/fieldset&gt;
              </p>
            </div>

            <h5>Как работает отправка формы (GET / POST, action)</h5>
            <p>
              Когда нажимаешь &lt;button type="submit"&gt; или &lt;input
              type="submit"&gt;, браузер: ​ &lt;&gt; 1. Берёт все элементы с
              атрибутом name внутри form. <br />
              2. Собирает пары name=значение. <br />
              3. Посылает HTTP‑запрос на URL из action с методом из method.
              <br />
            </p>

            <h5>method="GET"</h5>
            <p>
              Данные кодируются в URL после ?: /submit?name=Alex&age=25.
              Используется для простых запросов (поиск, фильтрация). Плохо для
              паролей и больших данных.
            </p>

            <h5>method="POST"</h5>

            <p>
              Данные идут в теле HTTP‑запроса, URL остаётся чистым. Подходит для
              логина, регистрации, отправки больших форм. ​
            </p>

            <p>Пример:</p>

            <p>
              &lt;form action=&quot;/handle-form&quot;
              method=&quot;post&quot;&gt;<br />
                  &lt;label for=&quot;login&quot;&gt;Логин:&lt;/label&gt;<br />
                  &lt;input id=&quot;login&quot; name=&quot;login&quot;
              type=&quot;text&quot;&gt;<br />
                  <br />
                  &lt;label for=&quot;password&quot;&gt;Пароль:&lt;/label&gt;<br />
                  &lt;input id=&quot;password&quot; name=&quot;password&quot;
              type=&quot;password&quot;&gt;<br />
                  <br />
                  &lt;button type=&quot;submit&quot;&gt;Войти&lt;/button&gt;<br />
              &lt;/form&gt; На сервер прилетит что‑то вроде:
              login=...&password=.... <br />
              Вот в действии
            </p>

            <form action="/handle-form" method="post">
              <label for="login">Логин:</label>
              <input id="login" name="login" type="text" />

              <label for="password">Пароль:</label>
              <input id="password" name="password" type="password" />

              <button type="submit">Войти</button>
            </form>

            <h5>Как отправлять файлы на сервер</h5>
            <p>
              Чтобы форма умела отправлять файл, нужно одновременно выполнить
              три условия: <br />

              1. Внутри формы — поле для выбора файла. Прописать type="text"
              <br />
              2. Метод формы обязательно POST. Потому что обычный GET не умеет
              нормально передавать большие бинарные данные через URL, а POST с
              enctype="multipart/form-data" как раз и создан для отправки файлов
              в теле запроса.
              <br />
              3. Добавить атрибут enctype="multipart/form-data": <br />

              &lt;form action=&quot;/upload&quot; method=&quot;post&quot;
              enctype=&quot;multipart/form-data&quot;&gt;<br />
                  &lt;label for=&quot;avatar&quot;&gt;Загрузите
              аватар:&lt;/label&gt;<br />
                  &lt;input id=&quot;avatar&quot; name=&quot;avatar&quot;
              type=&quot;file&quot;&gt;<br />
                  <br />
                  &lt;button
              type=&quot;submit&quot;&gt;Отправить&lt;/button&gt;<br />
              &lt;/form&gt; <br />

              enctype="multipart/form-data" говорит браузеру отправлять данные
              «частями» (multipart), что позволяет прикреплять бинарные файлы, а
              не только обычный текст. <br />

              Без этого атрибута файл нормально на сервер не дойдёт.
            </p>
          </div>

          <section class="exam--card">
            <h4>
              4. Что такое семантическая верстка, зачем нужна. Рассказать про
              article, section, footer, header, aside, nav, figure. Зачем нужны
              ul и ol, что верстают используя ul и ol.
            </h4>
            <p>
              Семантика - смысловое разделение кода страницы на блоки, на основе
              смысла их содержимого. Идея в том, чтобы код был понятен не только
              человеку на глаз, но и браузеру (для продвижения в поиске),
              скринридеру, поисковику и другим программам.
            </p>
            <h4>Теги</h4>
            <p>
              header - верхняя часть страницы (шапка), секции, блок и т.д.
              (Несколько на странице) <br />
              footer - нижняя часть страницы (шапка), секции, блок и т.д.
              (Несколько на странице) <br />
              main - основная часть страницы (Один на страницу) <br />
              section - независимые функциональные блоки. (Обязателен заголовок)
              <br />
              article - самодостаточный блок какой-либо сущности. (Типа если
              можно вынести как блок рекламы - то это он) <br />
              aside - блок с доп./косвенным содержимым. Типа боковая (не всегда)
              колонка/фильтры и т.д. <br />
              nav - блок навигации. (несколько на страницу) <br />
              figure - обозначение картинки, диаграммы, кода, таблицы и т.д.
              <br />
            </p>
            <img src="images\semanticCode.jpg" alt="Семантика кода" />

            <p>
              ul Типа: <br />
              &lt;ul&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;/ul&gt; <br />
            </p>

            <ul>
              <li>Я элемент маркированного спика</li>
              <li>Я элемент маркированного спика</li>
              <li>Я элемент маркированного спика</li>
            </ul>

            <p>
              ol Типа: <br />
              &lt;ol&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;li&gt;Я элемент маркированного спика&lt;/li&gt; <br />
              &lt;/ol&gt; <br />
            </p>

            <ol>
              <li>Я элемент нумерованного спика</li>
              <li>Я элемент нумерованного спика</li>
              <li>Я элемент нумерованного спика</li>
            </ol>
          </section>

          <section class="exam--card">
            <h4>
              5. В контексте CSS. Что такое БЭМ, зачем нужен. Привести примеры.
              Что такое внешняя геометрия и почему БЕМ ее запрещает. Плюсы и
              минусы БЕМ.
            </h4>
            <p>
              БЭМ — компонентный подход к веб-разработке, в основе которого
              лежит принцип разделения интерфейса на независимые блоки.
              <br />
              <br />
              Он позволяет легко и быстро разрабатывать интерфейсы любой
              сложности и повторно использовать существующий код, избегая
              «Copy-Paste».
            </p>
            <h5>Блок</h5>
            <p>
              Функционально независимый компонент страницы, который может быть
              повторно использован. В HTML блоки представлены атрибутом class.
              <br />

              Название блока характеризует смысл («что это?» — «меню»: menu,
              «кнопка»: button), а не состояние («какой, как выглядит?» —
              «красный»: red, «большой»: big). <br />

              Пример <br />

              &lt;!-- Верно. Семантически осмысленный блок `error` --&gt;<br />
              &lt;div class=&quot;error&quot;&gt;&lt;/div&gt;<br />
              <br />
              &lt;!-- Неверно. Описывается внешний вид --&gt;<br />
              &lt;div class=&quot;red-text&quot;&gt;&lt;/div&gt; <br />
              <br />
              Блок не должен влиять на свое окружение, т. е. блоку не следует
              задавать внешнюю геометрию (в виде отступов, границ, влияющих на
              размеры) и позиционирование. <br />

              В CSS по БЭМ также не рекомендуется использовать селекторы по
              тегам или id. <br />

              Таким образом обеспечивается независимость, при которой возможно
              повторное использование или перенос блоков с места на место.
            </p>

            <h5>Элемент</h5>
            <p>
              Составная часть блока, которая не может использоваться в отрыве от
              него. <br />

              Название элемента характеризует смысл («что это?» — «пункт»: item,
              «текст»: text), а не состояние («какой, как выглядит?» —
              «красный»: red, «большой»: big). <br />

              Структура полного имени элемента соответствует схеме:
              имя-блока__имя-элемента. Имя элемента отделяется от имени блока
              двумя подчеркиваниями (__). <br />

              Пример <br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
                  &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;
            </p>

            <h5>Модификатор</h5>
            <p>
              Cущность, определяющая внешний вид, состояние или поведение блока
              либо элемента.
            </p>
            <p>
              &lt;!-- Блок `search-form` имеет булевый модификатор `focused`
              --&gt;<br />
              &lt;form class=&quot;search-form search-form_focused&quot;&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` имеет булевый модификатор `disabled`
              --&gt;<br />
                  &lt;button class=&quot;search-form__button
              search-form__button_disabled&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;
            </p>
            <h5>Вложенность</h5>
            <ul>
              <li>Элементы можно вкладывать друг в друга.</li>
              <li>Допустима любая вложенность элементов.</li>
              <li>
                Элемент — всегда часть блока, а не другого элемента. Это
                означает, что в названии элементов нельзя прописывать иерархию
                вида block__elem1__elem2.
              </li>
            </ul>
            <p>
              &lt;!-- Блок `header` --&gt;<br />
              &lt;header class=&quot;header&quot;&gt;<br />
                  &lt;!-- Вложенный блок `logo` --&gt;<br />
                  &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;<br />
                  <br />
                  &lt;!-- Вложенный блок `search-form` --&gt;<br />
                  &lt;form class=&quot;search-form&quot;&gt;&lt;/form&gt;<br />
              &lt;/header&gt;
            </p>

            <h5>Принадлежность</h5>
            <p>
              Элемент — всегда часть блока и не должен использоваться отдельно
              от него.
            </p>

            <p>
              &lt;!-- Верно. Элементы лежат внутри блока `search-form` --&gt;<br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
                  &lt;input class=&quot;search-form__input&quot;&gt;<br />
                  <br />
                  &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
                  &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/form&gt;<br />
              <br />
              &lt;!-- Неверно. Элементы лежат вне контекста блока `search-form`
              --&gt;<br />
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;form class=&quot;search-form&quot;&gt;<br />
              &lt;/form&gt;<br />
              <br />
              &lt;!-- Элемент `input` блока `search-form` --&gt;<br />
              &lt;input class=&quot;search-form__input&quot;&gt;<br />
              <br />
              &lt;!-- Элемент `button` блока `search-form` --&gt;<br />
              &lt;button
              class=&quot;search-form__button&quot;&gt;Найти&lt;/button&gt;
            </p>
            <h5>Необязательность</h5>
            <p>
              Элемент — необязательный компонент блока. Не у всех блоков должны
              быть элементы.
            </p>
            <p>
              &lt;!-- Блок `search-form` --&gt;<br />
              &lt;div class=&quot;search-form&quot;&gt;<br />
                  &lt;!-- Блок `input` --&gt;<br />
                  &lt;input class=&quot;input&quot;&gt;<br />
                  <br />
                  &lt;!-- Блок `button` --&gt;<br />
                  &lt;button class=&quot;button&quot;&gt;Найти&lt;/button&gt;<br />
              &lt;/div&gt;
            </p>

            <h5>Внешняя геометрия</h5>
            <p>
              Внешняя геометрия - это всё что влияет на то как расположен блок
              относительно своих соседей (margin, position, float и т.п.): его
              отступы наружу и позиционирование относительно окружения. <br />
              ​Внутренняя геометрия — это наоборот padding, размеры, границы, то
              есть «как устроен блок изнутри». <br />
              Она запрещена в БЭМ так как способна повлиять при
              переиспользовании блока в других местах.
            </p>

            <h5>Плюсы и минусы БЭМ</h5>
            <p>
              Плюсы БЭМ — предсказуемая структура, независимые блоки, меньше
              конфликтов CSS, проще поддерживать и работать в команде. <br />
              Минусы — длинные классы, порог входа, привязка к структуре и
              необходимость строго соблюдать правила.
            </p>
          </section>

          <section class="exam--card">
            <h4>
              6. Каскад, Специфичность (таблица), Наследование. 3 фактора.
            </h4>
            <a href="https://youtu.be/PEQ3i9q3ez8?si=sp7y35Dj_kYj2Mxx"
              >Видос от Ламкова</a
            >
            <h5>Каскад</h5>
            <p>
              Каскад — это алгоритм выбора финального значения свойства, когда
              на один элемент действует несколько CSS‑правил.
            </p>

            <h6>Главные идеи</h6>
            <ul>
              <li>
                Правила приходят из разных источников (стили браузера, стили
                пользователя, стили автора страницы).
              </li>
              <li>
                Браузер сравнивает важность, специфичность и порядок объявления
                и решает, какое значение взять.
              </li>
            </ul>
            <h5>2. Специфичность (и «таблица»)</h5>
            <p>
              Специфичность — это «вес» селектора; чем он выше, тем правило
              важнее. <br />

              Упрощённая табличка (от меньшего к большему):
            </p>
            <ul>
              <li>Селектор по тегу: p, div, section — низкая специфичность.</li>
              <li>
                Класс, псевдокласс: .btn, .error, :hover, [type="text"] — выше.
              </li>
              <li>ID: #header — ещё выше.</li>
              <li>
                Стиль в атрибуте style="" — самый высокий среди обычных
                (inline‑стиль).
              </li>
            </ul>
            <p>
              Если на элемент действуют два правила с разной специфичностью,
              победит более специфичный селектор. ​
            </p>
            <img
              width="100%"
              src="images/TableSpecific.jpg"
              alt="Таблица специфичности"
            />

            <div>
              <h5>Наследование</h5>
              <p>
                Наследование — это когда некоторые свойства CSS не задаются
                явно, а унаследуются от родителя.
              </p>
              <ul>
                <li>Наследуются, например: color, font-family, line-height.</li>
                <li>
                  Не наследуются: margin, padding, border, width, height и т.д.
                </li>
                <li>
                  Наследование можно управлять значениями inherit, initial,
                  unset.
                </li>
              </ul>

              <h5>«3 фактора» в каскаде</h5>

              <p>
                В упрощённом виде (для экзамена) три фактора, которыми браузер
                руководствуется:
              </p>
              <ol>
                <li>Важность (importance / origin)</li>
                <ul>
                  <li>!important побеждает обычные правила.</li>
                  <li>
                    Плюс источник: стили браузера < стили автора < !important и
                    т.п.
                  </li>
                </ul>
                <li>Специфичность селектора</li>
                <ul>
                  <li>ID > класс / псевдокласс > тег.</li>
                </ul>
                <li>Порядок объявления (source order)</li>
                <ul>
                  <li>
                    Если важность и специфичность совпали, выигрывает последнее
                    по порядку правило в CSS.
                  </li>
                </ul>
              </ol>
              <p>
                Наследование работает как дополнительный механизм: если элементу
                свойство не задано напрямую и нет более приоритетного правила,
                он берёт значение у родителя. ​
              </p>
            </div>
          </section>

          <section id="cascad-demo">
            <h2>Каскад спецефичность наследование</h2>

            <p class="text--cascad">Этот текста должен быть зеленым.</p>

            <p class="text special" id="important--text">
              А этот параграф поборется за размер и цвет шрифта
            </p>
          </section>

          <section class="exam--card">
            <h4>
              7. Блочная модель, строчные элементы. Стандартная блочная модель
              CSS. Альтернативная блочная модель CSS.
            </h4>
            <div>
              <h5>Блочная модель</h5>
              <p>
                Блочная модель - это алгоритм расчета размеров каждого отдельно
                взятого элемента страницы. Совокупность всех свойств влияющих на
                размеры элементов.
              </p>
              <div class="my--box">Я my--box</div>
              <img src="images/myBox.jpg" alt="Моя коробочка" />
              <img src="images/blockModel.jpg" alt="Блочная модель" />
              <p>Любой элемент в потоке — это прямоугольник из 4 слоёв:</p>
              <ul>
                <li>content — содержимое (текст, картинка).</li>
                <li>padding — внутренний отступ от контента до границы.</li>
                <li>border — рамка вокруг padding.</li>
                <li>margin — внешний отступ до соседних элементов.</li>
              </ul>
              <p>
                Схема: итоговый размер = content + padding + border + margin.
              </p>
            </div>
            <div>
              <h5>Блочные (block-level)</h5>
              <ul>
                <li>Всегда начинаются с новой строки.</li>
                <li>По умолчанию занимают всю доступную ширину родителя.</li>
                <li>
                  Можно задавать width/height, margin/padding по всем сторонам.
                </li>
                <li>Примеры: div, section, article, header, footer, ul, p</li>
              </ul>
              <h5>Строчные (inline-level)</h5>
              <ul>
                <li>Не начинают новую строку, идут «в строку» с текстом.</li>
                <li>Ширина = ширина содержимого.</li>
                <li>
                  width/height практически не работают; вертикальные
                  margin/padding ведут себя ограниченно.
                </li>
                <li>Примеры: span, a, strong, em, label.​</li>
              </ul>
              (Есть ещё inline-block, гибрид: стоит в строке, но ведёт себя как
              маленький блок — можно задавать width/height. )
              <h5>Альтернаятивная блочная модель</h5>
              Альтернативная модель включается через box-sizing: border-box: ​
              <ul>
                <li>
                  width и height задают размер всего видимого бокса: content +
                  padding + border.
                </li>
                <li>
                  При увеличении padding/border контентная область сжимается, но
                  визуальная ширина остаётся фиксированной.
                </li>
              </ul>

              Пример: <br />
              .box { <br />
              width: 200px; <br />
              padding: 20px; <br />
              border: 4px solid; <br />
              box-sizing: border-box; <br />
              } <br />

              Реальная видимая ширина будет ровно 200px, padding и border
              «влезают внутрь» этой ширины.

              <h5>Разница</h5>
              Разница только в том, как считается width/height относительно
              padding и border.
              <ul>
                <li>
                  Стандартная блочная модель (box-sizing: content-box)
                  (добавляет размер, "заботиться о контенте"): width/height
                  задают только контент. Padding и border добавляются сверху и
                  увеличивают реальный размер блока.
                </li>
                <li>
                  Альтернативная блочная модель (box-sizing: border-box)
                  (отжирает место у контента): width/height задают всю коробку
                  целиком (content + padding + border). При изменении
                  padding/border внешняя ширина не меняется, уменьшается только
                  область контента.
                </li>
              </ul>
            </div>
          </section>

          <div class="exam--card">
            <h4>
              8. Рассказать про свойство border, margin, padding, схлопывание,
              max(min)-width-height.
            </h4>
            <div>
              <h5>padding</h5>
              Внутренние рамки (от рамки к контенту) <br />

              Одно значение (padding 10px):
              <ol>
                <li>отступ будет добавлен со всех сторон одинаковый</li>
              </ol>
              Два значение (padding 10px 20px):
              <ol>
                <li>первое по вертикали</li>
                <li>второе по горизонтали</li>
              </ol>
              Три значения (padding 10px 20px 30px):
              <ol>
                <li>первое сверху</li>
                <li>горизонталь</li>
                <li>снизу</li>
              </ol>
              Четыре значения (padding 10px 20px 30px 40px). То (по часовой):
              <ol>
                <li>сверху</li>
                <li>справа</li>
                <li>снизу</li>
                <li>слева</li>
              </ol>
              Дополнительно:
              <ul>
                <li>padding-block - по вертикали</li>
                <li>padding-top - по горизонтали</li>
                <li>padding-top - сверху</li>
                <li>padding-left - слева</li>
                <li>padding-right - справа</li>
                <li>padding-bottom - снизу</li>
              </ul>

              Единицы измерения - доступны множество пиксели, проценты, въюмы,
              ремы. Но чаще всего приходится работать именно с пикселями
            </div>
            <div>
              <h5>margin</h5>
              название тегов одинаковое и аналогично padding. (Например,
              padding-top аналогично margin-top и так далее) <br />

              Но сама логика другая. margin отталкивает от себя рядом стояющие
              блоки.
              <h5>Схлопывание отступов. (Относится к margin)</h5>
              Если например, у одного рядомстоящего блока будет отступ 30px, у
              второго 40px, то они будут находиться друг от друга на расстоянии
              40px, а не 70px - это и называется схлопыванием отступов. <br />
              Также расстояние может быть отрицательным (margin: -40px) из-за
              чего блоки могут даже залезать друг на друга. В этом случае
              выбирается самый отрицательный margin.
            </div>
            <div>
              <h5>border (рамка элемента)</h5>
              border (рамка) — сущность между "настоящей" границей блока и
              padding. <br />
              <br />

              .box { <br />
              border: 2px solid #fff; <br />
              } <br />

              Это сразу задаёт: ​
              <ul>
                <li>border-width — толщину (2px).</li>
                <li>
                  border-style — стиль линии (solid, dashed, dotted, double,
                  none и т.д.).
                </li>
                <li>border-color — цвет.</li>
              </ul>
            </div>
            <div>
              <h5>min-width, max-width, min-height, max-height</h5>
              Эти свойства задают ограничения на размеры блока относительно
              обычных width/height.
              <ul>
                <li>
                  min - не позволяет блоку сжаться меньше определенного размера
                  по высоте/ширине.
                </li>
                <li>
                  max - не позволяет блоку стать больше указанного значения.
                </li>
              </ul>
            </div>
          </div>
          <div class="exam--card">
            <h4>
              9. Привести примеры: Селекторы, псевдоклассы, псевдоэлементы.
            </h4>
            <p>
              Псевдоэлементы - элементы которые несуществуют в HTML разметке, а
              задаются с помощью CSS с помощью специальных селекторов.
            </p>
            <p>
              Универсальные псевдоэлементы <br />
              before и after - позволяют прицепить к любому элементу страницы
              вспомогательный элемент. <br />
              Пример из этого сайта:
            </p>
            <img src="images/sBeforemCode.jpg" alt="Код с бефорем из HTML" />
            <img src="images/sBeforemStyle.jpg" alt="Стиль с бефорем" />
            <p class="with--before">Я элемент с бефорем.</p>

            <h5>Другие псевдоэлементы</h5>
            <ul>
              <li>
                placeholder - текст подсказка. (Пример меняющий все
                placeholderы)
              </li>

              &lt;input placeholder=&quot;&quot;&gt;
              <br />
              <br />
              input::placeholder{
              <br />
              color: grow;
              <br />
              }

              <li>
                file button (Загрузка файлов). Пример меняющий только для
                классов
              </li>
              &lt;input class=&quot;example--psevdo&quot;
              type=&quot;file&quot;&gt;
              <br />
              <br />
              .example--psevdo::file{
              <br />
              color: yellow;
              <br />
              }
              <li>first-letter - первая буква слова</li>
              <li>first-line - первая строка</li>
              <li>selection - кастомное выделение текста</li>
              <li class="custom--marker">
                marker - маркеры у ненумерованных списков.
              </li>
            </ul>
            <h5>псевдоклассы</h5>
            <p>
              Псевдоклассы - это такие селекторы к элементам которые
              эдовлетворяют определенным условиям.
            </p>
            <ul>
              <li>
                Наведение курсора<br />
                a:hover { <br />
                text-decoration: underline;<br />
                }
              </li>
              <li>
                Фокус в поле ввода. (Это когда tabом бегаешь по кнопкам)<br />
                input:focus {<br />
                outline: 2px solid #2563eb;<br />
                }
              </li>
              <li>
                Первый ребёнок<br />
                li:first-child {<br />
                font-weight: bold;<br />
                }
              </li>
              <li>
                Каждый второй элемент<br />
                tr:nth-child(2n) {<br />
                background: #f3f4f6;<br />
                }
              </li>
              <li>
                Элемент, который НЕ имеет класс .active<br />
                button:not(.active) {<br />
                opacity: 0.6;<br />
                }
              </li>
              <li>
                disabled. Помогает состояние интерактивного элемента когда с ним
                нельзя провзаимодействовать.
              </li>
              <li>checked характерно только для type = checkbox/redio</li>
            </ul>
            <p>
              Псевдокласс - это состояние элемента. <br />
              Псевдоэлемент - это часть элемента.
            </p>
          </div>

          <div class="exam--card">
            <h4>10. Перечислить единицы измерения. Различия em и rem.</h4>
            <h5>Относительные (те что измеряются относительно чего-либо)</h5>
            <ul>
              <li>% - проценты</li>
              <ul>
                <li>width (высота) - вычисляется от родительского элемента</li>
                <li>
                  height (высота) - сработает только если у родительского
                  элемента указана конкретная высота <br />
                  если прописан (position: absolut) - то вычисляется от
                  ближайшего нестатического родителя
                </li>
              </ul>
              <li>
                em - относительно размера шрифта
                <p>
                  браузер возьмет родительский элемент с текстом, найдет размер
                  этого текста, и умножит его на значение указанное в em (если
                  0.5em - то размер = размер шрифта родителя * 0.5).
                </p>
              </li>
              <li>
                rem - относительно корневого элемента разметки для тега html.
                <br />
                Пример: <br />
                html { <br />
                font-size: 10px; <br />
                } <br />
                .small{ <br />
                font-size: 0.75rem (т. е. 7.5 пикселя) <br />
                }
              </li>
              <li>
                vw - проценты от ширины вьюпорта (окна браузера). <br />
                (10vw = 10% от текущей ширины окна браузера)
              </li>
              <li>vh - проценты от высоты вьюпорта (окна браузера)</li>
              <li>fr — доля свободного пространства в CSS Grid.</li>
            </ul>
            <h5>Абсолютные (те что ни от чего не зависят)</h5>
            <ul>
              <li>
                px - пиксели. на самом деле довольно адаптивен, так как размер
                пикселя завист от экрана и устройства
              </li>
              <li>
                cm, mm, in, pt, pc — (миллиметры, сантиметры и т.д.)
                используются в печати, физические единицы.
              </li>
            </ul>
          </div>
          <div class="exam--card">
            <h4>
              11. Рассказать про Flexbox. flex-container, flex Items, shrink,
              grow.
            </h4>
            <a href="https://youtu.be/YG8Vhz1pAsU?si=nv_xtbo28VxSPUyt"
              >Видос "CSS Flexbox Layout. Флексы в CSS."</a
            >
            <p>
              Flexbox — это режим раскладки, в котором родитель (flex‑container)
              управляет расположением и размером своих детей (flex‑items) в
              одном направлении и может «растягивать» или «сжимать» их под
              доступное пространство. ​
            </p>
            <h5>Flex‑container</h5>
            Flex‑контейнер — элемент, у которого display: flex (типа
            классического блока, когда всю ширину занимает) или display:
            inline-flex (типа строки, занимает только требуемый для контента
            объем). <br />
            ​ Пример: <br />
            css <br />
            .container { <br />
            display: flex; (делаем контейнер flex‑контейнером) <br />
            flex-direction: row; /* ось: по горизонтали (по умолчанию) */ <br />
            gap: 16px; (расстояние между элементами) <br />
            } <br />

            Все прямые дети .container > * становятся flex‑items. <br />

            Можно легко выравнивать и распределять элементы (justify-content,
            align-items, gap).
            <ul>
              <li>
                justify-content — распределение элементов по главной оси (обычно
                горизонталь: слева, справа, по центру, с равными промежутками).
                <br />
                justify-content: center; (по главной оси в центр)
              </li>
              <li>
                align-items — по второстепенной оси (обычно вертикаль: сверху,
                снизу, по центру, растянуть). <br />
                align-items: flex-start; (по перекрёстной оси к верху)
              </li>
              <li>
                gap — расстояние между самими элементами (горизонтальные и
                вертикальные “промежутки” внутри flex/grid‑контейнера). <br />
                gap: 16px;
              </li>
            </ul>

            <div>
              <h5>Flex‑items</h5>
              Flex‑элементы — прямые дети flex‑контейнера. <br />
              <br />

              &lt;div class=&quot;container&quot;&gt;     &lt;div <br />
              class=&quot;item item--1&quot;&gt;1&lt;/div&gt;     &lt;div <br />
              class=&quot;item item--2&quot;&gt;2&lt;/div&gt;     &lt;div <br />
              class=&quot;item item--3&quot;&gt;3&lt;/div&gt; &lt;/div&gt;
              <br />
              <br />
              css <br />
              <br />
              .item { <br />
              flex-basis: 200px; (базовая ширина/высота вдоль главной оси)
              <br />
              }
            </div>
            ​ Для каждого flex‑item можно настроить:
            <ul>
              <li>
                flex-grow — как он будет расти, если есть свободное место.
              </li>
              <li>
                flex-shrink — как он будет сжиматься, если места не хватает.
              </li>
              <li>flex-basis — базовый размер до растягивания/сжатия.</li>
            </ul>

            <div>
              <h5>flex-grow (растягивание)</h5>
              flex-grow — коэффициент, который показывает, какую долю свободного
              пространства получит элемент по сравнению с соседями. <br />
              css <br />
              .item--1 { flex-grow: 1; } (получит 1 «долю») <br />
              .item--2 { flex-grow: 2; } (2 доли (в два раза больше, чем
              первый))
              <br />
              .item--3 { flex-grow: 0; } (не будет расширяться) <br />
            </div>

            <div>
              <h5>flex-shrink (сжатие)</h5>
              flex-shrink — коэффициент, который показывает, как сильно элемент
              готов сжиматься, когда контейнеру не хватает места. ​ css <br />
              .item--1 { flex-shrink: 1; } /* стандартное сжатие */ <br />
              .item--2 { flex-shrink: 0; } /* не сжимать */ <br />
              .item--3 { flex-shrink: 2; } /* можно сжимать активнее */ <br />

              Когда суммарная ширина flex‑items > ширины контейнера: <br />
              <ul>
                <li>элементы с большим flex-shrink ужимаются сильнее,</li>
                <li>
                  с flex-shrink: 0 стараются не сужать вообще (пока можно).
                </li>
              </ul>
            </div>
          </div>

          <div class="exam--card">
            <h4>12. Рассказать про CSS Grid.</h4>
            <a href="https://youtu.be/JrKOHNRnRMg?si=h0XrAtxVMVmOF9C8"
              >Видос про Gridы</a
            >
            CSS Grid — это система двумерной раскладки (строки + столбцы) для
            построения сеток и макетов страниц.

            <h5>Основные понятия</h5>

            <ul>
              <li>Grid‑контейнер — элемент с display: grid или inline-grid.</li>
              <li>
                Grid‑элементы — прямые дети контейнера, автоматически становятся
                «ячейками» сетки.
              </li>
              <li>Сетка состоит из:</li>
              <ul>
                <li>столбцов (columns);</li>
                <li>строк (rows);</li>
                <li>промежутков (gaps).</li>
              </ul>
            </ul>

            <h5>Как задать сетку (Минимальный пример):</h5>

            css <br />
            .grid { <br />
            display: grid; /* включаем Grid */ <br />
            grid-template-columns: 1fr 1fr 1fr; /* три равных столбца */ <br />
            grid-template-rows: auto auto; /* две строки по контенту */ <br />
            gap: 16px; /* расстояние между ячейками */ <br />
            } <br />
            <br />

            &lt;div class="grid"&gt; <br />
            &lt;div&gt;1&lt;/div&gt; <br />
            &lt;div&gt;2&lt;/div&gt; <br />
            &lt;div&gt;3&lt;/div&gt; <br />
            &lt;div&gt;4&lt;/div&gt; <br />
            &lt;div&gt;5&lt;/div&gt; <br />
            &lt;div&gt;6&lt;/div&gt; <br />
            &lt;/div&gt; <br />
            <br />

            <ul>
              <li>
                grid-template-columns / grid-template-rows задают количество и
                размер треков (1fr, 200px, repeat(3, 1fr) и т.д.).
              </li>
              <li>
                gap (или row-gap/column-gap) задаёт отступы между ячейками, не
                трогая margin.
              </li>
            </ul>

            <h5>Управление позиционированием элементов</h5>

            Каждый grid‑item можно растянуть на несколько рядов/колонок: <br />
            <br />
            ​ .item1 { <br />
            grid-column: 1 / 3; /* от линии 1 до 3 по колонкам (занять 2
            столбца) */ <br />
            grid-row: 1 / 2; /* первая строка */ <br />
            } <br />
            <br />

            .item2 { <br />
            grid-column: 3 / 4; /* третий столбец */ <br />
            grid-row: 1 / 3; /* растянуть на две строки */ <br />
            } <br />
            <br />

            <h5>Коротко:</h5>
            <ul>
              <li>
                grid-column-start, grid-column-end, grid-row-start, grid-row-end
                — управляют началом/концом по линиям сетки.
              </li>
              <li>
                Шорт‑запись: grid-column: start / end, grid-row: start / end.
              </li>
              <li>
                Плюс есть grid-template-areas, где макет можно описать текстовой
                «картой» (шпаргалочно можно просто упомянуть).
              </li>
            </ul>
            <h5>Разница Grid и Flexbox (можно фразой для билета)</h5>
            <ul>
              <li>
                Flexbox — одномерный (управляет либо строкой, либо колонкой).
              </li>
              <li>
                Grid — двумерный (строки и столбцы одновременно, удобно для
                сложных макетов).
              </li>
            </ul>
          </div>

          <div class="exam--card">
            <h4>
              13. Позиционирование. (absolute, relative, sticky, fixed).
              Нормальный поток в документе
            </h4>
            <a href="https://youtu.be/jQCzxM2dPWU?si=5JpAh59Iqtie0qDJ"
              >Видос про позиционирование</a
            >
            Позиционирование — это способ изменить, как элемент участвует в
            нормальном потоке и относительно чего считаются
            top/right/bottom/left.
            <h5>Нормальный поток документа (flow layout)</h5>

            <ul>
              <li>Блочные элементы идут сверху вниз, занимая всю ширину.</li>
              <li>Строчные — слева направо в строке.</li>
              <li>
                Элементы учитывают друг друга: следующий становится после
                предыдущего.
              </li>
            </ul>
            Любое «особое» позиционирование (absolute, fixed, частично sticky)
            может вытащить элемент из нормального потока.

            <div>
              <h5>position: relative</h5>
              <p>
                .box { <br />
                position: relative; <br />
                top: 10px; <br />
                left: 20px; <br />
                } <br />
              </p>
              <ul>
                <li>
                  Элемент остаётся в нормальном потоке, место за ним
                  сохраняется.
                </li>
                <li>
                  Сдвигается относительно своего исходного положения на
                  top/left/right/bottom.
                </li>
                <li>
                  Часто используется как «опорный» контейнер для position:
                  absolute внутри.
                </li>
              </ul>
            </div>
            ​

            <div>
              <h5>position: absolute</h5>
              <p>
                .child { <br />
                position: absolute; <br />
                top: 0; <br />
                right: 0; <br />
                }
              </p>
              <ul>
                <li>
                  Элемент вынут из нормального потока: соседние его «не видят».
                </li>
                <li>
                  Координаты считаются от ближайшего предка с position ≠ static
                  (обычно relative, absolute, fixed), а если такого нет — от
                  вьюпорта/страницы.
                </li>
                <li>
                  Используется для попапов, бейджей, плавающих элементов внутри
                  блока.
                </li>
              </ul>
            </div>
            <div>
              <h5>position: fixed</h5>
              <div>
                .banner { <br />
                position: fixed; <br />
                top: 0; <br />
                right: 0; <br />
                }
              </div>
              <ul>
                <li>Тоже вне нормального потока.</li>
                <li>
                  Закреплён относительно вьюпорта: не двигается при скролле.
                </li>
                <li>
                  Типичные примеры: фиксированное меню сверху, плавающая кнопка
                  «вверх».
                </li>
              </ul>
            </div>

            <div>
              <h5>position: sticky</h5>
              <div>
                .header { <br />
                position: sticky; <br />
                top: 0; <br />
                } <br />
              </div>
              <ul>
                <li>Гибрид relative и fixed.</li>
                <li>
                  Пока не доскроллили до заданного порога (top/bottom) — ведёт
                  себя как relative и остаётся в потоке.
                </li>
                <li>
                  Как только пересекли порог — «прилипает» и ведёт себя как
                  fixed в пределах своего контейнера (когда контейнер ушёл —
                  элемент тоже уходит).
                </li>
                <li>
                  Используется для липких заголовков секций, таблиц, сайдбаров.
                </li>
              </ul>
            </div>

            <div>
              <h5>Кратко для билета:</h5>
              <ul>
                <li>
                  Нормальный поток — стандартное размещение блоков и строк без
                  особого позиционирования.
                </li>
                <li>
                  relative — остаётся в потоке, но можно сдвигать от исходного
                  места.
                </li>
                <li>
                  absolute — выпадает из потока, позиционируется относительно
                  ближайшего спозиционированного предка.
                </li>
                <li>
                  fixed — выпадает из потока, приклеен к вьюпорту, не
                  скроллится.
                </li>
                <li>
                  sticky — сначала как relative, после порога скролла — как
                  fixed внутри своего контейнера.
                </li>
              </ul>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              14. Рассказать про z-index, контекст наложения и свойство
              overflow.
            </h4>

            <img
              class="standart--pictures"
              src="images/contecstNalojeniya.jpg"
              alt="Контекст наложения"
            />

            <div>
              <h5>z-index (порядок наложения)</h5>
              <p>z-index управляет тем, кто поверх кого при перекрытии.</p>
              <ul>
                <li>
                  Работает для элементов с position, отличным от static
                  (relative, absolute, fixed, sticky) и для flex/grid‑элементов.
                </li>
                <li>
                  Чем больше z-index, тем выше слой внутри своего контекста
                  наложения: элемент с z-index: 10 будет над z-index: 1.
                </li>
              </ul>
              <p>Пример:</p>
              <pre><code>.box1 { position: absolute; z-index: 1; }
.box2 { position: absolute; z-index: 2; } /* будет сверху box1 */</code></pre>
            </div>

            <div>
              <h5>Контекст наложения (stacking context)</h5>
              <p>
                Stacking context — это локальная трёхмерная «сцена», внутри
                которой сравниваются z-index.
              </p>

              <p>Важно:</p>
              <ul>
                <li>
                  Каждый контекст наложения ведёт себя как самостоятельный слой.
                </li>
                <li>
                  Дети не могут вылезти выше элементов из других контекстов, чем
                  их родитель, даже с большим z-index.
                </li>
              </ul>

              <p>Новый контекст создаётся, если:</p>
              <ul>
                <li>элемент — корень документа (&lt;html&gt;);</li>
                <li>элемент имеет position ≠ static и z-index ≠ auto;</li>
                <li>
                  или некоторые другие свойства: opacity &lt; 1, transform,
                  filter, isolation: isolate и т.п.
                </li>
              </ul>

              <p>
                Типичный сценарий: поставил родителю position: relative;
                z-index: 1; — создал контекст; дети с z-index: 9999 всё равно не
                перепрыгнут другие блоки вне этого родителя, если сам родитель
                ниже.
              </p>
            </div>

            <div>
              <h5>overflow</h5>
              <p>
                overflow управляет тем, что делать с содержимым, которое вылезло
                за границы блока.
              </p>

              <p>Основные значения:</p>
              <ul>
                <li>
                  visible (по умолчанию) — контент спокойно вылезает наружу,
                  ничего не обрезается.
                </li>
                <li>
                  hidden — лишнее обрезается, без полос прокрутки; можно прятать
                  «хвосты» или делать маски.
                </li>
                <li>
                  scroll — всегда показываются полосы прокрутки, даже если
                  контент помещается.
                </li>
                <li>
                  auto — добавляет полосы прокрутки, только если контент
                  действительно не помещается.
                </li>
              </ul>

              <p>
                Есть отдельные оси: <br />
                box { <br />
                overflow-x: auto; /* только по горизонтали */ <br />
                overflow-y: hidden; /* по вертикали обрезаем */ <br />
                } <br />
              </p>

              <p>
                Это используют, например, для горизонтальных списков с
                прокруткой.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              15. CSS для типографии. (font-size, line-height и т.д) Как
              подключать шрифты на сайт.
            </h4>
            <div>
              <p>
                CSS‑типографика управляет тем, как выглядит и ведёт себя текст:
                шрифты, размеры, интервалы, переносы, декор и подключение
                нестандартных гарнитур.
              </p>
              <h5>Основные свойства для текста</h5>
              <ul>
                <li>
                  <p>
                    font-family — семейство шрифта. <br />
                    Можно указать несколько через запятую, от более конкретного
                    к запасным: <br />

                    body { <br />
                    font-family: "Roboto", "Helvetica Neue", Arial, "Noto Sans",
                    sans-serif; <br />
                    } <br />
                    Браузер берёт первый доступный шрифт; базовые семейства:
                    serif, sans-serif, monospace.
                  </p>
                </li>
                <li>
                  font-size — размер шрифта (px, em, rem, %, vw, vh и т.д.).
                </li>
                <li>
                  font-weight — жирность (обычно 100–900; 400 — normal, 700 —
                  bold).
                </li>
                <li>font-style — начертание: normal, italic, oblique.</li>
                <li>
                  line-height — интерлиньяж, расстояние между строками; часто
                  задают без единиц (коэффициент, например 1.5).
                </li>
                <li>letter-spacing — кернинг, расстояние между буквами.</li>
                <li>
                  text-indent — отступ первой строки абзаца (красная строка).
                </li>
                <li>color — цвет текста.</li>
                <li>
                  text-align — выравнивание текста: left/right/center/justify
                  (или start/end).
                </li>
                <li>
                  text-transform — преобразование регистра: uppercase,
                  lowercase, capitalize, none.
                </li>
                <li>
                  <p>
                    text-decoration — декор текста (подчёркивание, зачёркивание
                    и т.п.), шорт‑запись для:
                  </p>
                  <ul>
                    <li>
                      text-decoration-line — underline, overline, line-through,
                      none;
                    </li>
                    <li>text-decoration-color;</li>
                    <li>
                      text-decoration-style — solid, double, dotted, dashed,
                      wavy;
                    </li>
                    <li>text-decoration-thickness.</li>
                  </ul>
                  ​
                  <p>
                    .underline { <br />
                    text-decoration: underline red wavy 2px; <br />
                    }
                  </p>
                </li>
                <li>
                  text-underline-offset — расстояние от подчёркивания до текста.
                </li>
                <li>
                  text-decoration-skip-ink — как линия проходит через «хвосты»
                  букв (p, g): auto / none.
                </li>
              </ul>
            </div>
            <div>
              <h5>Переносы, обрезка и пробелы</h5>
              <ul>
                <li>
                  overflow-wrap — как переносить длинные слова:
                  <ul>
                    <li>normal — не ломать слово;</li>
                    <li>
                      break-word / anywhere — можно разрывать слово, чтобы оно
                      влезло в контейнер. Очень полезно, чтобы текст не
                      «разъезжал» верстку.
                    </li>
                  </ul>
                </li>
                <li>
                  text-overflow — как показать, что текст обрезан:
                  <ul>
                    <li>clip — просто отрезать;</li>
                    <li>ellipsis — добавить ….</li>
                  </ul>
                </li>
                <li>
                  white-space — как обрабатывать пробелы и переносы:
                  <ul>
                    <li>
                      normal — схлопывать пробелы, переносить строки (по
                      умолчанию);
                    </li>
                    <li>nowrap — не переносить строки;</li>
                    <li>
                      pre — как в &lt;pre&gt;: сохранять пробелы и переносы;
                    </li>
                    <li>
                      pre-wrap, pre-line — комбинации сохранения
                      пробелов/переносов.
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>Типичный паттерн «truncate в одну строку»:</h5>
              <p>
                .truncate { <br />
                overflow: hidden; <br />
                text-overflow: ellipsis; <br />
                white-space: nowrap; <br />
                }
              </p>
            </div>
            <div>
              <h5>Направление и ориентация текста</h5>
              <ul>
                <li>
                  writing-mode — направление строк и блоков:
                  <ul>
                    <li>
                      например, vertical-lr — текст сверху вниз, столбцы слева
                      направо.
                    </li>
                  </ul>
                </li>
                <li>
                  text-orientation — ориентация символов во вертикальном режиме
                  (upright, mixed).
                </li>
              </ul>
              <p>
                Используется для вертикальных заголовков, восточноазиатских
                текстов и т.п.
              </p>
            </div>
            <div>
              <h5>Подключение шрифтов: системные, @font-face, Google Fonts</h5>
              <p>
                Системные и базовые семейства <br />
                Браузер всегда имеет набор стандартных шрифтов:
              </p>
              <ul>
                <li>serif — с засечками;</li>
                <li>sans-serif — без засечек;</li>
                <li>monospace — моноширинные (обычно в редакторах кода).</li>
              </ul>
              <p>Через запятую описывается цепочка fallback:</p>

              <p>
                body { <br />
                font-family: "Montserrat", "Roboto", "Helvetica Neue", Arial,
                sans-serif; <br />
                }
              </p>

              <h5>Свой шрифт через @font-face</h5>
              <p>
                Когда встроенных шрифтов мало, используют @font-face и шрифты
                как файлы (.woff2, .woff).
              </p>

              <p>
                @font-face { <br />
                font-family: "Montserrat"; <br />
                font-style: normal; /* обычное начертание */ <br />
                font-weight: 400; /* нормальная жирность */ <br />
                src: <br />
                local("Montserrat"), <br />
                url("./fonts/Montserrat.woff2") format("woff2"); <br />
                font-display: swap; <br />
                } <br />
                <br />
                @font-face { <br />
                font-family: "Montserrat"; <br />
                font-style: italic; <br />
                font-weight: 400; <br />
                src: url("./fonts/MontserratItalic.woff2") format("woff2");
                <br />
                font-display: swap; <br />
                } <br />
                <br />
                body { <br />
                font-family: "Montserrat", sans-serif; <br />
                } <br />
              </p>

              <p>Ключевые моменты:</p>

              <ul>
                <li>
                  Для каждой комбинации font-weight + font-style нужен свой
                  @font-face и свой файл.
                </li>
                <li>
                  src: local(...) позволяет не качать файл, если шрифт уже есть
                  в системе пользователя.
                </li>
                <li>
                  font-display: swap — сначала показываем текст запасным
                  шрифтом, потом плавно переключаемся на загруженный; это
                  улучшает UX и перформанс.
                </li>
              </ul>
              <p>Перфоманс:</p>
              <ul>
                <li>
                  Много файлов шрифтов (например, 9 весов × 2 стиля = 18 файлов)
                  сильно бьют по загрузке.
                </li>
                <li>
                  На практике обычно используют 1–2 семейства, ограниченный
                  набор весов (например, 400 и 700) и комбинируют их в дизайне.
                </li>
              </ul>

              <p>Подключение через Google Fonts и другие сервисы</p>
              <ol>
                <li>На Google Fonts выбирается семейство, веса и стили.</li>
                <li>
                  <p>
                    Сервис даёт <link />: <br />
                    <br />
                    &lt; link <br />
                    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;1,100&display=swap"
                    <br />
                    rel="stylesheet" <br />
                    /&gt; <br />
                    <br />
                  </p>
                </li>
                <li>
                  <p>
                    В CSS: <br />
                    css <br />
                    body { <br />
                    font-family: "Roboto", sans-serif; <br />
                    }
                  </p>
                </li>
              </ol>

              <p>
                Фактически по этому URL лежит CSS с @font-face, его можно
                открыть и посмотреть. <br />

                Если шрифт не из Google Fonts (купленный, корпоративный) —
                подключают как статические файлы через @font-face, как в примере
                выше.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              16. CSS custom properties - CSS calc (функции сalc и var). Функции
              сlamp() для fluid typography, min(), max(). Как они помогают в
              адаптивном дизайне без медиа-запросов.
            </h4>
            <h5>CSS custom properties и var()</h5>
            <p>
              CSS‑переменные (custom properties) — это собственные значения в
              CSS, которые можно переиспользовать и переопределять. Они
              объявляются как `--имя` и читаются через `var()`.
            </p>
            <p>
              :root { <br />
              --primary-color: red; <br />
              --header-height: 80px; <br />
              } <br />

              .button { <br />
              background-color: var(--primary-color); <br />
              } <br />

              .banner { <br />
              height: calc(var(--header-height) * 2); <br />
              }
            </p>
            <h6>Особенности:</h6>
            <ul>
              <li>
                Область видимости: переменные наследуются — объявленные в
                `:root` доступны везде; можно переопределять на уровне
                блока/темы.
              </li>
              <li>
                <p>Можно делать «темы» через переопределение переменных:</p>
                <p>
                  .posts-wrapper { <br />
                  --main-color: red; <br />
                  } <br />

                  .posts-wrapper--dark { <br />
                  --main-color: black; <br />
                  } <br />

                  .post-header { <br />
                  color: var(--main-color); <br />
                  }
                </p>
              </li>
              <li>
                <p>
                  `var(--name, fallback)` — второе значение используется, если
                  переменная не определена. Допускается вложенный fallback:
                </p>
                <p>
                  .posts-wrapper { <br />
                  color: var(--primary-color, red); <br />
                  } <br />

                  .title { <br />
                  color: var(--primary-color, var(--main-color, black)); <br />
                  }
                </p>
              </li>
            </ul>
            <p>CSS‑переменные удобно использовать для:</p>
            <ul>
              <li>палитры (цвета темы, тёмная/светлая);</li>
              <li>типографики (база шрифта, scale‑фактор);</li>
              <li>отступов, размеров блоков;</li>
              <li>
                - адаптивных формул (через `calc`, `min`, `max`, `clamp`).
              </li>
            </ul>
            <div>
              <h5>Функция calc()</h5>
              <p>
                `calc()` вычисляет значение свойства по математическому
                выражению.
              </p>
              <ul>
                <li>Поддерживаются `+`, `-`, `*`, `/`.</li>
                <li>
                  Можно мешать разные единицы: `px`, `%`, `em`, `rem`, `vw`,
                  `vh` и т.д.
                </li>
                <li>
                  У **`+` и `-` обязательно должны быть пробелы** с обеих
                  сторон: `calc(100% - 20px)`, иначе браузер может воспринять
                  `-20px` как одно число.
                </li>
                <li>
                  Хотя бы у одного операнда должна быть единица измерения.
                </li>
              </ul>
              <p>Примеры:</p>
              <p>
                width: calc(100% - 20px); <br />
                width: calc(100% + (20px * 2)); <br />
                width: calc(150px / 2);
              </p>
              <p>
                (пример `calc(150px * 20px)` теоретически валиден как синтаксис,
                но на практике размеры так не задают). <br /><br />

                Практическое применение — адаптивная ширина колонок:
              </p>
              <p>
                .container { display: flex; gap: 10px; } .elem1, .elem2, .elem3
                { width: calc(100% / 3); }
              </p>
              <p>
                Раньше писали «33.333%» руками, теперь браузер сам посчитает
                точно.
              </p>
            </div>
            <div>
              <h5>min() и max()</h5>
              <ul>
                <li>`min(a, b, c)` — берёт **минимальное** значение.</li>
                <li>`max(a, b, c)` — берёт **максимальное** значение.</li>
              </ul>
              <p>Примеры:</p>
              <p>
                .selector { <br />
                width: min(70%, 800px); /* не шире 800px, но до этого — 70% */
                <br />
                } <br />

                .container { <br />
                width: max(70%, 800px); /* не уже 800px, но может быть шире
                (70%) */ <br />
                }
              </p>
              <p>Использование:</p>
              <ul>
                <li>ограничение максимальной ширины контентной области;</li>
                <li>
                  гарантия минимальной ширины/отступа на больших/маленьких
                  экранах.
                </li>
              </ul>
            </div>
            <div>
              <h5>clamp() и fluid typography</h5>
              <p>
                `clamp(min, preferred, max)` — задаёт значение, которое
                **зажато** между минимумом и максимумом, но внутри может
                меняться по формуле.
              </p>
              <p>Пример из СФУ:</p>
              <p>
                h1 { <br />
                font-size: clamp(24px, 5vw + 1rem, 64px); <br />
                }
              </p>
              <ul>
                <li>min = `24px` — заголовок никогда не станет меньше 24px.</li>
                <li>
                  preferred = `5vw + 1rem` — плавно растёт с шириной окна:
                </li>
                <ul>
                  <li>`5vw` — 5% ширины viewport;</li>
                  <li>`1rem` — базовый шрифт (обычно 16px).</li>
                </ul>
                <li>max = `64px` — заголовок никогда не станет больше 64px.</li>
              </ul>
              <p>Поведение:</p>
              <ul>
                <li>
                  На маленьких экранах, когда `5vw + 1rem < 24px`, размер =
                  24px.
                </li>
                <li>
                  На средних — размер = `5vw + 1rem`, плавная fluid‑типографика.
                </li>
                <li>
                  На больших, когда `5vw + 1rem > 64px`, размер фиксируется на
                  64px.
                </li>
              </ul>
              <p>То же можно применять к:</p>
              <ul>
                <li>отступам (`padding: clamp(...)`);</li>
                <li>ширинам/высотам блоков;</li>
                <li>gap в сетках.</li>
              </ul>
            </div>
            <div>
              <h5>Функция attr()</h5>
              <p>
                `attr()` позволяет использовать значения HTML‑атрибутов в CSS
                (ограниченно, в основном в `content` псевдоэлементов). <br />
                <br />
                Пример:
              </p>
              <p>
                .tooltip::after { <br />
                content: attr(data-tooltip); <br />
                }
              </p>
              <p>
                В контексте билета достаточно **упомянуть**, что такая функция
                есть, и что основная тема — всё же `var`, `calc`,
                `min/max/clamp`.
              </p>
            </div>
            <div>
              <h5>Как это помогает в адаптивном дизайне без медиа‑запросов</h5>
              <p>Комбинация:</p>
              <ul>
                <li>CSS‑переменных (централизованные значения);</li>
                <li>`calc()` (формулы с разными единицами);</li>
                <li>
                  `min()`, `max()`, `clamp()` (ограничения и «гибкие» размеры)
                </li>
              </ul>
              <p>позволяет:</p>
              <ul>
                <li>
                  делать **fluid typography** — размер шрифта плавно меняется от
                  ширины экрана, но не меньше/больше заданных границ;
                </li>
                <li>
                  задавать адаптивные отступы и ширины блоков, которые сами
                  подстраиваются под viewport;
                </li>
                <li>
                  ограничивать размеры без большого количества `@media` (часто
                  достаточно 1–2 правил вместо 3–5 брейкпоинтов).
                </li>
              </ul>
              <p>Типичный пример, который можно привести на экзамене:</p>
              <p>
                :root { <br />
                --space: 1.5rem; <br />
                } <br />

                .page { <br />
                padding-inline: clamp(1rem, 4vw, 3rem); <br />
                max-width: min(100% - 2 * var(--space), 1200px); <br />
                }
              </p>
              <p>Здесь без единого медиазапроса:</p>
              <ul>
                <li>отступы растут с шириной окна, но в разумных пределах;</li>
                <li>
                  контентная область не становится уже, чем надо, и не
                  разъезжается шире 1200px.
                </li>
              </ul>
              <h5>Фраза для билета:</h5>
              <p>
                > CSS custom properties (`var`) позволяют хранить значения
                (цвета, размеры, базовый font-size) и переопределять их,
                например для тёмной темы. `calc()` даёт математические выражения
                с разными единицами. `min()`, `max()` и особенно `clamp()`
                позволяют задавать «гибкие» размеры с нижней и верхней границей.
                Вместе они дают fluid‑типографику и адаптивную вёрстку, которая
                подстраивается под ширину экрана без большого числа
                медиазапросов.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              17. Что такое Адаптивная верстка, резиновая верстка. Breakpoints.
              В чем различия desktop first и mobile first. Что такое
              контейнерные запросы, зачем они нужны - какие проблемы решают.
            </h4>
            <div>
              <h5>Адаптивная верстка</h5>
              <p>
                Адаптивная верстка основывается на использовании медиа-запросов
                и CSS-правил. С ее помощью можно изменять стили и расположение
                элементов на странице в зависимости от размера экрана
                устройства, на котором сайт отображается. В результате сайт
                может лучше адаптироваться к различным размерам экранов, что
                повышает удобство использования сайта на мобильных устройствах.
                <br />
                Например, на компьютере, сетка, которая состоит из 3 колонок, а
                на мобильных устройствах, колонка будет одна.
              </p>
              <img
                class="standart--pictures"
                src="images/adaptivFerst.jpg"
                alt="Пример адаптивной верстки"
              />

              <p>
                .container{ <br />
                display: grid; <br />
                grid-template-columns: repeat(3, minmax(0, 1fr)); <br />
                } <br />
                @media (max-width: 768px) <br />
                .container{ <br />
                grid-template-columns: repeat(1, minmax(0, 1fr)); <br />
                }
              </p>
            </div>
            <div>
              <h5>Медиа запросы</h5>
              <p>
                Медиа-выражения - это условия, которые проверяются в CSS, чтобы
                определить, должны ли быть применены определенные стили к
                элементам на странице. Например, медиа-выражение может проверять
                ширину экрана устройства и применять соответствующие стили.
              </p>
              <p>
                Медиа-запросы - это блоки CSS-кода, которые определяют, какие
                стили должны применяться к элементам на странице в зависимости
                от результатов проверки медиа-выражений. <br />
                В этом примере медиа-запрос, который выделен синим цветов,
                содержит стили, которые будут применяться к элементам на экранах
                с максимальной шириной 768 пикселей. <br />
                В данном случае, стили изменяют размер шрифта и ширину
                контейнера. Красным цветом выделено медиа-выражение, которое
                проверяет условие. <br />
                В медиа-выражениях, при проверке ширины или высоты экрана,
                размеры обычно указываются в пикселях.
              </p>
              <p class="red--text">@media (max-width: 768px) {</p>
              <p class="blue--text">
                body { <br />
                font-size: 16px; <br />
                } <br />
                .container { <br />
                width: 100%; <br />
                } <br />
                }
              </p>
              <p>
                Типы носителей описывают общую категорию устройства. За
                исключением случаев использования логических операторов not или
                only, тип носителя является необязательным, а тип all
                предполагаемым.
              </p>
              <ul>
                <li>all - подходит для всех устройств.</li>
                <li>screen - предназначен в первую очередь для экранов.</li>
                <li>
                  print - предназначен для постраничного материала и документов.
                </li>
              </ul>
              <p>
                Иными словами, с помощью print можно задать медиазапросы для
                печати, например, убрать ненужные блоки на веб-странице, перед
                ее печатью.
              </p>
              <h5>Логические операторы запросов</h5>
              <ul>
                <li>
                  <h6>AND</h6>
                  <p>Оба условия должны соблюдаться.</p>
                  <p>
                    @media (max-width: 767px) and (orientation: portrait) {
                    <br />
                    <br />
                    }
                  </p>
                </li>

                <li>
                  <h6>OR логическое или</h6>
                  <p>
                    @media (max-width: 767px), (min-width: 768px) and
                    (max-width: 1024px) { <br />
                    <br />
                    }
                  </p>
                </li>

                <li>
                  <h6>NOT Логическое отрицание</h6>
                  <p>
                    @media not screen and (color) { <br />
                    <br />
                    }
                  </p>
                </li>
              </ul>

              <p>
                Узконаправленные @media помогают учитывать тип ввода и тему ОС
                без JS.
              </p>
              <h5>hover и pointer (тип устройства)</h5>
              <ul>
                <li>
                  hover — умеет ли основное устройство ввода «наводить»
                  указатель.
                  <ul>
                    <li>
                      @media (hover: hover) — есть нормальный hover (мышь,
                      тачпад).
                    </li>
                    <li>
                      @media (hover: none) — hover‑эффекты недоступны (чистый
                      тач).
                    </li>
                  </ul>
                </li>
                <li>
                  pointer — точность указателя.
                  <ul>
                    <li>coarse — грубый ввод (палец по экрану).</li>
                    <li>fine — точный (мышь, стилус).</li>
                    <li>none — указателя нет.</li>
                  </ul>
                </li>
              </ul>
              <p>
                Примеры: <br />
                <br />
                css <br />
                /* Палец: смартфоны / грубый тач */ <br />
                @media (hover: none) and (pointer: coarse) {} <br />
                <br />
                /* Стилус: тач с точным вводом */ <br />
                @media (hover: none) and (pointer: fine) {} <br />
                <br />
                /* Мышь/тачпад: есть hover и точный указатель */ <br />
                @media (hover: hover) and (pointer: fine) {} <br />
              </p>
              <p>
                Можно, например, анимировать цвет по :hover только на
                устройствах с мышью, а на тач‑экранах менять состояние по клику.
              </p>
              <div>
                <h5>prefers-color-scheme (тёмная/светлая тема)</h5>
                <p>prefers-color-scheme читает системную тему пользователя.</p>
                <ul>
                  <li>light — пользователь предпочитает светлую тему.</li>
                  <li>dark — тёмную.</li>
                </ul>
                <p>
                  Пример: <br />
                  <br />

                  @media (prefers-color-scheme: dark) { <br />
                  body { <br />
                  background: #020617; <br />
                  color: #e5e7eb; <br />
                  } <br />
                  } <br />
                  <br />

                  @media (prefers-color-scheme: light) { <br />
                  body { <br />
                  background: #ffffff; <br />
                  color: #020617; <br />
                  } <br />
                  } <br />
                  Так можно автоматически подстраивать сайт под тёмную/светлую
                  тему ОС без переключателя.
                </p>
              </div>
            </div>
            <div>
              <h5>Резиновая верстка</h5>
              <p>
                Она, в свою очередь, основывается на использовании относительных
                единиц измерения, таких как %, rem, em и так далее, вместо
                фиксированных значений, для задания размеров элементов на
                странице. <br />
                Например, контейнер, с шириной 100%, который содержит текст и
                при изменении размеров окна браузера контейнер будет становится
                меньше. Ну или размер текста, который можно настроить таким
                образом, чтобы он зависел от размеров окна браузера. При верстке
                эти два подхода применяются совместно. <br />
              </p>
              <p>
                .container { <br />
                width: 100%; <br />
                } <br />
                .text { <br />
                font-size: 5vw; <br />
                }
              </p>
            </div>
            <div>
              <h5>Mobile first</h5>
              <p>
                Mobile first - это подход, при котором верстка сайта
                разрабатываются с учетом мобильных устройств, то есть верстка
                начинается с самой минимальной ширины, а потом увеличивается.
                <br />
                Разберем пример, для элемента title на мобильных устройствах,
                размер шрифта будет равен 16px, <br />
                дальше, когда ширина экрана будет больше или равна 640px, размер
                шрифта будет равен 18px <br />
                и когда ширина экрана будет больше или равна 1280px, размер
                шрифта будет равен 40px <br />
                Важно заметить в mobile first подходе, в условиях, используется
                свойство - минимальная ширина
              </p>
              <p>
                От меньшего к большему <br />
                .title{ <br />
                font-size: 16px; <br />
                } <br />
                ширина экрана >= 640px <br />
                @media (min-width: 640px) <br />
                .title{ <br />
                font-size: 18px; <br />
                } <br />
                } <br />
                ширина экрана >= 1280px <br />
                @media (min-width: 1280px) <br />
                .title{ <br />
                font-size: 40px; <br />
                } <br />
                }
              </p>
            </div>
            <div>
              <h5>Desktop first</h5>
              <p>
                Desktop first - это подход, при котором дизайн и верстка сайта
                разрабатываются с учетом десктопных компьютеров, то есть верстка
                начинается с самой максимальной ширины, а потом уменьшается.
                <br />
                Разберем пример, для элемента title на компьютерах размер шрифта
                будет равен 40px, <br />
                дальше, когда ширина экрана будет меньше или равна 1280px,
                размер шрифта будет равен 18px <br />
                и когда ширина экрана будет меньше или равна 640px, размер
                шрифта будет равен 16px <br />
                Важно заметить в Desktop first подходе, в условиях, используется
                свойство - максимальная ширина <br />
              </p>
              <p>
                От большего к меньшему <br />
                .title{ <br />
                font-size: 40px; <br />
                } <br />

                ширина экрана < 1280px <br />
                @media (max-width: 1279px) <br />
                .title{ <br />
                font-size: 18px; <br />
                } <br />
                } <br />
                ширина экрана < 640px <br />
                @media (max-width: 639px) <br />
                .title{ <br />
                font-size: 16px; <br />
                } <br />
                }
              </p>
            </div>
            <div>
              <h5>Breakpoint</h5>
              <p>
                Breakpoints - это настраиваемая ширина, которая определяет, как
                адаптивный макет ведет себя на разных устройствах или размерах
                области просмотра. <br />
                Самые популярные размеры, которые используются в адаптивной
                верстке, это <br />
                640,768,1024,1280,1536px <br />
                576,768,992,1200,1400px <br />
                и другие.
              </p>
              <p>
                Обсудим, как найти контентную область, то есть как создать
                контейнер и отцентрировать его. <br />
                Практически все сайты, которые вы посещаете, отцентрированы,
                значит, есть пустое пространство слева и справа <br />
                На данном изображении, в синей метке, вы видите размер в 1260px,
                то есть дизайнер, при создании дизайна, определяет основную
                область контента, еще правильный дизайнер, создает дизайн с
                помощью системы сеток, это розовые колонки, они помогают при
                верстке сайтов.
              </p>
              <img
                width="100%"
                src="images/centrovka.jpg"
                alt="Пример центрирования контента"
              />
              <p>
                И для того, чтоб отцентрировать контент, нужно использовать
                такие css свойства:
              </p>
              <ul>
                <li>задать максимальную ширину</li>
                <li>внутренние отступы - padding</li>
                <li>
                  внешние отступы - margin слева и справа задать на значение
                  auto
                </li>
              </ul>
              <p>
                Почему же 1292px? Потому что при верстке, нужно задавать
                безопасные отступы, например по 16px, а в мобильной версии,
                например по 10, <br />
                Иначе, при изменении размеров окна браузера, контент будет
                соприкасаться с окном браузера, по левую и правую сторону.
                <br />
                Нужно обязательно задавать минимальный отступ, иными словами -
                задавать пустое пространство. <br />
              </p>
              <p>
                .container { <br />
                max-width: 1292px; 1260 + 16 + 16 <br />
                padding-left: 16px; <br />
                padding-right: 16px; <br />
                width: 100%; <br />
                margin-right: auto; <br />
                margin-left: auto; <br />
                }
              </p>
            </div>
            <div>
              <h5>Контейнерные запросы</h5>
              <p>
                Контейнерные запросы позволяют применять стили к компоненту в
                зависимости от размера его родительского контейнера, а не от
                ширины всего экрана (как в обычных media‑запросах).
              </p>
              <h6>Что такое контейнерные запросы</h6>
              <p>Механика:</p>
              <ol>
                <li>
                  <p>
                    Сначала помечаем блок как «контейнер»: <br />

                    .card-list { <br />
                    container-type: inline-size; /* смотреть на ширину
                    контейнера */ <br />
                    container-name: cards; /* опциональное имя */ <br />
                    }
                  </p>
                </li>
                <li>
                  <p>
                    Потом внутри пишем @container (аналог @media, но не по
                    viewport, а по контейнеру): <br />
                    <br />

                    .card { <br />
                    padding: 16px; <br />
                    } <br />
                    <br />

                    @container cards (min-width: 600px) { <br />
                    .card { <br />
                    display: grid; <br />
                    grid-template-columns: 120px 1fr; <br />
                    gap: 16px; <br />
                    } <br />
                    }
                  </p>
                </li>
              </ol>
              <p>
                Если .card-list стала шире 600px, карточки сами перестраиваются
                в более сложный вид; если .card-list узкая (например, в
                сайдбаре) — карточки остаются компактными. Формально:
              </p>
              <ul>
                <li>
                  container-type: inline-size / size включает
                  «контейнер‑контекст», по которому можно делать запросы.
                </li>
                <li>
                  @container (min-width: 500px) { ... } — условие, завязанное на
                  размер контейнера, а не viewport.
                </li>
              </ul>
              <h5>Какую проблему они решают</h5>
              <p>
                Проблема обычных @media: Media‑запросы смотрят только на окно
                браузера, а не на то, куда именно вставлен компонент.
              </p>
              <p>Один и тот же компонент может быть:</p>
              <ul>
                <li>широкой карточкой в контенте;</li>
                <li>
                  узким виджетом в боковой колонке. <br />
                  При подходе только с @media он «подстраивается под экран в
                  целом», а не под реальную ширину своего блока, и ломается.
                </li>
              </ul>
              <p>Контейнерные запросы решают это:</p>
              <ul>
                <li>
                  Компонент делает свою адаптацию, глядя на свой контейнер, а не
                  глобальные breakpoints.
                </li>
                <li>
                  Можно сделать по‑настоящему переиспользуемые компоненты: один
                  и тот же блок карточки/меню/таблицы корректно ведёт себя в
                  разных местах макета (узкая колонка, широкая область, карточка
                  в сетке и т.д.).
                </li>
              </ul>
              <h6>Кратко для билета:</h6>
              <p>
                Контейнерные запросы (@container) — это «media‑запросы для
                элементов»: они применяют стили к дочерним элементам в
                зависимости от размеров их контейнера (container-type:
                inline-size/size). Они решают проблему классической адаптивной
                верстки, где @media смотрят только на ширину viewport, из‑за
                чего компонент не знает, в узком он блоке или в широком. С
                контейнерными запросами компоненты становятся по‑настоящему
                адаптивными и переиспользуемыми без жёсткой привязки к
                глобальным breakpoint’ам.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              18. Изображения. Рассказать про основные атрибуты, зачем указывать
              width - height, alt. Адаптивные изображения (srcset и sizes).
            </h4>
            <div>
              <h5>Основные атрибуты изображений</h5>
              <p>
                &lt;img src=&quot;photo.jpg&quot; alt=&quot;Описание
                изображения&quot; width=&quot;600&quot;
                height=&quot;400&quot;&gt;
              </p>
              <ul>
                <li>`src` — путь к файлу изображения.</li>
                <li>
                  `alt` — текстовое описание картинки:
                  <ul>
                    <li>читается скринридерами (доступность);</li>
                    <li>показывается, если картинка не загрузилась;</li>
                    <li>
                      используется поисковиками. <br />
                      Для декоративных картинок `alt=""`.
                    </li>
                  </ul>
                </li>
                <li>
                  `width` / `height` — исходные размеры изображения в пикселях.
                  Зачем указывать:
                  <ul>
                    <li>
                      браузер заранее резервирует нужное место под картинку и
                      **не дёргает верстку** при загрузке (меньше layout shift,
                      лучше Core Web Vitals);
                    </li>
                    <li>
                      пропорции сохраняются, даже если дальше картинка
                      масштабируется через CSS.
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>Адаптивные изображения: srcset и sizes</h5>
              <p>
                Задача: один тег `<img />`, но разные файлы для разных экранов и
                плотностей пикселей, чтобы не грузить лишние мегабайты.
              </p>
              <p>
                &lt;img <br />
                  src=&quot;elva-fairy-800w.jpg&quot;<br />
                  srcset=&quot;<br />    elva-fairy-320w.jpg 320w,<br />   
                elva-fairy-480w.jpg 480w,<br />
                elva-fairy-800w.jpg 800w<br />  &quot;<br />  sizes=&quot;<br /> 
                  (max-width: 320px) 280px,<br />
                (max-width: 480px) 440px,<br />    800px<br />  &quot;<br /> 
                alt=&quot;Elva dressed as a fairy&quot;<br />/&gt;
              </p>
            </div>
            <div>
              <h5>srcset</h5>
              <p>
                `srcset` — список вариантов изображений с их реальной шириной:
              </p>
              <ul>
                <li>формат: `имя-файла ширинаw`;</li>
                <li>
                  `w` — это «ширина в CSS‑пикселях», не `px` в CSS‑свойстве.
                </li>
              </ul>
              <p>
                Пример: <br />
                <br />
                srcset="small.jpg 300w, medium.jpg 600w, large.jpg 1200w" <br />
                `src` остаётся обязательным (fallback), `srcset` дополняет его,
                давая браузеру выбор.
              </p>
            </div>
            <div>
              <h5>sizes</h5>
              <p>
                `sizes` говорит браузеру: **какую ширину слот под изображение
                примерно будет занимать** при разных ширинах вьюпорта. <br />
                <br />
                Формат: список `&lt;media&gt; &lt;slot-width&gt;`, последняя
                запись — значение по умолчанию.
              </p>
              <p>
                sizes="(max-width: 600px) 100vw, <br />
                (max-width: 1200px) 50vw, <br />
                33vw"
              </p>
              <p>Читается так:</p>
              <ul>
                <li>
                  до 600px ширины экрана — изображение ≈ 100% ширины окна;
                </li>
                <li>от 600 до 1200 — ≈ 50vw;</li>
                <li>выше 1200 — ≈ 33vw.</li>
              </ul>
              <p>Алгоритм выбора браузером:</p>
              <ol>
                <li>Берёт текущую ширину viewport.</li>
                <li>
                  По `sizes` вычисляет ожидаемую ширину слота (например, `370px`
                  или `50vw`).
                </li>
                <li>
                  Умножает на плотность пикселей (DPR, например 2 для Retina).
                </li>
                <li>
                  Из `srcset` выбирает файл, чья `w` ближе всего к полученному
                  значению, но **не меньше**, чтобы не терять качество.
                </li>
              </ol>
            </div>
            <div>
              <h5>Пример более короткий из СФУ:</h5>
              <p>
                &lt;img<br />
                  src=&quot;/img/image.jpg&quot;<br />
                  srcset=&quot;/img/image1.jpg 370w,<br />
                          /img/image2.jpg 600w,<br />
                          /img/image3.jpg 1920w&quot;<br />
                  sizes=&quot;(max-width: 991px) 370px, 600px&quot;<br />
                  alt=&quot;Пример изображения&quot;<br />/&gt;
              </p>
              <ul>
                <li>при viewport ≤ 991px слот ≈ 370px;</li>
                <li>при viewport > 991px — 600px;</li>
                <li>
                  для Retina‑экрана браузер выберет более крупное изображение
                  (чтобы не выглядело мыльно).
                </li>
              </ul>
            </div>
            <div>
              <h5>decoding и минимальный набор атрибутов</h5>
              <p>Рекомендуемый минимальный набор:</p>
              <p>
                &lt;img<br />
                  decoding=&quot;async&quot;<br />
                  loading=&quot;lazy&quot;<br />
                  src=&quot;/img-1920.jpg&quot;<br />
                  srcset=&quot;<br />    /img-640.jpg 640w,<br />
                /img-920.jpg 920w,<br />
                /img-1280.jpg 1280w,<br />
                /img-1560.jpg 1560w<br />  &quot;<br />
                  sizes=&quot;50vw&quot;<br />
                  alt=&quot;Описание&quot;<br />/&gt;
              </p>
              <ul>
                <li>
                  `decoding="async"` — браузер может декодировать картинку
                  асинхронно, не блокируя рендер.
                </li>
                <li>
                  `loading="lazy"` — отложенная загрузка (можно упомянуть, но не
                  обязательно для билета).
                </li>
                <li>`sizes="50vw"` — слоту примерно половина ширины окна.</li>
              </ul>
            </div>
            <div>
              <h5>Адаптивные изображения в CSS: image-set</h5>
              <p>
                Для фоновых картинок (через `background-image`) есть похожая
                функция `image-set()`:
              </p>
              <p>
                .hero { <br />
                background-image: image-set( <br />
                "image1.jpg" 1x, <br />
                "image2.jpg" 2x, <br />
                "image3.webp" 3x type("image/webp") <br />
                ); <br />
                }
              </p>
              <ul>
                <li>
                  Браузер сам выбирает подходящее изображение по плотности
                  пикселей и поддержке формата (например, WebP).
                </li>
              </ul>
            </div>
            <div>
              <h5>Если сжать до формулировки для билета:</h5>
              <p>
                > Основные атрибуты: `src` — путь к картинке, `alt` — текстовое
                описание (доступность, SEO), `width`/`height` — исходный размер,
                чтобы браузер заранее зарезервировал место и не дёргал верстку.
                Адаптивные изображения делаются через `srcset` и `sizes`:
                `srcset` даёт браузеру список файлов с их шириной (`300w`,
                `600w`, `1200w`), `sizes` — описывает, какую ширину слот под
                изображение занимает при разных ширинах экрана. Браузер смотрит
                на viewport и плотность пикселей и сам выбирает самый подходящий
                вариант, не загружая лишние большие файлы. Для фоновых
                изображений похожую задачу решает функция `image-set()` в CSS.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              19. Ссылки в HTML: атрибуты href, target, rel (nofollow,
              noopener). Что такое якорные ссылки (#id) и как они работают.
              Безопасность ссылок (XSS).
            </h4>
            <p>
              Ссылка в HTML — это тег &lt;a&gt;, у которого через атрибуты
              управляется адрес, способ открытия и безопасность.
            </p>
            <div>
              <h5>href и target</h5>
              <p>
                &lt;a href=&quot;https://example.com&quot;
                target=&quot;_blank&quot;&gt;Открыть сайт&lt;/a&gt;
              </p>
              <ul>
                <li>`href` — адрес, куда ведёт ссылка (URL или `#якорь`).</li>
                <li>
                  `target` — где открыть:
                  <ul>
                    <li>`_self` — в этом же окне (по умолчанию);</li>
                    <li>`_blank` — в новой вкладке/окне;</li>
                    <li>реже `_parent`, `_top`.</li>
                  </ul>
                </li>
              </ul>
            </div>
            <div>
              <h5>rel: nofollow, noopener (и немного noreferrer)</h5>
              <p>
                Атрибут `rel` описывает отношение текущей страницы к целевой.
                Для билета важны:
              </p>
              <p>
                &lt;a<br />
                  href=&quot;https://external.com&quot;<br />
                  target=&quot;_blank&quot;<br />
                  rel=&quot;nofollow noopener noreferrer&quot;<br />>   Внешняя
                ссылка<br />
                &lt;/a&gt;
              </p>
              <ul>
                <li>
                  `rel="nofollow"` — рекомендует поисковикам **не передавать
                  SEO‑вес** по этой ссылке и не учитывать её как «доверенную
                  рекомендацию». Часто ставят на рекламные, пользовательские или
                  нежелательные внешние ссылки.
                </li>
                <li>
                  `rel="noopener"` — защита от reverse tabnabbing:
                  <ul>
                    <li>
                      при `target="_blank"` новая вкладка получает доступ к
                      `window.opener` и теоретически может изменить исходную
                      страницу (подменить URL, внедрить фишинг);
                    </li>
                    <li>
                      `noopener` запрещает доступ к `window.opener`, новая
                      вкладка живёт отдельно.
                    </li>
                  </ul>
                </li>
                <li>
                  `rel="noreferrer"` (можно упомянуть коротко) — дополнительно
                  скрывает заголовок `Referer`, целевой сайт не знает, откуда
                  пришёл пользователь.
                </li>
              </ul>
              <p>
                На практике безопасные внешние ссылки с `_blank` оформляют так:
                <br />
                <br />

                &lt;a href=&quot;https://example.com&quot;
                target=&quot;_blank&quot; rel=&quot;noopener
                noreferrer&quot;&gt;...&lt;/a&gt;
              </p>
            </div>
            <div>
              <h5>Якорные ссылки (#id)</h5>
              <p>
                Якорная ссылка ведёт **на определённое место на странице**, а не
                на новый URL.
              </p>
              <ol>
                <li>
                  Элементу присваивается `id`:
                  <p>&lt;h2 id=&quot;forms&quot;&gt;Формы&lt;/h2&gt;</p>
                </li>
                <li>
                  Ссылка ссылается на этот id через `#`:
                  <p>
                    &lt;a href=&quot;#forms&quot;&gt;Перейти к разделу
                    «Формы»&lt;/a&gt;
                  </p>
                </li>
              </ol>
              <p>При клике: <br /></p>
              <ul>
                <li>браузер скроллит до элемента с указанным `id`;</li>
                <li>в адресной строке появляется `#forms` (фрагмент URL).</li>
              </ul>
              <p>
                Якорь может вести и на другой документ:
                `href="/page.html#section-2"`.
              </p>
            </div>
            <div>
              <h5>Безопасность ссылок и XSS</h5>
              <p>
                XSS (cross‑site scripting) — когда злоумышленник добивается
                выполнения своего JavaScript‑кода в браузере пользователя.
                Ссылки тоже могут быть каналом атаки. <br />
                <br />
                Опасные моменты:
              </p>
              <ul>
                <li>
                  Динамическое подставление `href` из пользовательского ввода
                  без проверки:
                  <ul>
                    <li>
                      злоумышленник может подставить
                      `href="javascript:alert(1)"` или URL с вредоносным
                      скриптом;
                    </li>
                    <li>при клике такой код выполнится в контексте сайта.</li>
                  </ul>
                </li>
              </ul>
              <p>Основные меры:</p>
              <ul>
                <li>
                  Никогда не вставлять пользовательский ввод напрямую в `href`
                  без валидации и экранирования.
                </li>
                <li>
                  Разрешать только безопасные протоколы (`http`, `https`, при
                  необходимости `mailto`, `tel`), отфильтровывать `javascript:`,
                  `data:` и т.п. (часто через проверку `URL.protocol`).
                </li>
                <li>
                  Для внешних ссылок с `_blank` добавлять `rel="noopener"` (и по
                  желанию `noreferrer`) против tabnabbing.
                </li>
              </ul>
            </div>
            <div>
              <h5>Формулировка для билета:</h5>
              <p>
                > Якорные ссылки (`href="#id"`) ведут к элементу с заданным `id`
                на текущей странице. Для безопасности ссылок важно: не
                подставлять пользовательские данные в `href` без проверки
                (защита от XSS через `javascript:`‑URL) и при `target="_blank"`
                использовать `rel="noopener"`/`noreferrer`, чтобы новая вкладка
                не могла управлять исходной страницей и не получала лишнюю
                информацию.
              </p>
            </div>
          </div>

          <div class="exam--card">
            <h4>
              20. Как встраивать SVG в HTML. Преимущества SVG над растровыми
              изображениями. Анимация SVG с CSS.
            </h4>
            <div>
              <h5>SVG</h5>
              <p>
                SVG — это **векторная графика** в виде XML‑разметки, которая
                отлично подходит для иконок, логотипов и иллюстраций в вебе.
              </p>
            </div>
            <div>
              <h5>Преимущества SVG</h5>
              <ul>
                <li>
                  Масштабируется без потери качества на любых экранах и DPI
                  (всегда чёткий логотип/иконка).
                </li>
                <li>
                  Обычно маленький размер файла для простых форм и иконок
                  (меньше, чем PNG/JPEG для того же логотипа).
                </li>
                <li>
                  Текстовый формат: можно править в редакторе кода, хранить в
                  Git, генерировать.
                </li>
                <li>
                  Стилизуется через CSS (`fill`, `stroke`, `transform`) и
                  управляется JS, поддерживает анимацию.
                </li>
                <li>
                  Удобен для иконок, логотипов, диаграмм, карт, схем. Растровые
                  форматы лучше для сложных фотографий.
                </li>
              </ul>
            </div>
            <div>
              <h5>Как встраивать SVG в HTML</h5>
              <ol>
                <li>
                  **Встроенный (inline SVG)** — максимальный контроль (для
                  анимаций и стилей):
                  <p>
                    &lt;svg width=&quot;100&quot; height=&quot;100&quot;
                    viewBox=&quot;0 0 100 100&quot;
                    xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  
                    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot;
                    r=&quot;40&quot; fill=&quot;red&quot; /&gt; &lt;/svg&gt;
                  </p>
                  <div>
                    <svg
                      width="100"
                      height="100"
                      viewBox="0 0 100 100"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <circle cx="50" cy="50" r="40" fill="red" />
                    </svg>
                  </div>
                  <ul>
                    <li>
                      Доступен как обычный DOM — можно менять атрибуты CSS/JS.
                    </li>
                  </ul>
                </li>
                <li>
                  Через &lt;img&gt; (статика, кеширование):
                  <p>
                    &lt;img src=&quot;icon.svg&quot; alt=&quot;Логотип
                    компании&quot; width=&quot;120&quot;
                    height=&quot;120&quot;&gt;
                  </p>
                  <ul>
                    <li>
                      Просто как картинка, хорошо кешируется браузером, но
                      внутренние элементы нельзя анимировать/красить по CSS.
                    </li>
                  </ul>
                </li>
                <li>
                  Фоном в CSS:
                  <p>
                    .logo { <br />
                    background-image: url("icon.svg"); <br />
                    }
                  </p>
                </li>
                <li>
                  &lt;object&gt;/&lt;embed&gt; обычно для отдельных сложных
                  SVG‑документов, реже для иконок.
                </li>
              </ol>
            </div>
            <div>
              <h5>Базовая теория по &lt;svg&gt;</h5>
              <p>Главное, что нужно для билета:</p>
              <ul>
                <li>
                  <p>
                    &lt;svg&gt; — корневой контейнер, задаёт область рисования.
                    <br />
                    Важные атрибуты:
                  </p>
                  <ul>
                    <li>`width` / `height` — отображаемый размер;</li>
                    <li>
                      `viewBox="minX minY width height"` — внутренняя система
                      координат для масштабирования.
                    </li>
                  </ul>
                </li>
                <li>
                  Теги фигур (знать по названию и назначению):
                  <ul>
                    <li>&lt;rect&gt; — прямоугольник;</li>
                    <li>&lt;circle&gt; — круг;</li>
                    <li>&lt;ellipse&gt; — эллипс;</li>
                    <li>&lt;line&gt; — линия;</li>
                    <li>
                      &lt;polyline&gt; / &lt;polygon&gt; — ломаная /
                      многоугольник;
                    </li>
                    <li>
                      &lt;path&gt; — произвольный контур, самый универсальный.
                    </li>
                  </ul>
                </li>
              </ul>
              <p>Общие атрибуты оформления:</p>
              <ul>
                <li>fill — цвет заливки;</li>
                <li>stroke — цвет обводки;</li>
                <li>stroke-width — толщина контура.</li>
              </ul>
              <p>
                Этого набора достаточно, чтобы объяснить, что SVG — именно язык
                разметки, а не просто картинка.
              </p>
            </div>
            <div>
              <h5>Анимация SVG с помощью CSS</h5>
              <p>
                Чтобы анимировать SVG через CSS, его обычно **встраивают
                инлайном**, чтобы элементы были в DOM. <br />
                <br />
                Пример простой анимации круга:
              </p>
              <p>
                &lt;svg width=&quot;100&quot; height=&quot;100&quot;
                viewBox=&quot;0 0 100 100&quot;&gt;   &lt;circle    
                class=&quot;pulse&quot;     cx=&quot;50&quot;    
                cy=&quot;50&quot;     r=&quot;40&quot;     fill=&quot;red&quot;
                  /&gt; &lt;/svg&gt;
              </p>
              <div>
                <svg width="100" height="100" viewBox="0 0 100 100">
                  <circle class="pulse" cx="50" cy="50" r="40" fill="red" />
                </svg>
              </div>
              <p>
                .pulse { <br />
                animation: pulse 2s infinite; <br />
                } <br />
                <br />
                @keyframes pulse { <br />
                0% { r: 40; } <br />
                50% { r: 50; } <br />
                100% { r: 40; } <br />
                }
              </p>
              <ul>
                <li>
                  Анимируются SVG‑атрибуты (`r`, `stroke-dashoffset`,
                  `transform` и т.п.) как обычные анимируемые свойства.
                </li>
              </ul>
              <p>
                Частый паттерн — эффект «рисования» линий для `path` через
                `stroke-dasharray` и `stroke-dashoffset`:
              </p>
              <p>
                .path { <br />
                stroke-dasharray: 300; <br />
                stroke-dashoffset: 300; <br />
                animation: draw 2s linear forwards; <br />
                } <br />
                <br />
                @keyframes draw { <br />
                to { stroke-dashoffset: 0; } <br />
                }
              </p>
              <p>Можно также:</p>
              <ul>
                <li>добавлять hover‑эффекты (смена `fill`, `stroke`);</li>
                <li>
                  комбинировать с трансформациями (`transform: rotate`, `scale`)
                  прямо на SVG‑элементах.
                </li>
              </ul>
            </div>
            <div>
              <h5>Краткая формулировка для билета:</h5>
              <p>
                > SVG — это векторная XML‑графика, которая масштабируется без
                потери качества и хорошо подходит для иконок и логотипов.
                Встраивать SVG можно инлайном (&lt;svg&gt;...&lt;/svg&gt; — даёт
                доступ к отдельным элементам для CSS/JS), как обычную картинку в
                &lt;img src="icon.svg" /&gt; или фоном через `background-image`.
                SVG легко анимировать CSS: например, инлайн‑SVG позволяет менять
                радиус круга, цвет заливки, параметры обводки, а для линий часто
                анимируют `stroke-dasharray`/`stroke-dashoffset`, создавая
                эффект «рисования» контура.
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="section js">
      <h3>Вопросы по JS</h3>
      <div class="exam--card">
        <h4>
          1. Function Declaration - Function Expression. Стрелочные функции.
        </h4>
        <div class="subtopic">
          <h5>Function Declaration</h5>
          <p>
            это объявление функции отдельной инструкцией `function`, её можно
            вызывать до и после места объявления из того же блока, потому что
            она поднимается (hoisting).
          </p>
          <p>
            Синтаксис: <br />
            <br />

            function sum(a, b) { <br />
            return a + b; <br />
            } <br />
            console.log(sum(2, 3)); // 5
          </p>
          <ul>
            <li>Всегда есть имя функции.</li>
            <li>
              Декларации обрабатываются до исполнения кода, поэтому `sum()`
              можно вызвать выше по файлу.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h5>Function Expression</h5>
          <p>
            это когда функция создаётся как значение в выражении и, например,
            присваивается в переменную. Работает как обычное значение; функцию
            можно передавать, хранить в массиве и т.д. Вызывать можно только
            после строки, где она создана.
          </p>
          <p>
            Синтаксис: <br />
            <br />

            const sum = function (a, b) { <br />
            return a + b; <br />
            };<br />

            console.log(sum(2, 3)); // 5
          </p>
          <p>Ключевые моменты для ответа:</p>
          <ul>
            <li>Функция становится значением переменной `sum`.</li>
            <li>
              Не поднимается как декларация: если вызвать `sum()` до этой
              строки, будет ошибка.
            </li>
            <li>
              <p>
                Бывает анонимной (без имени) и именованной (редко нужно):
                <br /><br />
                const sum = function sumImpl(a, b) { <br />
                return a + b;<br />
                };
              </p>
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h5>Стрелочные функции</h5>
          <p>
            это укороченный синтаксис function expression, всегда выражение,
            пишется через `=>`, часто используется как коллбэк (в `map`,
            `filter`, обработчиках событий). У стрелочных функций нет своего
            `this`, `arguments`, `new`, они берут `this` снаружи.
          </p>
          <p>
            Синтаксис: <br /><br />

            Обычный вариант: <br />
            <br />

            const sum = (a, b) => { <br />
            return a + b;<br />
            };
          </p>
          <p>
            Короткая запись (одно выражение → не нужны `return` и фигурные
            скобки): <br /><br />

            const sum = (a, b) => a + b;
          </p>
          <p>
            Если один параметр, скобки можно опустить: <br /><br />

            const square = x => x * x;<br /><br />

            Если нет параметров: <br /><br />

            const sayHi = () => console.log("Hi");
          </p>
        </div>
        <div class="subtopic">
          <h4>Что важно подчеркнуть на экзамене</h4>
          <ol>
            <li>
              Function Declaration
              <ul>
                <li>Объявляется как `function name(...) { ... }`.</li>
                <li>Поднимается (hoisting): доступна до места объявления.</li>
              </ul>
            </li>
            <li>
              Function Expression
              <ul>
                <li>
                  Функция создаётся внутри выражения, чаще всего присваивается в
                  переменную: `const f = function(...) {}`.
                </li>
                <li>
                  Не поднимается как декларация: её можно вызывать только после
                  строки объявления.
                </li>
              </ul>
            </li>
            <li>
              Стрелочные функции
              <ul>
                <li>
                  Это всегда function expression: `const f = (...) => { ... }`.
                </li>
                <li>Более короткий синтаксис, удобно для коллбэков.</li>
                <li>
                  Нет собственного `this` и `arguments`, они берутся из внешнего
                  окружения. Это важно для работы в методах и коллбэках
                  (например, в `setTimeout`).
                </li>
              </ul>
            </li>
          </ol>
        </div>
      </div>
      <div class="exam--card">
        <h4>
          2. Функция высшего порядка. Чистая функция. Побочный эффект. Колбэки.
          Замыкание.
        </h4>
        <div class="subtopic">
          <h5>Функция высшего порядка (Higher-order function)</h5>
          <p>
            Определение: функция высшего порядка — это функция, которая либо
            принимает другую функцию как аргумент, либо возвращает функцию как
            результат (или и то, и другое).
          </p>
          <p>Пример 1 — принимает функцию (колбэк): <br /><br /></p>
          <p class="code--block" data-lang="JS">
            function repeat(times, callback) { <br />
            for (let i = 0; i < times; i++) { <br />
            callback(i); <br />
            } <br />
            } <br />
            <br />

            repeat(3, (i) => { <br />
            console.log(`Итерация ${i}`); <br />
            });
          </p>
          <p>
            `repeat` — функция высшего порядка, потому что принимает другую
            функцию `callback`.
          </p>
          <p>
            Пример 2 — возвращает функцию: <br />
            <br />
          </p>
          <p class="code--block" data-lang="JS">
            function makeMultiplier(k) { <br />
            return function (x) { <br />
            return x * k; <br />
            }; <br />
            } <br />

            const double = makeMultiplier(2); <br />
            console.log(double(5)); // 10 <br />
          </p>
          <p>
            `makeMultiplier` — функция высшего порядка, возвращающая другую
            функцию.
          </p>
        </div>
        <div class="subtopic">
          <h5>Чистая функция (Pure function)</h5>
          <p>Определение: чистая функция — это функция, которая:</p>
          <ol>
            <li>
              при одних и тех же входных данных всегда возвращает один и тот же
              результат;
            </li>
            <li>
              не имеет побочных эффектов (не меняет внешние данные, не лезет в
              DOM, сеть, консоль и т.д.).
            </li>
          </ol>
          <p>
            Пример чистой функции: <br />
            <br />

            function sum(a, b) { <br />
            return a + b; <br />
            }
          </p>
          <ul>
            <li>Всегда `sum(2, 3) === 5`.</li>
            <li>Ничего вне себя не трогает.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h5>Нечистая функция (антипример):</h5>
          <p>
            let count = 0; <br />
            <br />

            function increment() { <br />
            count++; // меняет внешнюю переменную → побочный эффект <br />
            console.log(count); // вывод в консоль → тоже побочный эффект <br />
            }
          </p>
        </div>
        <div class="subtopic">
          <h5>Побочный эффект (Side effect)</h5>
          <p>
            Определение: побочный эффект — это любое изменение вне локальной
            области функции или взаимодействие с внешним миром: изменение
            глобальных переменных, аргументов по ссылке, DOM, запросы к серверу,
            логирование, рандом, работа с временем и т.д.
          </p>
          <p>Примеры побочных эффектов:</p>
          <p class="code--block" data-lang="JS">
            let state = 0; <br />
            function bad(x) { <br />
            state = x; // мутируем внешнее состояние <br />
            document.body.textContent = x; // меняем DOM <br />
            console.log('done'); // выводим в консоль <br />
            } <br />
          </p>
          <p>Все эти действия делают функцию нечистой.</p>
        </div>
        <div class="subtopic">
          <h5>Колбэк (Callback)</h5>
          <p>
            Определение: колбэк — это функция, которую передают в другую функцию
            как аргумент, чтобы та вызвала её позже (как «обратный вызов»).
          </p>
          <p>Пример с `setTimeout`:</p>
          <p class="code--block" data-lang="JS">
            setTimeout(() => { <br />
            console.log('Прошло 1 секунда'); <br />
            }, 1000); <br />
          </p>
          <p>
            Анонимная стрелочная функция `() => { ... }` здесь — колбэк, который
            `setTimeout` вызовет спустя 1000 мс.
          </p>
          <p>Пример с массивом: <br /></p>
          <p class="code--block" data-lang="JS">
            const arr = [1, 2, 3]; <br />
            const doubled = arr.map(x => x * 2); // x => x * 2 — колбэк <br />
          </p>
          <p>`map` — функция высшего порядка, `x => x * 2` — колбэк.</p>
        </div>
        <div class="subtopic">
          <h5>Замыкание (Closure)</h5>
          <p>
            Замыкание — это функция, которая запоминает переменные из внешней
            (родительской) области видимости и может использовать их даже после
            того, как внешняя функция завершила выполнение.
          </p>
          <p>
            Классический пример: <br />
            <br />

            function makeCounter() { <br />
            let count = 0; <br />
            <br />

            return function () { <br />
            count++; <br />
            return count; <br />
            }; <br />
            } <br />
            <br />

            const counter = makeCounter(); <br />

            console.log(counter()); // 1 <br />
            console.log(counter()); // 2 <br />
            console.log(counter()); // 3
          </p>
          <ul>
            <li>
              makeCounter вызвали один раз, она вернула внутреннюю функцию.
            </li>
            <li>
              Внутренняя функция «замыкает» переменную `count` и продолжает к
              ней иметь доступ.
            </li>
          </ul>
          <p>
            Ещё короткий пример с параметром: <br />
            <br />

            function makeAdder(a) { <br />
            return function (b) { <br />
            return a + b; <br />
            }; <br />
            } <br />
            <br />

            const add5 = makeAdder(5); <br />
            console.log(add5(10)); // 15 <br />
            <br />

            Внутренняя функция помнит `a` из внешней.
          </p>
        </div>
        <div class="subtopic">
          <h5>Кратко</h5>
          <ul>
            <li>
              Функция высшего порядка — это функция, которая принимает или
              возвращает другую функцию, например `map`, `filter`, или своя
              `repeat(callback)`.
            </li>
            <li>
              Чистая функция — всегда даёт один и тот же результат при
              одинаковых аргументах и не имеет побочных эффектов, то есть не
              меняет ничего вне себя.
            </li>
            <li>
              Побочный эффект — это любое изменение внешнего состояния:
              изменение глобальной переменной, изменение DOM, лог в консоль,
              запрос к серверу и т.д.
            </li>
            <li>
              Колбэк — функция, которую передают в другую функцию как аргумент,
              чтобы вызвать позже, например в `setTimeout` или `array.map`.
            </li>
            <li>
              Замыкание — это функция, которая запоминает переменные из внешней
              области видимости и может использовать их после завершения внешней
              функции; пример — `makeCounter` с внутренней функцией, которая
              увеличивает `count`.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>3. Способы создания объектов.</h3>
        <div class="subtopic">
          <h4>Литерал объекта</h4>
          <p>
            Определение: самый простой и популярный способ создания объекта —
            через фигурные скобки с парами «ключ: значение».
          </p>
          <p>
            const user = { <br />
            name: "Костя", <br />
            age: 20 <br />
            }; <br />
            <br />
            const empty = {};
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              Это основной способ создания обычных объектов в современном JS.
            </li>
            <li>Удобен для конфигов, данных, простых сущностей.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Конструктор `Object` и `new Object()`</h4>
          <p>
            Определение: создание объекта через встроенный конструктор `Object`.
            Сейчас используется редко, больше для теории.
          </p>
          <p>
            const user = new Object(); <br />
            user.name = "Костя"; <br />
            user.age = 20; <br />
            <br />

            или: <br />
            <br />

            const user = new Object({ name: "Костя", age: 20 });
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>Работает, но проще и короче `{}`.</li>
            <li>На экзамене достаточно упомянуть как один из способов.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Функция‑конструктор + `new`</h4>
          <p>
            Определение: функция, которая используется как «шаблон» для создания
            однотипных объектов. Вызывается с `new`.
          </p>
          <p>
            function User(name, age) { <br />
            this.name = name; <br />
            this.age = age; <br />
            } <br />
            <br />

            const user1 = new User("Костя", 20); <br />
            const user2 = new User("Аня", 25);
          </p>
          <p>Что важно сказать:</p>
          <ul>
            <li>Имя конструктора обычно с заглавной буквы.</li>
            <li>
              `new User(...)` создаёт новый объект, привязывает `this` и
              возвращает его.
            </li>
            <li>
              Раньше это был основной способ «классовоподобных» объектов до
              появления `class`.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>`class` (синтаксический сахар над прототипами)</h4>
          <p>
            Определение: ES6‑синтаксис для описания «класса» — более привычный
            для тех, кто из C#/Java. Внутри всё равно используется прототипное
            наследование.
          </p>
          <p>
            class User { <br />
            constructor(name, age) { <br />
            this.name = name; <br />
            this.age = age; <br />
            } <br />
            <br />

            sayHi() { <br />
            console.log(`Привет, я ${this.name}`); <br />
            } <br />
            } <br />
            <br />

            const user1 = new User("Костя", 20); <br />
            user1.sayHi(); // Привет, я Костя
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              `class` — удобный синтаксис для работы с объектами и
              наследованием.
            </li>
            <li>
              Используется вместе с `new` так же, как функция‑конструктор.
            </li>
            <li>В современном коде предпочтительнее конструкторных функций.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Object.create(proto)</h4>
          <p>
            Определение: создаёт объект с указанным прототипом. Полезно, когда
            нужно явно задать прототип или создать объект без прототипа.
          </p>
          <p>
            const personProto = { <br />
            sayHi() { <br />
            console.log(`Привет, я ${this.name}`); <br />
            } <br />
            }; <br />
            <br />

            const user = Object.create(personProto); <br />
            user.name = "Костя"; <br />
            user.sayHi(); // Привет, я Костя
          </p>
          <p>Что сказать:</p>
          <ul>
            <li>
              `Object.create(proto)` создаёт объект, у которого в качестве
              прототипа используется `proto`.
            </li>
            <li>
              Удобен для ручной работы с прототипами и «чистым» прототипным
              наследованием.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Кратко, как говорить на экзамене</h4>
          <ol>
            <li>
              литерал объекта `{}` — самый простой и часто используемый способ;
            </li>
            <li>
              через конструктор `Object` — `new Object()`, сейчас почти не
              используется;
            </li>
            <li>
              через функцию‑конструктор с `new`, например `function User(...) {
              this... }`, `new User(...)`;
            </li>
            <li>
              через класс `class User { constructor(){...} }`, который внутри
              всё равно работает через прототипы;
            </li>
            <li>
              с помощью `Object.create(proto)`, когда нужно явно задать прототип
              для нового объекта.
            </li>
          </ol>
        </div>
      </div>

      <div class="exam--card">
        <h3>4. Способы клонирования объектов.</h3>
        <div class="subtopic">
          <h4>Поверхностное копирование (shallow copy)</h4>
          <p>
            Копируются только верхнеуровневые свойства; вложенные объекты и
            массивы остаются теми же ссылками.
          </p>
          <ol>
            <li>
              <h5>Оператор распространения (spread ...)</h5>
              <p>
                const user = { name: "Костя", info: { age: 20 } }; <br />
                <br />

                const copy = { ...user }; // поверхностная копия <br />
                <br />

                copy.name = "Петя"; // не влияет на user.name <br />
                copy.info.age = 30; // изменит и user.info.age тоже! <br />
                Создаётся новый объект, но вложенные объекты/массивы общие.
                <br />
                <br />

                Самый популярный способ сделать «копию на один уровень».
              </p>
            </li>
            <li>
              <h5>Object.assign</h5>
              <p>
                const user = { name: "Костя", info: { age: 20 } }; <br />
                <br />

                const copy = Object.assign({}, user); // поверхностная копия
                <br />
                <br />

                copy.info.age = 30; // затронет и оригинал <br />
                Работает аналогично spread: копирует только верхний уровень.
                <br />
                <br />

                Разница: Object.assign может дописывать в существующий объект.
              </p>
            </li>
          </ol>
        </div>
        <div class="subtopic">
          <h4>Глубокое копирование (deep copy)</h4>
          <p>
            Глубокая копия — когда всё дерево объекта копируется, и вложенные
            объекты/массивы не делят ссылки с оригиналом.
          </p>
          <ol>
            <li>
              <h5>structuredClone (современный стандарт)</h5>
              <p>
                const original = { <br />
                x: 1, <br />
                nested: { y: 2 }, <br />
                arr: [1, 2, 3] <br />
                }; <br />
                <br />

                const clone = structuredClone(original); <br />
                <br />

                clone.nested.y = 999; <br />
                clone.arr[0] = 100; <br />
                <br />

                console.log(original.nested.y); // 2 — оригинал не изменился
                <br />
              </p>
              <ul>
                <li>
                  Делает глубокую копию, поддерживает сложные типы: объекты,
                  массивы, Map, Set, Date и т.д.
                </li>
                <li>
                  Сейчас это рекомендуемый способ для deep copy в современных
                  браузерах и Node.
                </li>
              </ul>
            </li>
            <li>
              <h5>
                JSON.parse(JSON.stringify(obj)) (старый, но популярный хак)
              </h5>
              <p>
                const original = { x: 1, nested: { y: 2 } }; <br />
                <br />

                const clone = JSON.parse(JSON.stringify(original)); <br />
                <br />

                clone.nested.y = 999; <br />
                console.log(original.nested.y); // 2
              </p>
              <p>Минусы:</p>
              <ul>
                <li>
                  Теряются функции, undefined, Symbol, Date превращается в
                  строку.
                </li>
                <li>Не работает с циклическими ссылками.</li>
              </ul>
            </li>
            <p>
              Используется как простой deep copy для «чистых» данных (без
              функций и специальных типов).
            </p>
          </ol>
        </div>
        <div class="subtopic">
          <h4>Краткий ответ:</h4>
          <ul>
            <li>
              Есть поверхностное копирование (копируются только верхнеуровневые
              свойства, вложенные объекты остаются по ссылке) и глубокое
              копирование (полностью независимая копия структуры).
            </li>
            <li>
              Для поверхностного копирования объектов используют:

              <ul>
                <li>оператор spread: const copy = { ...obj };</li>
                <li>Object.assign({}, obj).</li>
              </ul>
            </li>
            <li>
              Для глубокого копирования:

              <ul>
                <li>
                  современный стандарт — structuredClone(obj), который делает
                  полноценную глубокую копию и работает с многими типами;
                </li>
                <li>
                  более старый подход — JSON.parse(JSON.stringify(obj)), но он
                  теряет функции и спецтипы.
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          5. Что такое this. Правила определения this. Рассказать про bind,
          call, apply.
        </h3>
        <div class="subtopic">
          <h4>this</h4>
          <p>
            this — это ссылка на контекст выполнения функции, то есть на тот
            объект, «от имени которого» функция вызвана.
          </p>
          <p>
            Примеры: <br />
            <br />

            const user = { <br />
            name: "Костя", <br />
            sayHi() { <br />
            console.log(this.name); <br />
            } <br />
            }; <br />
            <br />

            user.sayHi(); // this === user, выведет "Костя"
          </p>
          <ul>
            <li>В методах объекта this обычно указывает на сам объект.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Основные правила определения this</h4>
          <ol>
            <li>
              <h5>Глобальный контекст</h5>
              <p>
                В браузере снаружи функций: <br />
                <br />

                console.log(this === window); // true в браузере <br />
                Здесь this — глобальный объект (window / globalThis).
              </p>
            </li>
            <li>
              <h5>Обычный вызов функции</h5>
              <p>
                function show() { <br />
                console.log(this); <br />
                } <br />
                show();
              </p>
              <ul>
                <li>
                  В нестрогом режиме this внутри такой функции будет глобальным
                  объектом (window).
                </li>
                <li>В строгом режиме ('use strict') this будет undefined.</li>
              </ul>
            </li>
            <li>
              <h5>Вызов как метод объекта</h5>
              <p>
                const user = { <br />
                name: "Костя", <br />
                sayHi() { <br />
                console.log(this.name); <br />
                } <br />
                }; <br />
                <br />

                user.sayHi(); // this === user
              </p>
              <p>this указывает на объект перед точкой — user.</p>
            </li>
            <li>
              <h5>Конструктор с new</h5>
              <p>
                function User(name) { <br />
                this.name = name; <br />
                } <br />
                <br />

                const u = new User("Костя");
              </p>
              <p></p>
            </li>
            <p>При вызове с new:</p>
            <ul>
              <li>создаётся новый объект;</li>
              <li>this внутри конструктора указывает на этот новый объект;</li>
              <li>если явно не вернуть другой объект, возвращается this.</li>
            </ul>
            <li>
              <h5>Явное связывание: call / apply / bind</h5>
              <p>
                this можно принудительно задать с помощью call, apply, bind
                (ниже).
              </p>
            </li>
            <li>
              <h5>Стрелочные функции</h5>
              <p>
                Стрелочные функции не имеют своего this. <br /><br />

                const obj = { <br />
                name: "Костя", <br />
                sayHi: () => { <br />
                console.log(this.name); <br />
                } <br />
                }; <br />
                <br />

                obj.sayHi(); // this здесь НЕ obj, а внешнее окружение
              </p>
              <p>
                this внутри стрелочной берётся из внешней области (лексически),
                поэтому стрелки не подходят как методы, если нужен this к
                объекту.
              </p>
            </li>
          </ol>
        </div>
        ​
        <div class="subtopic">
          <h4>call, apply, bind</h4>
          <p>Все три метода нужны, чтобы задать this для функции.</p>
          <p>Возьмём базовую функцию:</p>
          <p>
            function greet(greeting, punctuation) { <br />
            console.log(greeting + ", " + this.name + punctuation); <br />
            } <br />
            <br />

            const user = { name: "Костя" };
          </p>
          <div>
            <h4>call</h4>
            <p>
              Вызывает функцию сразу, задавая this и передавая аргументы по
              одному. <br />
              <br />

              greet.call(user, "Привет", "!"); <br />
              // this === user → "Привет, Костя!" <br />
              Сигнатура: func.call(thisArg, arg1, arg2, ...).
            </p>
          </div>
          <div>
            <h4>apply</h4>
            <p>
              Тоже вызывает функцию сразу, но аргументы принимает массивом.
              <br />
              <br />

              greet.apply(user, ["Здравствуйте", "!!!"]); <br />
              // this === user → "Здравствуйте, Костя!!!"
            </p>
            <ul>
              <li>Сигнатура: func.apply(thisArg, [arg1, arg2, ...]).</li>
              <li>Удобно, когда аргументы уже лежат в массиве.</li>
            </ul>
          </div>
          <div>
            <h4>bind</h4>
            <p>
              Не вызывает функцию сразу, а возвращает новую функцию с жёстко
              привязанным this и (опционально) частично подставленными
              аргументами. <br />
              <br />

              const greetKostya = greet.bind(user, "Привет"); <br />
              <br />

              greetKostya("!"); // "Привет, Костя!" <br />
              greetKostya("!!!"); // "Привет, Костя!!!" <br />
            </p>
            <ul>
              <li>Сигнатура: func.bind(thisArg, arg1, arg2, ...).</li>
              <li>Возвращает новую функцию, которую можно вызывать позже.</li>
            </ul>
            <p>
              Типичный пример с потерей this: <br />
              <br />

              const user = { <br />
              name: "Костя", <br />
              sayHi() { <br />
              console.log(this.name); <br />
              } <br />
              }; <br />
              <br />

              const hi = user.sayHi; <br />
              hi(); // this потерян, в строгом режиме undefined <br />
              <br />

              const hiBound = user.sayHi.bind(user); <br />
              hiBound(); // "Костя"
            </p>
          </div>
        </div>
        <div class="subtopic">
          <h4>Кратко</h4>
          <ul>
            <li>
              this — это контекст выполнения функции, объект, от имени которого
              она вызвана. В методах объекта this ссылается на этот объект, при
              new — на создаваемый объект, в глобальной функции — на глобальный
              объект или undefined в strict.
            </li>
            <li>
              В стрелочных функциях нет своего this, он берётся из внешней
              области.
            </li>
            <li>
              call и apply вызывают функцию сразу с указанным this; разница —
              call принимает аргументы по одному, apply — массивом.
            </li>
            <li>
              bind не вызывает функцию, а возвращает новую функцию с привязанным
              this и, при желании, частью аргументов.
            </li>
          </ul>
        </div>
      </div>
      <div class="exam--card">
        <h3>
          6. Что такое DOM? DOM-коллекции. Навигация и поиск. Что такое BOM.
          Location, Cookie, Web Storage.
        </h3>
        <div class="subtopic">
          <h4>DOM</h4>
          <p>
            DOM (Document Object Model) — это объектное представление
            HTML-документа в виде дерева узлов, к которому JS получает доступ,
            чтобы читать и менять структуру, содержимое и стили страницы.
          </p>
          <ul>
            <li>
              Каждый тег становится узлом (node) и элементом (element) в дереве.
            </li>
            <li>
              Через DOM можно создавать, удалять, перемещать элементы, менять
              текст, атрибуты и вешать обработчики событий.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>DOM-коллекции, навигация и поиск</h4>
          <p>
            Поиск элементов <br />
            Основные методы:
          </p>
          <ul>
            <li>document.getElementById(id) – один элемент по id.</li>
            <li>
              document.getElementsByClassName(class) – HTMLCollection элементов
              по классу.
            </li>
            <li>
              document.getElementsByTagName(tag) – HTMLCollection по тегу.
            </li>
            <li>
              document.querySelector(selector) – первый элемент по
              CSS‑селектору.
            </li>
            <li>
              document.querySelectorAll(selector) – NodeList всех подходящих
              элементов.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>DOM-коллекции</h4>
          <ul>
            <li>
              HTMLCollection – «живое» (live) коллекция: меняется при изменении
              DOM, возвращается getElementsByClassName, getElementsByTagName.
            </li>
            <li>
              NodeList – «неживое» (statическое) чаще всего; возвращается
              querySelectorAll. Можно перебирать через for...of, forEach.
            </li>
          </ul>
          <p>Они похожи на массив, но это не полноценный Array.</p>
          <div>
            <h5>Навигация по DOM-дереву</h5>
            <p>Основные свойства навигации:</p>
            <ul>
              <li>Родитель: node.parentNode, node.parentElement.</li>
              <li>
                Дети: node.childNodes (все узлы), node.children (только
                элементы), node.firstChild, node.firstElementChild,
                node.lastElementChild.
              </li>
              <li>
                Соседи: node.previousElementSibling, node.nextElementSibling.
              </li>
            </ul>
            <p>Через эти ссылки можно ходить по дереву от любого узла.</p>
          </div>
          <img src="images/DOMTree.jpg" alt="DOM-дерево" />
        </div>
        <div class="subtopic">
          <h4>BOM</h4>
          <p>
            BOM (Browser Object Model) — это объектная модель браузера, набор
            объектов вокруг window, которые описывают сам браузер и вкладку, а
            не сам документ.
          </p>
          <ul>
            <li>
              Главный объект — window: в нём лежат document, location,
              navigator, history, localStorage, sessionStorage и т.д.
            </li>
            <li>
              DOM — это window.document, BOM — всё остальное, связанное с
              окном/вкладкой (адрес, история, размер окна, навигатор, хранение
              данных).
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Location</h4>
          <p>
            location — объект, который описывает адрес текущей страницы (URL) и
            позволяет его менять/перезагружать.
          </p>
          <p>Основные свойства/методы:</p>
          <ul>
            <li>
              location.href – полный URL; можно читать и изменять
              (перенаправление).
            </li>
            <li>
              location.protocol, hostname, pathname, search, hash – части URL.
            </li>
            <li>location.reload() – перезагрузить страницу.</li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Cookie</h4>
          <p>
            Cookies — маленькие текстовые данные (пары ключ‑значение), которые
            браузер хранит обычно пер‑сайт и автоматически отправляет на сервер
            с HTTP‑запросами.
          </p>
          <ul>
            <li>
              В JS доступ через document.cookie (строка; установка через
              присваивание).
            </li>
            <li>
              Обычно используются для сессий, авторизации, настроек
              пользователя.
            </li>
            <li>
              Имеют ограничения по размеру и количеству, сроки жизни и флаги
              (expires, path, secure, httpOnly и т.д. — для понимания достаточно
              упомянуть, что есть срок жизни и настройки безопасности).
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Web Storage: localStorage и sessionStorage</h4>
          <p>
            Web Storage — современный API для хранения данных в браузере в виде
            пары ключ → строка.
          </p>
          <p>localStorage</p>
          <ul>
            <li>
              Данные переживают закрытие вкладки и браузера, пока явно не
              очищены.
            </li>
            <li>
              Объём хранения больше, чем у cookies, и данные не отправляются на
              сервер каждые запросом.
            </li>
          </ul>
          <p>Основные методы:</p>
          <p class="code--block" data-lang="JS">
            localStorage.setItem("key", "value"); localStorage.getItem("key");
            // вернёт строку или null localStorage.removeItem("key");
            localStorage.clear(); localStorage.length; // количество записей
          </p>
        </div>
        <div class="subtopic">
          <h4>sessionStorage</h4>
          <ul>
            <li>
              Работает так же, как localStorage, но данные живут только в рамках
              одной вкладки/сессии.
            </li>
            <li>При закрытии вкладки/session — всё очищается.</li>
          </ul>
          <p>
            Использование аналогично:
            sessionStorage.setItem/getItem/removeItem/clear.
          </p>
        </div>
        <div class="subtopic">
          <h4>Кратко</h4>
          <ul>
            <li>
              DOM — это объектная модель документа, дерево узлов, через которое
              JS управляет HTML‑страницей: ищет элементы (getElementById,
              querySelector), ходит по дереву (parentNode, children) и работает
              с DOM‑коллекциями (HTMLCollection, NodeList).
            </li>
            <li>
              BOM — это объектная модель браузера: объект window и связанные с
              ним объекты вроде location, history, navigator, localStorage.
            </li>
            <li>
              location описывает текущий URL и позволяет управлять переходами и
              перезагрузкой.
            </li>
            <li>
              document.cookie — старый механизм хранения маленьких данных,
              которые также отправляются на сервер.
            </li>
            <li>
              Web Storage (localStorage, sessionStorage) — современный способ
              хранить ключ‑значение в браузере: localStorage — постоянно,
              sessionStorage — до закрытия вкладки.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          7. События - всплытие и погружение. Как к элементу прикрепить
          обработчик события click. Что такое event.target и
          event.currentTarget, отличия. Делегирование событий.
        </h3>
        <div class="subtopic">
          <h4>Всплытие и погружение</h4>
          <p>
            Событие в DOM проходит две основные фазы: погружение (capturing) и
            всплытие (bubbling). <br />
            <br />
            Представь структуру:
          </p>
          <p class="code--block" data-lang="HTML">
            &lt;div id=&quot;outer&quot;&gt; <br />
            &nbsp;&nbsp;&lt;button id=&quot;inner&quot;&gt;Кликни&lt;/button&gt;
            <br />
            &lt;/div&gt;
          </p>
          <p>Когда пользователь кликает по #inner:</p>
          <ol>
            <li>
              Погружение (capturing): событие идёт сверху вниз: document → html
              → body → outer → inner.
            </li>
            <li>Цель (target): событие достигает сам элемент inner.</li>
            <li>
              Всплытие (bubbling): поднимается снизу вверх: inner → outer → body
              → html → document.
            </li>
          </ol>
          <p>
            По умолчанию обработчики в addEventListener работают на фазе
            всплытия.
          </p>
        </div>
        <div class="subtopic">
          <h4>Как повесить обработчик click</h4>
          <p>Современный способ — addEventListener:</p>
          <p class="code--block" data-lang="JS">
            const button = document.getElementById("myBtn"); <br />
            <br />
            button.addEventListener("click", (event) => { <br />
            &nbsp;&nbsp;console.log("Клик по кнопке"); <br />
            });
          </p>
          <p>Синтаксис:</p>
          <p class="code--block" data-lang="JS">
            element.addEventListener(type, listener, useCapture);
          </p>
          <ul>
            <li>type — строка события: "click", "input", "submit" и т.д.</li>
            <li>listener — функция‑обработчик, обычно (event) => { ... }.</li>
            <li>
              useCapture (опционально) — false по умолчанию (всплытие), true —
              обработчик срабатывает на фазе погружения.
            </li>
          </ul>
          <p>Пример с погружением:</p>
          <p class="code--block" data-lang="JS">
            outer.addEventListener("click", handler, true); // capture <br />
            inner.addEventListener("click", handler, false); // bubble
          </p>
        </div>
        <div class="subtopic">
          <h4>event.target и event.currentTarget</h4>
          <p>Оба свойства есть у объекта события event.</p>
          <h5>event.target</h5>
          <p>
            event.target — конкретный элемент, на котором произошло событие (где
            пользователь кликнул).
          </p>
          <p class="code--block" data-lang="JS">
            document.addEventListener("click", (event) => { <br />
            console.log("target:", event.target); <br />
            });
          </p>
          <p>Если клик по button, event.target будет button.</p>
          <h5>event.currentTarget</h5>
          <p>
            event.currentTarget — элемент, на котором сейчас выполняется
            обработчик, т.е. куда повесили addEventListener.
          </p>
          <p class="code--block" data-lang="JS">
            const div = document.getElementById("container"); <br />
            <br />

            div.addEventListener("click", (event) => { <br />
            console.log("currentTarget:", event.currentTarget); // всегда div
            <br />
            console.log("target:", event.target); // конкретный вложенный
            элемент <br />
            });
          </p>
          <div>
            <h5>Разница:</h5>
            <ul>
              <li>target — «где реально кликнули».</li>
              <li>
                currentTarget — «на каком элементе сейчас выполняется этот
                обработчик».
              </li>
            </ul>
            <h5>При клике по вложенному элементу внутри контейнера:</h5>
            <ul>
              <li>event.target → этот вложенный элемент;</li>
              <li>
                event.currentTarget → контейнер, если обработчик висит на
                контейнере.
              </li>
            </ul>
          </div>
        </div>
        <div class="subtopic">
          <h4>Делегирование событий</h4>
          <p>
            Идея делегирования: вместо того чтобы вешать обработчик на каждый
            элемент отдельно, мы вешаем один обработчик на общего родителя и в
            нём смотрим, по какому именно ребёнку кликнули, используя
            event.target.
          </p>
          <p>Пример: есть список, и нам нужно реагировать на клики по li:</p>
          <p class="code--block" data-lang="HTML">
            &lt;ul id=&quot;list&quot;&gt; <br />
            &nbsp;&nbsp;&lt;li data-id=&quot;1&quot;&gt;Элемент 1&lt;/li&gt;
            <br />
            &nbsp;&nbsp;&lt;li data-id=&quot;2&quot;&gt;Элемент 2&lt;/li&gt;
            <br />
            &nbsp;&nbsp;&lt;li data-id=&quot;3&quot;&gt;Элемент 3&lt;/li&gt;
            <br />
            &lt;/ul&gt;
          </p>
          <p class="code--block" data-lang="JS">
            const list = document.getElementById("list"); <br />
            <br />

            list.addEventListener("click", (event) => { <br />
            const item = event.target.closest("li"); // ищем ближайший li <br />
            if (!item || !list.contains(item)) return; <br />
            <br />

            const id = item.dataset.id; <br />
            console.log("Клик по элементу с id =", id); <br />
            });
          </p>
          <p>Что тут важно:</p>
          <ul>
            <li>
              Обработчик висит только на ul, но ловит клики по любому li внутри
              — это и есть делегирование.
            </li>
            <li>event.target — элемент, по которому конкретно кликнули.</li>
            <li>
              Используем closest("li"), чтобы подняться до нужного предка.
            </li>
          </ul>
          <p>Плюсы делегирования:</p>
          <ul>
            <li>Меньше обработчиков → лучше производительность.</li>
            <li>
              Работает даже для динамически добавленных элементов, потому что
              событие всплывает до родителя.
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h4>Кратко</h4>
          <ul>
            <li>
              В браузере события проходят фазы: погружение сверху вниз и
              всплытие снизу вверх. По умолчанию addEventListener срабатывает на
              фазе всплытия, но можно включить погружение третьим параметром
              true.
            </li>
            <li>
              Обработчик click обычно вешают так:
              element.addEventListener("click", handler).
            </li>
            <li>
              event.target — элемент, где событие произошло, event.currentTarget
              — элемент, на котором висит обработчик. При делегировании вешаем
              обработчик на родителя, используем event.target, чтобы понять, по
              какому дочернему элементу кликнули.
            </li>
            <li>
              Делегирование событий — это приём, когда один обработчик на
              родителе обрабатывает события всех дочерних элементов за счёт
              всплытия, что оптимизирует код и упрощает работу с динамическим
              DOM.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>8. Что такое event loop? Макро и микро таски.</h3>
        <div class="subtopic">
          <h4>Что такое event loop</h4>
          <p>
            JavaScript однопоточен: в один момент времени выполняется только
            один фрагмент кода, а асинхронность реализуется через очереди задач
            и event loop.
          </p>
          <p>Event loop — это механизм, который:</p>
          <ol>
            <li>
              Выполняет весь синхронный код (то, что попало в call stack).
            </li>
            <li>
              Когда стек пуст, берёт задачи из очередей (микро‑ и макротаски) и
              выполняет их по определённым правилам.
            </li>
          </ol>
          <p>
            По сути, это цикл: «выполнил стек → обработал микротаски → взял
            следующую макротаску → снова обработал микротаски и т.д.».
          </p>
        </div>
        <div class="subtopic">
          <h4>Макротаски (macrotasks)</h4>
          <p>
            Макротаски (task queue) — это крупные асинхронные задачи, которые
            попадают в очередь «обычных» задач.
          </p>
          <p>Примеры макротасок:</p>
          <ul>
            <li>setTimeout, setInterval</li>
            <li>события DOM (click, load и т.п.)</li>
            <li>сетевые колбэки (XHR, fetch, I/O)</li>
          </ul>
          <p>Работа цикла:</p>
          <ol>
            <li>Выполняется весь синхронный код.</li>
            <li>Потом берётся одна макротаска из очереди и выполняется.</li>
            <li>
              После этого снова дают шанс микротаскам, и только потом переходят
              к следующей макротаске.
            </li>
          </ol>
        </div>
        <div class="subtopic">
          <h4>Микротаски (microtasks)</h4>
          <p>
            Микротаски — задачи более высокого приоритета, которые выполняются
            до перехода к следующей макротаске.
          </p>
          <p>Примеры микротасок:</p>
          <ul>
            <li>обработчики Promise.then, catch, finally</li>
            <li>queueMicrotask(...)</li>
            <li>(в браузере также mutation observer и др.)</li>
          </ul>
          <p>
            Правило: после выполнения синхронного кода и каждой макротаски
            движок полностью вычищает очередь микротасок, прежде чем брать
            следующую макротаску.
          </p>
        </div>

        <div class="subtopic">
          <h4>Почему Promise выполняется раньше setTimeout 0</h4>
          <p>Классический пример:</p>
          <p class="code--block" data-lang="JS">
            console.log("start"); <br />
            <br />

            setTimeout(() => { <br />
            console.log("timeout"); <br />
            }, 0); <br />
            <br />

            Promise.resolve().then(() => { <br />
            console.log("promise"); <br />
            }); <br />
            <br />

            console.log("end");
          </p>
          <p>Порядок вывода:</p>
          <ol>
            <li>start</li>
            <li>end</li>
            <li>promise</li>
            <li>timeout</li>
          </ol>
          <p>Объяснение:</p>
          <ol>
            <li>start и end — синхронный код, выполняется сразу.</li>
            <li>setTimeout(..., 0) → колбэк в очередь макротасок.</li>
            <li>Promise.resolve().then(...) → колбэк в очередь микротасок.</li>
            <li>
              После синхронного кода event loop сначала выполняет все микротаски
              → promise.
            </li>
            <li>Потом берёт первую макротаску → timeout.</li>
          </ol>
        </div>
        <div class="subtopic">
          <h4>Кратко</h4>
          <ul>
            <li>
              Event loop — это механизм в JS, который управляет выполнением
              кода: он берёт синхронный код, затем асинхронные задачи из
              очередей, чтобы однопоточный JS мог работать с асинхронностью.
            </li>
            <li>
              Есть две важные очереди: макротаски и микротаски. Макротаски — это
              setTimeout, события DOM и другие крупные задачи; микротаски — в
              основном обработчики промисов и queueMicrotask.
            </li>
            <li>
              После выполнения синхронного кода и каждой макротаски движок
              сначала полностью вычищает очередь микротасок, и только потом
              берёт следующую макротаску. Поэтому Promise.then выполняется
              раньше setTimeout(..., 0).
            </li>
          </ul>
        </div>
        <div class="subtopic">
          <h5>Вот понятный порядок</h5>
          <p>
            Синхронный код ↓ <br />
            | <br />
            Микротаски (ВСЕ) ↓ <br />
            | <br />
            Макротаска 1 ↓ <br />
            | <br />
            Микротаски (ВСЕ) ↓ <br />
            | <br />
            Макротаска 2 ↓ <br />
            | <br />
            Микротаски (ВСЕ) ↓ <br />
            и так далее...
          </p>
        </div>
      </div>
    </section>

    <section class="section vue">
      <h3>Вопросы по VUE</h3>
      <div class="exam--card">
        <h3>
          1. Чем отличается computed от обычной функции? Когда и зачем
          использовать watch, если есть computed? Что такое ref и reactive.
        </h3>

        <div class="subtopic">
          <h4>1. Чем отличается computed от обычной функции (methods)</h4>
          <p>
            <strong>computed</strong> — это «вычисляемое свойство», которое
            ведёт себя как поле объекта: оно автоматически пересчитывается,
            когда меняются его зависимые реактивные данные, и результат
            кэшируется.
          </p>
          <p>
            Обычный метод (функция в <code>methods</code>) запускается каждый
            раз при вызове, не кэширует результат и не зависит от реактивных
            данных автоматически — это просто функция.
          </p>
          <p>
            Если одно и то же вычисление нужно часто использовать в шаблоне
            (например, в нескольких местах или при каждом рендере), лучше
            использовать <code>computed</code>, чтобы не считать одно и то же
            много раз.
          </p>

          <p class="code--block" data-lang="JS">
            const { createApp, computed } = Vue; <br />
            <br />
            const app = createApp(&#123; <br />
            &nbsp;&nbsp;data() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;return &#123; firstName: 'Иван', lastName:
            'Иванов' &#125;; <br />
            &nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;computed: &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;fullName() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.firstName + ' ' +
            this.lastName; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&#125; <br />
            &nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;methods: &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;getFullName() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.firstName + ' ' +
            this.lastName; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&#125; <br />
            &nbsp;&nbsp;&#125; <br />
            &#125;); <br />
          </p>
          <p>Ключевая разница</p>
          <ul>
            <li>
              Метод вызывается заново КАЖДЫЙ раз, когда компонент
              перерендеривается (каждый ре-рендер шаблона).
            </li>
            <li>
              Computed запоминает (кэширует) результат и пересчитывается только
              тогда, когда изменились его зависимости
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>2. Когда и зачем использовать watch, если есть computed</h4>
          <p>
            <strong>computed</strong> используют, когда нужно получить новое
            значение на основе других реактивных данных и использовать это
            значение в шаблоне, как обычное свойство.
          </p>
          <p>
            <strong>watch</strong> используют, когда при изменении данных нужно
            выполнить побочный эффект: запрос на сервер, запись в localStorage,
            запуск/очистка таймера, логирование и т.п. — то есть не просто
            вернуть значение.
          </p>
          <p>
            <code>watch</code> «подписывается» на изменение реактивного
            источника (ref, reactive-свойство или computed) и вызывает
            функцию‑обработчик с новым и старым значениями.
          </p>

          <p class="code--block" data-lang="JS">
            const &#123; ref, watch &#125; = Vue; <br />
            <br />
            const search = ref(''); <br />
            <br />
            watch(search, (newValue, oldValue) =&gt; &#123; <br />
            &nbsp;&nbsp;// Пример: отправить запрос на сервер с задержкой,
            сохранить в localStorage и т.п. <br />
            &nbsp;&nbsp;console.log('Поиск изменился:', oldValue, '-&gt;',
            newValue); <br />
            &#125;); <br />
          </p>

          <p>
            Здесь <code>computed</code> не подойдёт, потому что нам нужно не
            «получить значение», а «среагировать действием» на изменение
            значения.
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Что такое ref и reactive в Vue 3</h4>
          <p>
            <strong>ref</strong> создаёт «обёртку» над значением:
            <code>ref(значение)</code> возвращает объект с полем
            <code>.value</code>, и это значение становится реактивным (Vue
            отслеживает его изменения).
          </p>
          <p>
            <strong>ref</strong> обычно используют для примитивов (число,
            строка, boolean), но можно также оборачивать объекты и массивы,
            тогда реактивной будет сама ссылка (для работы с DOM, ссылок на
            компоненты и т.п.).
          </p>
          <p>
            <strong>reactive</strong> делает объект «глубоко реактивным»:
            оборачивает сам объект и его свойства в Proxy, так что изменения
            любых вложенных полей отслеживаются. Он не работает напрямую с
            примитивами — только с объектами.
          </p>

          <p class="code--block" data-lang="JS">
            const &#123; ref, reactive &#125; = Vue; <br />
            <br />
            const count = ref(0); <br />
            // Обращаемся так: count.value <br />
            <br />
            const state = reactive(&#123; <br />
            &nbsp;&nbsp;name: 'Иван', <br />
            &nbsp;&nbsp;age: 20 <br />
            &#125;); <br />
            // Обращаемся как к обычному объекту: state.name, state.age <br />
          </p>

          <p>
            В шаблоне Vue автоматически «распаковывает» <code>ref</code>,
            поэтому там можно писать
            <code>&#123;&#123; count &#125;&#125;</code>, а не
            <code>&#123;&#123; count.value &#125;&#125;</code>; в JS‑коде за
            пределами шаблона нужно использовать <code>.value</code>.
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Кратко</h4>
          <ul>
            <li>
              <strong>computed</strong> — вычисляемое свойство, завязано на
              реактивные данные, кэширует результат и пересчитывается только при
              изменении зависимостей; удобно для сложных вычислений,
              используемых в шаблоне.
            </li>
            <li>
              Обычная функция в <code>methods</code> — выполняется при каждом
              вызове, без кэша, годится для обработчиков событий и одноразовых
              вычислений.
            </li>
            <li>
              <strong>watch</strong> нужен, когда при изменении данных надо
              выполнить действие (запрос, таймер, запись в хранилище), а не
              просто получить новое значение.
            </li>
            <li>
              <strong>ref</strong> — реактивная обёртка над значением, чаще
              всего примитивом; доступ через <code>.value</code> в JS, в шаблоне
              можно писать как обычную переменную.
            </li>
            <li>
              <strong>reactive</strong> — делает объект (и его вложенные
              свойства) реактивным; используют для состояния с несколькими
              полями, когда удобно работать с объектом.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          2. Что делает директива v-model и как она работает? Как v-model
          работает на кастомных компонентах. Как передать данные от
          родительского компонента к дочернему и обратно?
        </h3>

        <div class="subtopic">
          <h4>1. Что делает директива v-model и как она работает</h4>
          <p>
            <strong>v-model</strong> создаёт двустороннюю привязку между полем
            формы (input, textarea, select и т.п.) и реактивным состоянием
            компонента. При вводе в поле значение автоматически попадает в
            состояние, а при изменении состояния — обновляется значение поля.
          </p>
          <p>
            Под капотом <code>v-model</code> — это просто синтаксический сахар
            для связки <code>:value</code> (или соответствующего атрибута) и
            события ввода (обычно <code>@input</code> или
            <code>@update:modelValue</code> для компонента).
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- В шаблоне --&gt; <br />
            &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt;
            <br />
          </p>

          <p class="code--block" data-lang="JS">
            // Внутри компонента <br />
            import &#123; ref &#125; from 'vue'; <br />
            <br />
            const username = ref(''); <br />
            // v-model=&quot;username&quot; &lt;=&gt;
            :value=&quot;username&quot; + @input=&quot;username =
            $event.target.value&quot; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Как v-model работает на кастомных компонентах</h4>
          <p>
            Когда мы пишем <code>&lt;MyInput v-model="value" /&gt;</code> на
            кастомном компоненте, Vue разворачивает это в передачу пропа
            <code>modelValue</code> и прослушку события
            <code>update:modelValue</code>.
          </p>
          <p>
            Правило: дочерний компонент должен принять проп
            <code>modelValue</code> и выбрасывать событие
            <code>update:modelValue</code> с новым значением, тогда родительское
            <code>v-model</code> будет работать автоматически.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Родительский компонент --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;CustomInput v-model=&quot;message&quot; /&gt; <br />
            &nbsp;&nbsp;&lt;p&gt;Сообщение: &#123;&#123; message
            &#125;&#125;&lt;/p&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            // Родитель <br />
            import &#123; ref &#125; from 'vue'; <br />
            import CustomInput from './CustomInput.vue'; <br />
            <br />
            const message = ref('Привет'); <br />
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Дочерний компонент CustomInput.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;input <br />
            &nbsp;&nbsp;&nbsp;&nbsp;:value=&quot;modelValue&quot; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;@input=&quot;$emit('update:modelValue',
            $event.target.value)&quot; <br />
            &nbsp;&nbsp;/&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            &lt;script setup&gt; <br />
            const props = defineProps(&#123; <br />
            &nbsp;&nbsp;modelValue: &#123; type: String, default: '' &#125;
            <br />
            &#125;); <br />
            <br />
            const emit = defineEmits(['update:modelValue']); <br />
            &lt;/script&gt; <br />
          </p>

          <p>
            С точки зрения синтаксиса родителя, конструкция
            <code>&lt;CustomInput v-model="message" /&gt;</code> эквивалентна
            <code
              >&lt;CustomInput :modelValue="message" @update:modelValue="message
              = $event" /&gt;</code
            >.
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Передача данных от родителя к дочернему и обратно</h4>
          <p>
            От родителя к дочернему данные передаются через
            <strong>props</strong>: родитель передаёт значения в атрибутах тега,
            а дочерний объявляет соответствующие пропы и читает их как обычные
            переменные.
          </p>
          <p>
            Обратно (от дочернего к родителю) данные передаются через
            <strong>события</strong>: дочерний компонент вызывает
            <code>$emit('имя-события', данные)</code>, а родитель подписывается
            на событие через <code>@имя-события="обработчик"</code>.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Родитель --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;ChildComponent <br />
            &nbsp;&nbsp;&nbsp;&nbsp;:title=&quot;parentTitle&quot; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;@change-title=&quot;handleChangeTitle&quot;
            <br />
            &nbsp;&nbsp;/&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            // Родительский скрипт <br />
            import &#123; ref &#125; from 'vue'; <br />
            <br />
            const parentTitle = ref('Начальный заголовок'); <br />
            <br />
            function handleChangeTitle(newTitle) &#123; <br />
            &nbsp;&nbsp;parentTitle.value = newTitle; <br />
            &#125; <br />
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Дочерний компонент ChildComponent.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;div&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;&#123;&#123; title
            &#125;&#125;&lt;/h4&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;button
            @click=&quot;onClick&quot;&gt;Изменить заголовок&lt;/button&gt;
            <br />
            &nbsp;&nbsp;&lt;/div&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            &lt;script setup&gt; <br />
            const props = defineProps(&#123; <br />
            &nbsp;&nbsp;title: &#123; type: String, required: true &#125; <br />
            &#125;); <br />
            <br />
            const emit = defineEmits(['change-title']); <br />
            <br />
            function onClick() &#123; <br />
            &nbsp;&nbsp;emit('change-title', 'Новый заголовок из дочернего');
            <br />
            &#125; <br />
            &lt;/script&gt; <br />
          </p>

          <p>
            В реальных проектах для простых форм часто используют
            <code>v-model</code> поверх этой схемы: проп
            <code>modelValue</code> + событие <code>update:modelValue</code>,
            что фактически является комбинацией props + emit.
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Кратко</h4>
          <ul>
            <li>
              <strong>v-model</strong> — двусторонняя привязка: состояние
              &lt;=&gt; элемент формы или компонент; внутри это связка
              <code>:value</code> и события обновления.
            </li>
            <li>
              На кастомном компоненте <code>v-model</code> разворачивается в
              <code>:modelValue</code> + <code>@update:modelValue</code>,
              дочерний обязан принять <code>modelValue</code> и эмитить
              <code>update:modelValue</code>.
            </li>
            <li>
              От родителя к дочернему данные идут через
              <strong>props</strong> (атрибуты тега =&gt; объявленные пропы в
              дочернем).
            </li>
            <li>
              От дочернего к родителю данные идут через
              <strong>события</strong> (<code>$emit('имя', данные)</code> в
              дочернем и <code>@имя=&quot;обработчик&quot;</code> в
              родительском).
            </li>
            <li>
              <code>v-model</code> на компонентах — это удобный сахар над
              связкой props + emit (модель: <code>modelValue</code> /
              <code>update:modelValue</code>).
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          3. Что такое props drilling и почему он считается архитектурной
          проблемой? Какими способами можно решить эту проблему.
        </h3>

        <div class="subtopic">
          <h4>1. Что такое props drilling</h4>
          <p>
            <strong>Props drilling</strong> — это ситуация, когда одни и те же
            данные приходится передавать через несколько уровней вложенных
            компонентов от верхнего родителя к глубоко вложенному потомку,
            причём промежуточные компоненты сами эти данные не используют, а
            только «прокидывают дальше».
          </p>
          <p>
            Например, если данные нужны компоненту «внуку», но живут в самом
            верхнем компоненте, их приходится передавать через родителя и
            ребёнка только ради того, чтобы добросить их до нужного места.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Верхний компонент --&gt; <br />
            &lt;Parent :user=&quot;user&quot; /&gt; <br />
            <br />
            &lt;!-- Parent.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;Child :user=&quot;user&quot; /&gt; &lt;!-- сам
            Parent user не использует --&gt; <br />
            &lt;/template&gt; <br />
            <br />
            &lt;!-- Child.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;GrandChild :user=&quot;user&quot; /&gt; <br />
            &lt;/template&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Почему props drilling считается архитектурной проблемой</h4>
          <ul>
            <li>
              Усложняется код: много «промежуточных» props, которые компоненты
              не используют по сути, а только перенаправляют дальше.
            </li>
            <li>
              Падает читаемость: сложнее понять, откуда пришли данные и где они
              реально нужны; затрудняется отладка и навигация по коду.
            </li>
            <li>
              Слабая масштабируемость: при изменении структуры компонентов или
              данных приходится править сразу много уровней.
            </li>
            <li>
              Сильная связность: компоненты зависят от контекста выше по дереву,
              их сложнее переиспользовать в другом месте.
            </li>
            <li>
              Лишние перерисовки: изменение одного props может вызывать
              обновление всех промежуточных компонентов, хотя им данные не
              нужны.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>3. Способы решения проблемы props drilling в Vue</h4>
          <p>
            В Vue есть несколько подходов, которые позволяют не «таскать» props
            через все уровни дерева, а давать доступ к данным там, где они
            реально нужны.
          </p>
        </div>

        <div class="subtopic">
          <h4>3.1. provide / inject</h4>
          <p>
            Механизм <strong>provide/inject</strong> позволяет верхнему
            компоненту «предоставить» значение всем своим потомкам, а глубоко
            вложенные компоненты могут его «подключить» через
            <code>inject</code> без явной передачи через каждый уровень.
          </p>
          <p>
            Это удобно для глобальных настроек, текущего пользователя, тем,
            локализации, форм, когда одно и то же состояние нужно многим
            вложенным компонентам.
          </p>

          <p class="code--block" data-lang="JS">
            &lt;!-- App.vue --&gt; <br />
            &lt;script setup&gt; <br />
            import &#123; provide, ref &#125; from 'vue'; <br />
            <br />
            const currentUser = ref(&#123; name: 'Иван', role: 'admin' &#125;);
            <br />
            <br />
            provide('currentUser', currentUser); <br />
            &lt;/script&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            &lt;!-- Глубоко вложенный компонент --&gt; <br />
            &lt;script setup&gt; <br />
            import &#123; inject &#125; from 'vue'; <br />
            <br />
            const currentUser = inject('currentUser'); <br />
            // currentUser.value.name и т.д. доступны без props на каждом уровне
            <br />
            &lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3.2. Глобальное состояние: Pinia / Vuex / собственный стор</h4>
          <p>
            Для данных, которые нужны многим частям приложения (авторизация,
            корзина, настройки), используют отдельное хранилище состояния: в
            актуальных проектах чаще всего это Pinia (вместо Vuex).
          </p>
          <p>
            Компонент читает и изменяет данные прямо из стора, а не через
            бесконечные props, что убирает необходимость прокидывать состояние
            через все уровни.
          </p>

          <p class="code--block" data-lang="JS">
            // Пример Pinia-хранилища userStore <br />
            import &#123; defineStore &#125; from 'pinia'; <br />
            <br />
            export const useUserStore = defineStore('user', &#123; <br />
            &nbsp;&nbsp;state: () =&gt; (&#123; name: 'Иван', role: 'admin'
            &#125;), <br />
            &nbsp;&nbsp;actions: &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;setName(name) &#123; this.name = name;
            &#125; <br />
            &nbsp;&nbsp;&#125; <br />
            &#125;); <br />
          </p>

          <p class="code--block" data-lang="JS">
            // В любом компоненте <br />
            import &#123; useUserStore &#125; from '@/stores/userStore'; <br />
            <br />
            const userStore = useUserStore(); <br />
            console.log(userStore.name); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3.3. Composables (composition functions)</h4>
          <p>
            В Vue 3 можно вынести общую логику в отдельные функции
            (composables), например <code>useUser()</code> или
            <code>useTheme()</code>, которые возвращают реактивные переменные и
            методы.
          </p>
          <p>
            Любой компонент может подключить этот composable напрямую, без
            передачи данных через props, получив доступ к разделяемому состоянию
            или логике.
          </p>

          <p class="code--block" data-lang="JS">
            // useUser.js <br />
            import &#123; ref &#125; from 'vue'; <br />
            <br />
            const user = ref(&#123; name: 'Иван' &#125;); <br />
            <br />
            export function useUser() &#123; <br />
            &nbsp;&nbsp;function setName(name) &#123; user.value.name = name;
            &#125; <br />
            &nbsp;&nbsp;return &#123; user, setName &#125;; <br />
            &#125; <br />
          </p>

          <p class="code--block" data-lang="JS">
            // В двух разных компонентах <br />
            import &#123; useUser &#125; from '@/composables/useUser'; <br />
            <br />
            const &#123; user, setName &#125; = useUser(); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3.4. Локальное поднятие состояния (lift state up)</h4>
          <p>
            Иногда достаточно немного изменить структуру: перенести состояние
            ближе к тем компонентам, которые его реально используют, чтобы
            сократить количество уровней, через которые проходят props.
          </p>
          <p>
            Это не избавляет полностью от props, но уменьшает глубину их
            «прокидывания» и делает дерево компонентов логичнее.
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Кратко</h4>
          <ul>
            <li>
              Props drilling — это передача одних и тех же данных через много
              уровней компонентов, которые их сами не используют.
            </li>
            <li>
              Это проблема, потому что код засоряется лишними props, падает
              читаемость, возрастает связность и сложнее масштабировать
              архитектуру.
            </li>
            <li>
              Основные решения: <strong>provide/inject</strong> для передачи
              данных от предка ко всем потомкам без промежуточных props.
            </li>
            <li>
              Глобальное состояние (Pinia/Vuex/собственный стор) — данные живут
              отдельно от дерева компонентов, компоненты их читают напрямую.
            </li>
            <li>
              Composables (composition functions) и продуманное размещение
              состояния помогают сократить или полностью убрать props drilling.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          4. Чем принципиально отличается механизм provide / inject от
          использования глобального состояния через Pinia?
        </h3>

        <div class="subtopic">
          <h4>1. Суть provide / inject</h4>
          <p>
            Механизм <strong>provide / inject</strong> — это встроенная в Vue
            система внедрения зависимостей: предок «предоставляет» значение, а
            любой его потомок может это значение «подключить», минуя
            промежуточные уровни компонентов.
          </p>
          <p>
            Область видимости provide / inject ограничена конкретным деревом
            компонентов: данные доступны только потомкам того компонента,
            который выполняет provide.
          </p>

          <p class="code--block" data-lang="JS">
            &lt;!-- Родитель --&gt; <br />
            &lt;script setup&gt; <br />
            import &#123; provide, ref &#125; from 'vue'; <br />
            <br />
            const theme = ref('dark'); <br />
            provide('theme', theme); <br />
            &lt;/script&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            &lt;!-- Глубокий потомок --&gt; <br />
            &lt;script setup&gt; <br />
            import &#123; inject &#125; from 'vue'; <br />
            <br />
            const theme = inject('theme'); <br />
            // theme.value доступна без props через все уровни дерева <br />
            &lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Суть глобального состояния через Pinia</h4>
          <p>
            <strong>Pinia</strong> — это официальная библиотека для глобального
            состояния в Vue 3: данные хранятся в отдельных «стоях» (stores),
            которые можно импортировать и использовать в любых компонентах и
            даже вне компонентов.
          </p>
          <p>
            Состояние в Pinia обычно живёт на уровне всего приложения: к одному
            и тому же store обращаются разные, даже не связанные друг с другом
            ветки дерева компонентов и разные страницы.
          </p>

          <p class="code--block" data-lang="JS">
            // userStore.js <br />
            import &#123; defineStore &#125; from 'pinia'; <br />
            <br />
            export const useUserStore = defineStore('user', &#123; <br />
            &nbsp;&nbsp;state: () =&gt; (&#123; name: 'Иван', role: 'admin'
            &#125;), <br />
            &nbsp;&nbsp;actions: &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;setName(name) &#123; this.name = name;
            &#125; <br />
            &nbsp;&nbsp;&#125; <br />
            &#125;); <br />
          </p>

          <p class="code--block" data-lang="JS">
            // В любом компоненте <br />
            import &#123; useUserStore &#125; from '@/stores/userStore'; <br />
            <br />
            const userStore = useUserStore(); <br />
            console.log(userStore.name); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Принципиальные отличия provide / inject и Pinia</h4>
          <ul>
            <li>
              <strong>Область действия</strong>: provide / inject работает в
              рамках конкретного поддерева компонентов, Pinia — на уровне всего
              приложения (глобально).
            </li>
            <li>
              <strong>Назначение</strong>: provide / inject решает проблему
              props drilling (глубоко вложенные компоненты в одном контексте),
              Pinia решает задачу общеприложенческого состояния (авторизация,
              корзина, настройки, кэш данных).
            </li>
            <li>
              <strong>Архитектура</strong>: provide / inject — низкоуровневый
              DI-механизм Vue без дополнительных соглашений; Pinia даёт
              структуру (state, getters, actions), devtools-интеграцию и явные
              паттерны работы со сторами.
            </li>
            <li>
              <strong>Доступ</strong>: provide / inject требует наличия
              родителя, который делает provide; Pinia store можно импортировать
              где угодно, в том числе вне компонента (например, в сервисах).
            </li>
            <li>
              <strong>Масштаб</strong>: provide / inject удобно для локальных
              контекстов (одна форма, один модуль, одна страница), Pinia — для
              данных, нужных многим независимым частям приложения.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>4. Когда использовать provide / inject, а когда Pinia</h4>
          <p>
            provide / inject подходит, когда состояние «логически принадлежит»
            одному компоненту и его потомкам: например, контекст формы, тема
            внутри layout-а, локальный менеджер модалок, который нужен только в
            этой части дерева.
          </p>
          <p>
            Pinia лучше, когда состояние действительно глобальное: авторизация
            пользователя, настройки приложения, корзина интернет‑магазина, общие
            фильтры, которые должны жить между страницами и сохраняться при
            навигации.
          </p>

          <p class="code--block" data-lang="JS">
            // Пример: локальный контекст формы через provide/inject <br />
            // FormRoot.vue <br />
            import &#123; provide, reactive &#125; from 'vue'; <br />
            <br />
            const formState = reactive(&#123; name: '', email: '' &#125;);
            <br />
            provide('formState', formState); <br />
            <br />
            // Любой дочерний компонент формы: <br />
            // const formState = inject('formState'); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Кратко</h4>
          <ul>
            <li>
              provide / inject — встроенный механизм Vue для передачи данных от
              предка к потомкам без prop drilling; область действия — одно
              дерево компонентов.
            </li>
            <li>
              Pinia — библиотека глобального состояния: отдельные stores,
              devtools, удобные паттерны; область действия — всё приложение.
            </li>
            <li>
              provide / inject удобно для локальных контекстов (форма, тема,
              модалка), когда состояние нужно только в конкретной ветке дерева.
            </li>
            <li>
              Pinia используют, когда одно и то же состояние нужно на разных
              страницах и в несвязанных компонентах, и его важно централизованно
              хранить и отлаживать.
            </li>
            <li>
              Главная разница: provide / inject — scoped-контекст внутри
              поддерева, Pinia — централизованный глобальный стор приложения.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          5. В чём принципиальная разница между состоянием приложения (App State
          - Pinia) и кэшем данных (Cache - TanStack Query)?
        </h3>

        <div class="subtopic">
          <h4>1. Что такое состояние приложения (App State, Pinia)</h4>
          <p>
            <strong>Состояние приложения</strong> — это данные, которые живут
            исключительно на клиенте и описывают текущую работу интерфейса:
            выбранная вкладка, открыта ли модалка, содержимое формы до отправки,
            выбранные фильтры, текущий пользователь и его права, локальные флаги
            вроде «показывать спиннер» или «показать тост».
          </p>
          <p>
            Pinia хранит именно такое клиентское состояние: оно не обязано
            один-в-один совпадать с данными на сервере, может существовать
            только в рамках текущей сессии и может быть произвольной структуры
            (включая чисто UI-флаги).
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Что такое кэш данных (Cache, TanStack Query)</h4>
          <p>
            <strong>Кэш TanStack Query</strong> хранит не «свободное» состояние,
            а результат запросов к серверу — то есть серверное состояние,
            которое пришло по HTTP/WS и может меняться независимо от клиента
            (другими пользователями, другими сервисами).
          </p>
          <p>
            TanStack Query управляет именно серверным состоянием: когда и как
            его получать, сколько держать в кэше, когда считать устаревшим,
            когда автоматически обновлять в фоне, как обрабатывать ошибки и
            повторные запросы.
          </p>
        </div>

        <div class="subtopic">
          <h4>
            3. Принципиальные отличия App State (Pinia) и Cache (TanStack Query)
          </h4>
          <ul>
            <li>
              <strong>Источник данных</strong>: App State — данные рождаются на
              клиенте и живут в приложении; Cache — это копия данных, «источник
              истины» для которых находится на сервере.
            </li>
            <li>
              <strong>Владение данными</strong>: App State «принадлежит» фронту
              (мы можем полностью менять его локально); Cache должен оставаться
              синхронизированным с сервером, и обновление делается через
              запросы/мутации.
            </li>
            <li>
              <strong>Семантика</strong>: App State описывает текущий UI и
              поведение (выборы пользователя, состояние форм), Cache описывает
              загруженные ресурсы: списки, сущности, детали, которые сервер
              отдаёт по API.
            </li>
            <li>
              <strong>Жизненный цикл</strong>: App State живёт столько, сколько
              нужно логике приложения (иногда через несколько страниц, иногда
              только пока открыт компонент); Cache управляется правилами
              свежести/устаревания (stale/fresh, refetch при фокусе, gc времени
              и т.п.).
            </li>
            <li>
              <strong>Инструменты</strong>: Pinia даёт структуру для
              произвольного состояния (state/getters/actions), TanStack Query
              даёт high‑level API для запросов/мутаций, кэша, инвалидации и
              фоновых обновлений.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>4. Как работать с ними вместе</h4>
          <p>
            Pinia обычно используют для того, что не является прямым «ответом
            сервера»: состояние UI, выбранные элементы, промежуточные значения,
            флаги «отфильтровано ли», локальные настройки пользователя, которые
            не обязательно хранить на сервере.
          </p>
          <p>
            TanStack Query используют для загрузки и кэширования серверных
            данных: списки товаров, пользователей, задач, комментариев, а также
            для синхронизации изменений (mutations) и автоматического обновления
            этих данных в интерфейсе.
          </p>
          <p>
            Частый паттерн: TanStack Query отвечает за получение и кеширование
            «сырых» данных с сервера, а Pinia — за выбранные фильтры, текущую
            страницу, выбранный элемент, временное состояние форм и прочую
            клиентскую логику поверх этих данных.
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Кратко</h4>
          <ul>
            <li>
              App State (Pinia) — клиентское состояние интерфейса: вкладки,
              модалки, фильтры, текущий пользователь и прочая логика, которая
              живёт только во фронтенде.
            </li>
            <li>
              Cache (TanStack Query) — кэш серверных данных: результаты
              запросов, которые библиотека обновляет, помечает устаревшими,
              перезапрашивает и синхронизирует с бэкендом.
            </li>
            <li>
              Pinia отвечает за «что сейчас происходит в приложении», TanStack
              Query — за «какие данные с сервера у нас есть и насколько они
              свежие».
            </li>
            <li>
              Они не конкуренты: TanStack Query не заменяет Pinia, а закрывает
              именно задачу управления серверным состоянием и его кэшированием.
            </li>
            <li>
              Типичный подход: TanStack Query — источник данных с сервера, Pinia
              — центр управления UI и пользовательскими настройками вокруг этих
              данных.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>6. Какие основные хуки жизненного цикла существуют в Vue?</h3>

        <div class="subtopic">
          <h4>1. Общая идея жизненного цикла</h4>
          <p>
            Компонент Vue проходит несколько стадий жизни: создание,
            монтирование в DOM, обновление при изменении данных и уничтожение.
            На каждой из этих стадий можно выполнить свой код через специальные
            функции — хуки жизненного цикла.
          </p>
          <p>
            В Options API хуки объявляются как методы объекта компонента
            (например, <code>mounted()</code>), а в Composition API — как
            функции <code>onMounted</code>, <code>onUpdated</code> и т.п.,
            вызываемые внутри <code>&lt;script setup&gt;</code>.
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Основные хуки жизненного цикла (Options API)</h4>
          <p>
            В классической форме (Options API) обычно выделяют восемь основных
            хуков компонента:
          </p>
          <ul>
            <li>
              <strong>beforeCreate</strong> — вызывается до создания экземпляра
              (данные и реактивность ещё не настроены).
            </li>
            <li>
              <strong>created</strong> — экземпляр создан, реактивность
              настроена, но компонент ещё не смонтирован в DOM.
            </li>
            <li>
              <strong>beforeMount</strong> — вызывается перед первым
              монтированием компонента в DOM.
            </li>
            <li>
              <strong>mounted</strong> — компонент смонтирован, DOM-элементы
              доступны (часто используют для работы с DOM или сторонними
              библиотеками).
            </li>
            <li>
              <strong>beforeUpdate</strong> — вызывается перед повторным
              рендером при изменении реактивных данных.
            </li>
            <li>
              <strong>updated</strong> — вызывается после обновления DOM, когда
              изменения уже применены.
            </li>
            <li>
              <strong>beforeUnmount</strong> (раньше <code>beforeDestroy</code>)
              — вызывается перед удалением компонента.
            </li>
            <li>
              <strong>unmounted</strong> (раньше <code>destroyed</code>) —
              компонент уничтожен, можно очищать подписки, таймеры и т.п.
            </li>
          </ul>

          <p class="code--block" data-lang="JS">
            export default &#123; <br />
            &nbsp;&nbsp;created() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;console.log('created'); <br />
            &nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;mounted() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;console.log('mounted'); <br />
            &nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;updated() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;console.log('updated'); <br />
            &nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;unmounted() &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;console.log('unmounted'); <br />
            &nbsp;&nbsp;&#125; <br />
            &#125;; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Основные хуки жизненного цикла (Composition API)</h4>
          <p>
            В Composition API используются функции, которые импортируются из Vue
            и вызываются внутри <code>setup</code> или внутри
            <code>&lt;script setup&gt;</code>. Они соответствуют тем же стадиям
            жизненного цикла.
          </p>
          <ul>
            <li><strong>onMounted</strong> — аналог <code>mounted</code>.</li>
            <li>
              <strong>onBeforeMount</strong> — аналог <code>beforeMount</code>.
            </li>
            <li><strong>onUpdated</strong> — аналог <code>updated</code>.</li>
            <li>
              <strong>onBeforeUpdate</strong> — аналог
              <code>beforeUpdate</code>.
            </li>
            <li>
              <strong>onUnmounted</strong> — аналог <code>unmounted</code>.
            </li>
            <li>
              <strong>onBeforeUnmount</strong> — аналог
              <code>beforeUnmount</code>.
            </li>
            <li>
              <strong>onErrorCaptured</strong> — перехват ошибок у дочерних
              компонентов.
            </li>
            <li>
              <strong>onActivated</strong> / <strong>onDeactivated</strong> —
              для компонентов, обёрнутых в <code>&lt;KeepAlive&gt;</code>.
            </li>
          </ul>

          <p class="code--block" data-lang="JS">
            &lt;script setup&gt; <br />
            import &#123; onMounted, onUpdated, onUnmounted &#125; from 'vue';
            <br />
            <br />
            onMounted(() =&gt; &#123; <br />
            &nbsp;&nbsp;console.log('компонент смонтирован'); <br />
            &#125;); <br />
            <br />
            onUpdated(() =&gt; &#123; <br />
            &nbsp;&nbsp;console.log('компонент обновлён'); <br />
            &#125;); <br />
            <br />
            onUnmounted(() =&gt; &#123; <br />
            &nbsp;&nbsp;console.log('компонент уничтожен'); <br />
            &#125;); <br />
            &lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Для чего обычно используют основные хуки</h4>
          <ul>
            <li>
              <strong>created / setup</strong> — инициализация данных, запросы,
              которые не завязаны на DOM.
            </li>
            <li>
              <strong>mounted / onMounted</strong> — работа с DOM, сторонними
              библиотеками, которые требуют готового HTML.
            </li>
            <li>
              <strong>beforeUpdate / onBeforeUpdate</strong> — редкий случай,
              когда нужно что-то сделать до обновления DOM.
            </li>
            <li>
              <strong>updated / onUpdated</strong> — реакция на уже обновлённый
              DOM (например, пересчёт размеров элементов).
            </li>
            <li>
              <strong>beforeUnmount / onBeforeUnmount</strong> и
              <strong>unmounted / onUnmounted</strong> — очистка ресурсов:
              таймеров, подписок, слушателей событий.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>5. Кратко</h4>
          <ul>
            <li>
              Жизненный цикл Vue-компонента делится на этапы: создание,
              монтирование, обновление и уничтожение.
            </li>
            <li>
              В Options API используются хуки: <strong>beforeCreate</strong>,
              <strong>created</strong>, <strong>beforeMount</strong>,
              <strong>mounted</strong>, <strong>beforeUpdate</strong>,
              <strong>updated</strong>, <strong>beforeUnmount</strong>,
              <strong>unmounted</strong>.
            </li>
            <li>
              В Composition API используются функции:
              <strong>onBeforeMount</strong>, <strong>onMounted</strong>,
              <strong>onBeforeUpdate</strong>, <strong>onUpdated</strong>,
              <strong>onBeforeUnmount</strong>, <strong>onUnmounted</strong> и
              специальные хуки <strong>onErrorCaptured</strong>,
              <strong>onActivated</strong>, <strong>onDeactivated</strong>.
            </li>
            <li>
              Хуки нужны, чтобы выполнять код в нужный момент жизни компонента:
              при первом рендере, при изменении данных, перед удалением и т.д.
            </li>
            <li>
              На практике чаще всего используют <strong>created/setup</strong>,
              <strong>mounted/onMounted</strong>,
              <strong>updated/onUpdated</strong> и
              <strong>unmounted/onUnmounted</strong>.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          7. Что понимается под контролируемыми и неконтролируемыми
          компонентами? Объяснить разницу между умными и глупыми компонентами.
        </h3>

        <div class="subtopic">
          <h4>1. Контролируемые компоненты</h4>
          <p>
            <strong>Контролируемый компонент</strong> — это компонент, у
            которого всё важное состояние (например, значения полей формы)
            хранится во внешнем состоянии (reactive/ref, Pinia, родительский
            компонент), а сам компонент только отображает это состояние и
            сообщает об изменениях через события.
          </p>
          <p>
            Источником истины является JS‑состояние, а не сам DOM: пользователь
            что‑то вводит, компонент эмитит событие, родитель меняет состояние,
            и новое значение снова приходит в компонент через пропы или v-model.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Родитель --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;input v-model=&quot;name&quot; /&gt; &lt;!--
            значение живёт в реактивном состоянии --&gt; <br />
            &nbsp;&nbsp;&lt;p&gt;Имя: &#123;&#123; name &#125;&#125;&lt;/p&gt;
            <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            import &#123; ref &#125; from 'vue'; <br />
            <br />
            const name = ref('Иван'); <br />
            // input здесь контролируемый: его значение всегда равно name, а
            изменения идут через v-model <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Неконтролируемые компоненты</h4>
          <p>
            <strong>Неконтролируемый компонент</strong> — это компонент, у
            которого часть состояния живёт внутри самого DOM‑элемента (input,
            textarea и т.п.) или внутри компонента, а не в общем реактивном
            состоянии приложения.
          </p>
          <p>
            В таком случае значение поля не синхронизируется на каждый ввод с
            реактивным состоянием, а читается по запросу (через ref на элемент
            или через методы компонента), например только при отправке формы.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;input type=&quot;text&quot; ref=&quot;inputEl&quot;
            /&gt; <br />
            &nbsp;&nbsp;&lt;button
            @click=&quot;submit&quot;&gt;Отправить&lt;/button&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            import &#123; ref &#125; from 'vue'; <br />
            <br />
            const inputEl = ref(null); <br />
            <br />
            function submit() &#123; <br />
            &nbsp;&nbsp;const value = inputEl.value.value; // читаем значение
            прямо из DOM только при клике <br />
            &nbsp;&nbsp;console.log('Отправили:', value); <br />
            &#125; <br />
            // Здесь input можно считать неконтролируемым: пока мы не нажали
            кнопку, значение не живёт в реактивном состоянии <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Умные (smart) компоненты</h4>
          <p>
            <strong>Умные компоненты</strong> (smart, container) — это
            компоненты, которые содержат бизнес‑логику и логику работы
            приложения: получают данные (в том числе с сервера), работают со
            store (Pinia), принимают решения, какие данные и какие события
            передать дочерним компонентам.
          </p>
          <p>
            Они обычно находятся выше по дереву, «орchestrируют» работу
            нескольких презентационных компонентов, знают о структурах данных и
            о том, как всё связано в приложении.
          </p>

          <p class="code--block" data-lang="JS">
            &lt;!-- SmartComponent.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;UserCard <br />
            &nbsp;&nbsp;&nbsp;&nbsp;:user=&quot;user&quot; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;@update-name=&quot;onUpdateName&quot; <br />
            &nbsp;&nbsp;/&gt; <br />
            &lt;/template&gt; <br />
            <br />
            &lt;script setup&gt; <br />
            import &#123; ref &#125; from 'vue'; <br />
            import UserCard from './UserCard.vue'; <br />
            <br />
            const user = ref(&#123; name: 'Иван', age: 25 &#125;); <br />
            <br />
            function onUpdateName(newName) &#123; <br />
            &nbsp;&nbsp;user.value.name = newName; <br />
            &nbsp;&nbsp;// тут может быть вызов API, обновление Pinia и т.д.
            <br />
            &#125; <br />
            &lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Глупые (dumb / presentational) компоненты</h4>
          <p>
            <strong>Глупые компоненты</strong> (dumb, presentational) — это
            компоненты, которые отвечают только за отображение интерфейса и
            простую UI‑логику (клики, ввод), но не хранят бизнес‑состояние и не
            знают, откуда приходят данные и что с ними дальше происходит.
          </p>
          <p>
            Они получают всё нужное через props и сообщают о взаимодействиях
            через события (emit), оставаясь максимально переиспользуемыми и не
            завязанными на конкретный контекст приложения.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- UserCard.vue (глупый компонент) --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;div class=&quot;user-card&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;&#123;&#123; user.name
            &#125;&#125;&lt;/h3&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Возраст: &#123;&#123; user.age
            &#125;&#125;&lt;/p&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;input v-model=&quot;localName&quot;
            /&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;button
            @click=&quot;emitUpdate&quot;&gt;Сохранить имя&lt;/button&gt; <br />
            &nbsp;&nbsp;&lt;/div&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="JS">
            &lt;script setup&gt; <br />
            import &#123; ref, watch &#125; from 'vue'; <br />
            <br />
            const props = defineProps(&#123; <br />
            &nbsp;&nbsp;user: &#123; type: Object, required: true &#125; <br />
            &#125;); <br />
            <br />
            const emit = defineEmits(['update-name']); <br />
            <br />
            const localName = ref(props.user.name); <br />
            <br />
            watch( <br />
            &nbsp;&nbsp;() =&gt; props.user.name, <br />
            &nbsp;&nbsp;(value) =&gt; &#123; localName.value = value; &#125;
            <br />
            ); <br />
            <br />
            function emitUpdate() &#123; <br />
            &nbsp;&nbsp;emit('update-name', localName.value); <br />
            &#125; <br />
            &lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Связь между понятиями</h4>
          <ul>
            <li>
              Чаще всего контролируемые компоненты встречаются как раз в роли
              «глупых» (presentational): они получают значения и коллбэки от
              родителя и не решают бизнес‑задачи сами.
            </li>
            <li>
              Неконтролируемые компоненты могут быть и умными, и глупыми, но их
              сложнее предсказуемо тестировать и синхронизировать с общим
              состоянием.
            </li>
            <li>
              Умные компоненты обычно управляют контролируемыми дочерними
              компонентами: держат состояние и передают значения/обработчики
              вниз через props и события.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>6. Кратко</h4>
          <ul>
            <li>
              Контролируемый компонент: состояние живёт в реактивных
              данных/сторе, компонент только отображает и эмитит изменения.
            </li>
            <li>
              Неконтролируемый компонент: часть состояния живёт в DOM или внутри
              самого компонента и читается по запросу (через ref/метод).
            </li>
            <li>
              Умный компонент: содержит бизнес‑логику, работает с API/Pinia,
              решает, какие данные и события передать детям.
            </li>
            <li>
              Глупый компонент: отвечает только за отображение и простую
              UI‑логику, получает всё через props и эмитит события.
            </li>
            <li>
              Хорошая архитектура старается разделять умные и глупые компоненты,
              а форму и сложные UI‑состояния делать контролируемыми.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          8. Почему не рекомендуется использовать объект в качестве key в v-for?
        </h3>

        <div class="subtopic">
          <h4>1. Зачем вообще нужен key в v-for</h4>
          <p>
            Атрибут <strong>key</strong> помогает Vue отличать элементы списка
            друг от друга при обновлении: по ключу фреймворк понимает, какой
            виртуальный элемент соответствует какому реальному DOM‑узлу.
          </p>
          <p>
            Правильный key даёт Vue возможность переиспользовать и правильно
            переставлять элементы, а не пересоздавать или «перепутывать» их при
            изменении массива.
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Требования к хорошему key</h4>
          <ul>
            <li>
              Должен быть <strong>примитивом</strong> (строка или число), а не
              объектом или массивом.
            </li>
            <li>
              Должен быть <strong>уникальным</strong> среди элементов одного
              списка.
            </li>
            <li>
              Должен быть <strong>стабильным</strong> — не меняться при каждом
              рендере для одного и того же логического элемента.
            </li>
            <li>
              Лучший вариант — это ID или другой стабильный идентификатор
              сущности (например, <code>user.id</code>).
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>3. Почему объект в качестве key — плохая идея</h4>
          <p>
            Если использовать объект как key (например,
            <code>:key="item"</code>, где <code>item</code> — объект), то Vue
            при каждом сравнении ключей будет опираться на ссылочное равенство,
            а не на «содержимое» объекта.
          </p>
          <p>
            Даже если поля объекта те же самые, но ссылка другая (новый объект),
            Vue будет считать, что это уже другой элемент и может пересоздавать
            DOM‑узлы или терять состояние вложенных компонентов.
          </p>
          <p>
            Кроме того, объект не является простым и предсказуемым
            идентификатором: сложно гарантировать его стабильность и
            уникальность так же, как у строки или числа.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Плохой пример --&gt; <br />
            &lt;div v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;
            <br />
            &nbsp;&nbsp;&#123;&#123; item.name &#125;&#125; <br />
            &lt;/div&gt; <br />
            &lt;!-- key здесь — целый объект, ссылка на который легко меняется
            при любых операциях с массивом --&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Возможные проблемы при использовании объекта в key</h4>
          <ul>
            <li>
              Непредсказуемые перерисовки: Vue может заново создать компонент
              вместо переиспользования, теряя его локальное состояние.
            </li>
            <li>
              Сложности с анимациями и переходами:
              <code>&lt;transition-group&gt;</code> опирается на key, и при
              «прыгающих» ключах анимации будут ломаться.
            </li>
            <li>
              Баги при редактировании/перетаскивании элементов: при изменении
              порядка Vue может неправильно сопоставить элементы и «перемешать»
              данные на экране.
            </li>
            <li>
              Падение производительности: лишние уничтожения и пересоздания
              DOM‑узлов и компонентов вместо аккуратной перестановки.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>5. Правильный подход к выбору key</h4>
          <p>
            Вместо объекта следует использовать уникальное примитивное поле: ID
            записи, имя пользователя, комбинацию нескольких полей,
            сериализованную в строку или индекс как крайний вариант.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Хороший пример: используем item.id как key --&gt; <br />
            &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
            <br />
            &nbsp;&nbsp;&#123;&#123; item.name &#125;&#125; <br />
            &lt;/div&gt; <br />
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Если нет id, можно собрать стабильный ключ из нескольких
            полей --&gt; <br />
            &lt;div v-for=&quot;user in users&quot; :key=&quot;user.name + '-' +
            user.email&quot;&gt; <br />
            &nbsp;&nbsp;&#123;&#123; user.name &#125;&#125; <br />
            &lt;/div&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>6. Кратко</h4>
          <ul>
            <li>
              key нужен, чтобы Vue правильно сопоставлял элементы списка при
              обновлении и перестановке.
            </li>
            <li>
              Хороший key — это примитив (строка/число), уникальный и стабильный
              для элемента.
            </li>
            <li>
              Объект как key опирается на ссылочное сравнение, из‑за чего Vue
              легко «теряет» идентичность элементов и пересоздаёт компоненты.
            </li>
            <li>
              Это ведёт к багам UI, некорректным анимациям, потере локального
              состояния и лишним перерисовкам.
            </li>
            <li>
              Поэтому рекомендуется всегда использовать примитивы: ID,
              уникальные поля или их комбинации, а не объект целиком.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          9. Как Vue отслеживает зависимости и определяет, какие компоненты
          необходимо обновить при изменении данных? (объяснить роль Proxy,
          описать механизм effect, раскрыть принципы track и trigger)
        </h3>

        <div class="subtopic">
          <h4>1. Общая идея реактивности и зависимостей</h4>
          <p>
            В Vue 3 каждый кусок реактивных данных (ref, reactive‑объект) может
            использоваться в разных вычислениях и компонентах — эти вычисления
            называют <strong>эффектами</strong> (effects): рендер компонента,
            computed, watchEffect и т.п.
          </p>
          <p>
            При первом выполнении эффекта Vue запоминает, какие реактивные
            свойства были прочитаны, а при их изменении система знает, какие
            эффекты нужно пересчитать и какие компоненты перерисовать.
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Роль Proxy и перехват get/set</h4>
          <p>
            В Vue 3 объекты делают реактивными с помощью <strong>Proxy</strong>:
            вместо оригинального объекта используется прокси‑обёртка, которая
            перехватывает операции чтения (<code>get</code>) и записи
            (<code>set</code>).
          </p>
          <p>
            Внутри перехватчика <code>get</code> вызывается функция
            <code>track(...)</code> для регистрации зависимости, а в
            перехватчике <code>set</code> — <code>trigger(...)</code> для
            оповещения подписчиков, что значение изменилось.
          </p>

          <p class="code--block" data-lang="JS">
            function reactive(obj) &#123; <br />
            &nbsp;&nbsp;return new Proxy(obj, &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;get(target, key, receiver) &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;track(target, key); //
            регистрируем зависимость <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.get(target, key,
            receiver); <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&#125;, <br />
            &nbsp;&nbsp;&nbsp;&nbsp;set(target, key, value, receiver) &#123;
            <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const oldValue = target[key];
            <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const result =
            Reflect.set(target, key, value, receiver); <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (oldValue !== value) &#123;
            <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trigger(target,
            key); // оповещаем эффекты <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&#125; <br />
            &nbsp;&nbsp;&#125;); <br />
            &#125; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Что такое effect и как он работает</h4>
          <p>
            <strong>Effect</strong> — это функция, которая должна автоматически
            выполниться при изменении зависимых данных: например, функция
            рендера компонента, функция внутри <code>watchEffect</code> или
            вычисление <code>computed</code>.
          </p>
          <p>
            Когда Vue запускает эффект, он делает его «активным» (записывает в
            переменную вроде <code>activeEffect</code>) и затем выполняет
            функцию; при каждом чтении реактивного свойства в этот момент
            <code>track</code> привязывает активный эффект к этому свойству.
          </p>

          <p class="code--block" data-lang="JS">
            let activeEffect = null; <br />
            <br />
            function effect(fn) &#123; <br />
            &nbsp;&nbsp;const runner = () =&gt; &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;activeEffect = runner; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;fn(); <br />
            &nbsp;&nbsp;&nbsp;&nbsp;activeEffect = null; <br />
            &nbsp;&nbsp;&#125;; <br />
            &nbsp;&nbsp;runner(); // сразу запускаем <br />
            &nbsp;&nbsp;return runner; <br />
            &#125; <br />
            <br />
            // Пример эффекта: <br />
            const state = reactive(&#123; count: 0 &#125;); <br />
            effect(() =&gt; &#123; <br />
            &nbsp;&nbsp;console.log('count изменился:', state.count); <br />
            &#125;); <br />
            // При чтении state.count внутри effect будет зарегистрирована
            зависимость <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Механизм track: как регистрируются зависимости</h4>
          <p>
            <strong>track(target, key)</strong> вызывается при чтении
            реактивного свойства и добавляет текущий активный эффект к списку
            зависимостей этого свойства.
          </p>
          <p>
            Для хранения зависимостей используется структура вида
            <code>WeakMap → Map → Set</code>: <code>WeakMap</code> сопоставляет
            реактивный объект с картой его свойств, а <code>Map</code> — имя
            свойства с множеством эффектов, которые от него зависят.
          </p>

          <p class="code--block" data-lang="JS">
            const targetMap = new WeakMap(); <br />
            <br />
            function track(target, key) &#123; <br />
            &nbsp;&nbsp;if (!activeEffect) return; // если нет активного
            эффекта, нечего связывать <br />
            <br />
            &nbsp;&nbsp;let depsMap = targetMap.get(target); <br />
            &nbsp;&nbsp;if (!depsMap) &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;depsMap = new Map(); <br />
            &nbsp;&nbsp;&nbsp;&nbsp;targetMap.set(target, depsMap); <br />
            &nbsp;&nbsp;&#125; <br />
            <br />
            &nbsp;&nbsp;let dep = depsMap.get(key); <br />
            &nbsp;&nbsp;if (!dep) &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;dep = new Set(); // множество эффектов для
            этого свойства <br />
            &nbsp;&nbsp;&nbsp;&nbsp;depsMap.set(key, dep); <br />
            &nbsp;&nbsp;&#125; <br />
            <br />
            &nbsp;&nbsp;dep.add(activeEffect); // добавляем текущий эффект в
            зависимости <br />
            &#125; <br />
          </p>

          <p>
            Итог: Vue знает, «это свойство → вот набор эффектов (рендеры,
            computed, watchers), которые надо запустить при изменении».
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Механизм trigger: как выполняются эффекты при изменении</h4>
          <p>
            <strong>trigger(target, key)</strong> вызывается при изменении
            реактивного свойства (в Proxy‑set или в setter у ref) и находит все
            эффекты, которые были зарегистрированы как зависящие от этого
            свойства.
          </p>
          <p>
            Затем <code>trigger</code> запускает эти эффекты: это может привести
            к повторному рендеру компонента, пересчёту <code>computed</code> и
            выполнению коллбэков watch/watchEffect.
          </p>

          <p class="code--block" data-lang="JS">
            function trigger(target, key) &#123; <br />
            &nbsp;&nbsp;const depsMap = targetMap.get(target); <br />
            &nbsp;&nbsp;if (!depsMap) return; <br />
            <br />
            &nbsp;&nbsp;const dep = depsMap.get(key); <br />
            &nbsp;&nbsp;if (!dep) return; <br />
            <br />
            &nbsp;&nbsp;dep.forEach(effectFn =&gt; &#123; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;effectFn(); // перезапускаем эффект <br />
            &nbsp;&nbsp;&#125;); <br />
            &#125; <br />
            <br />
            // При state.count++ будет вызван trigger(state, 'count'), <br />
            // и все эффекты, зависящие от state.count, выполнятся заново.
            <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>6. Как из этого следует обновление компонентов</h4>
          <p>
            Рендер компонента (его виртуальный DOM и шаблон) выполняется внутри
            эффекта — поэтому при первом рендере все реактивные свойства,
            прочитанные в шаблоне, автоматически регистрируются через
            <code>track</code>.
          </p>
          <p>
            Когда какое‑то из этих свойств меняется,
            <code>trigger</code> вызывает эффект рендера, Vue пересобирает
            виртуальный DOM для этого компонента и патчит настоящий DOM — в
            результате на экране обновляются только те компоненты и участки DOM,
            которые зависят от изменившихся данных.
          </p>
        </div>

        <div class="subtopic">
          <h4>7. Кратко</h4>
          <ul>
            <li>
              Vue 3 использует Proxy, чтобы перехватывать чтение и запись
              реактивных свойств и вызывать <code>track</code>/<code
                >trigger</code
              >
              автоматически.
            </li>
            <li>
              Effect — это функция (рендер, computed, watcher), которая должна
              автоматически запускаться при изменении использованных в ней
              реактивных данных.
            </li>
            <li>
              track(target, key) выполняется при чтении свойства и записывает
              активный эффект в структуру зависимостей
              <code>WeakMap → Map → Set</code>.
            </li>
            <li>
              trigger(target, key) выполняется при записи свойства и
              перезапускает все эффекты, которые зависят от этого свойства.
            </li>
            <li>
              Так Vue точно знает, какие эффекты (и какие компоненты) нужно
              обновить при изменении конкретных данных, и не трогает остальную
              часть приложения.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          10. Почему после изменения реактивных данных во Vue нельзя сразу
          работать с обновлённым DOM, и как nextTick() решает эту проблему?
        </h3>

        <div class="subtopic">
          <h4>1. Почему DOM не обновляется сразу после изменения данных</h4>
          <p>
            Vue обновляет DOM <strong>асинхронно</strong>: после изменения
            реактивных данных изменения в шаблоне не применяются мгновенно, а
            попадают в очередь обновлений, которая выполняется чуть позже, в
            «следующий тик» (следующий цикл события).
          </p>
          <p>
            Это нужно, чтобы сгруппировать несколько изменений состояния в один
            пакет и выполнить одну операцию обновления DOM, а не перерисовывать
            компонент много раз за один тик JavaScript.
          </p>
          <p>
            Поэтому сразу после <code>state.value++</code> разметка ещё старая:
            рендер и патчинг DOM будут выполнены после того, как текущий стек
            вызовов JS завершится и Vue выполнит запланированное обновление.
          </p>

          <p class="code--block" data-lang="JS">
            const count = ref(0); <br />
            const el = ref(null); <br />
            <br />
            function inc() &#123; <br />
            &nbsp;&nbsp;count.value++; <br />
            &nbsp;&nbsp;// Здесь DOM ещё не обновлён, el.value.innerText всё ещё
            со старым значением <br />
            &#125; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Чем опасно работать с DOM сразу после изменения данных</h4>
          <ul>
            <li>
              Вы можете читать размеры/позиции элементов (offsetHeight,
              scrollHeight) ещё до того, как браузер перерассчитал layout и
              применил новые узлы.
            </li>
            <li>
              Код, который полагается на уже добавленный элемент (автоскролл
              вниз, фокус, анимация), может работать по старому DOM и вести себя
              некорректно.
            </li>
            <li>
              Возникают «фантомные» баги: логика в JS уже думает, что элемент
              появился/исчез, а в DOM это отобразится только чуть позже.
            </li>
          </ul>

          <p class="code--block" data-lang="JS">
            const items = ref([]); <br />
            const listRef = ref(null); <br />
            <br />
            function addItem() &#123; <br />
            &nbsp;&nbsp;items.value.push('новый элемент'); <br />
            &nbsp;&nbsp;// Здесь v-for ещё не дорисовал элемент в DOM,
            scrollHeight старое <br />
            &nbsp;&nbsp;console.log('scrollHeight до обновления DOM:',
            listRef.value.scrollHeight); <br />
            &#125; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Что делает nextTick()</h4>
          <p>
            Функция <strong>nextTick()</strong> позволяет выполнить код
            <em>после того</em>, как Vue закончил текущий цикл обновления DOM:
            то есть после того, как все реактивные изменения, сделанные в этом
            тике, уже отрисованы в реальном DOM.
          </p>
          <p>
            Технически <code>nextTick</code> ставит колбэк (или промис) в
            очередь микрозадач, которая выполняется после того, как Vue закончит
            патчинг DOM в этом цикле.
          </p>

          <p class="code--block" data-lang="JS">
            import &#123; ref, nextTick &#125; from 'vue'; <br />
            <br />
            const items = ref([]); <br />
            const listRef = ref(null); <br />
            <br />
            async function addItem() &#123; <br />
            &nbsp;&nbsp;items.value.push('новый элемент'); <br />
            <br />
            &nbsp;&nbsp;await nextTick(); <br />
            &nbsp;&nbsp;// Здесь DOM уже обновлён, v-for дорисовал новый элемент
            <br />
            &nbsp;&nbsp;const el = listRef.value; <br />
            &nbsp;&nbsp;el.scrollTop = el.scrollHeight; // теперь можно
            корректно скроллить вниз <br />
            &#125; <br />
          </p>

          <p>
            После <code>await nextTick()</code> или
            <code>nextTick(() =&gt; ...)</code> можно безопасно читать и
            изменять DOM, исходя из нового состояния.
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Типичные случаи использования nextTick()</h4>
          <ul>
            <li>
              Автоскролл в чатах/списках после добавления нового сообщения или
              элемента.
            </li>
            <li>
              Установка фокуса на только что появившийся input/кнопку (после
              условного рендера v-if/v-for).
            </li>
            <li>
              Измерение размеров/позиции элементов после изменения списка или
              состояния (для анимаций, вычисления высоты и т.п.).
            </li>
            <li>
              Работа со сторонними библиотеками, которые должны
              инициализироваться по уже обновлённому DOM.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>5. Кратко</h4>
          <ul>
            <li>
              Vue обновляет DOM не сразу при изменении реактивных данных, а
              асинхронно, пакетируя изменения в один цикл обновления.
            </li>
            <li>
              Сразу после изменения состояния разметка ещё старая, поэтому
              чтение/манипуляции с DOM могут использовать устаревшую структуру.
            </li>
            <li>
              <strong>nextTick()</strong> планирует выполнение кода после
              завершения текущего цикла обновления DOM, когда все изменения уже
              применены.
            </li>
            <li>
              Используя <code>await nextTick()</code>, мы гарантируем, что
              работаем с актуальным DOM: можно корректно скроллить, мерить
              размеры, ставить фокус и инициализировать плагины.
            </li>
            <li>
              Поэтому после изменения реактивных данных, когда нужно оперировать
              уже обновлённым DOM, следует использовать <code>nextTick()</code>,
              а не полагаться на немедленное обновление.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>
          11. Сравните подход Virtual DOM и No Virtual DOM. Какую проблему
          изначально решал Virtual DOM. Почему отказываются от Virtual DOM
        </h3>

        <div class="subtopic">
          <h4>1. Что такое Virtual DOM и No Virtual DOM</h4>
          <p>
            <strong>Virtual DOM</strong> — это лёгкое JS‑представление дерева
            интерфейса в памяти: при каждом рендере фреймворк строит виртуальное
            дерево и сравнивает его с предыдущим, чтобы понять, какие
            минимальные изменения нужно применить к реальному DOM.
          </p>
          <p>
            Подход <strong>No Virtual DOM</strong> (Svelte, Solid и др.)
            старается не держать общее виртуальное дерево, а генерировать
            точечные операции над DOM «напрямую»: компилятор или тонкая
            реактивность заранее знает, какие узлы и когда нужно обновить, без
            глобового diff виртуальных деревьев.
          </p>

          <p class="code--block" data-lang="JS">
            // Условно: Virtual DOM-подход <br />
            render() &#123; <br />
            &nbsp;&nbsp;const newVTree = view(state); <br />
            &nbsp;&nbsp;patch(oldVTree, newVTree); // diff + минимальные
            изменения в DOM <br />
            &nbsp;&nbsp;oldVTree = newVTree; <br />
            &#125; <br />
            <br />
            // No Virtual DOM-подход (упрощённо) <br />
            count.subscribe((value) =&gt; &#123; <br />
            &nbsp;&nbsp;domNode.textContent = value; // сразу знаем, что и где
            менять <br />
            &#125;); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Какую проблему изначально решал Virtual DOM</h4>
          <ul>
            <li>
              <strong>Сложность ручного управления DOM</strong>: раньше код был
              завален императивными операциями (find элемент, изменить текст,
              класс, удалить/добавить узлы), что приводило к спагетти‑логике и
              ошибкам при росте проекта.
            </li>
            <li>
              <strong>Дороговизна частых операций с DOM</strong>: прямые частые
              изменения DOM дорого обходятся по производительности; Virtual DOM
              позволяет группировать изменения и минимизировать количество
              реальных операций.
            </li>
            <li>
              <strong>Простая модель программирования</strong>: с Virtual DOM
              можно думать в режиме «опиши, как должен выглядеть UI при таком
              состоянии», а библиотека сама решит, как обновить DOM. Это
              уменьшает количество багов и упрощает разработку.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>3. Суть Virtual DOM-подхода</h4>
          <p>
            При изменении состояния фреймворк строит новое виртуальное дерево,
            сравнивает его с предыдущим (diff), находит отличающиеся ветки и
            применяет минимальный набор операций к реальному DOM.
          </p>
          <p>
            Это даёт детерминированные обновления: можно много раз
            «перерисовывать» виртуальное дерево в JS, а реальные изменения в DOM
            будут сделаны пакетно и оптимизировано.
          </p>

          <p class="code--block" data-lang="JS">
            const oldTree = render(oldState); <br />
            const newTree = render(newState); <br />
            const patches = diff(oldTree, newTree); <br />
            applyPatches(domRoot, patches); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Подход No Virtual DOM: что он делает иначе</h4>
          <p>
            В подходе <strong>No Virtual DOM</strong> идея в том, чтобы вообще
            не строить и не диффать большие виртуальные деревья на каждый
            апдейт.
          </p>
          <p>
            Вместо этого компилятор или реактивная система заранее знает, какие
            конкретно части DOM зависят от каких переменных, и при изменении
            переменной сразу выполняет точечное обновление нужного узла.
          </p>

          <p class="code--block" data-lang="JS">
            // Псевдокод компилируемого подхода <br />
            const span = document.createElement('span'); <br />
            span.textContent = count; <br />
            <br />
            count.subscribe((value) =&gt; &#123; <br />
            &nbsp;&nbsp;span.textContent = value; // нет общего diff, сразу
            меняем нужный узел <br />
            &#125;); <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Почему отказываются от Virtual DOM (или ограничивают его)</h4>
          <ul>
            <li>
              <strong>Добавляет свой оверхед</strong>: сам расчёт виртуального
              дерева и diff — это тоже немаленькая работа в JS. Для больших
              интерфейсов и частых апдейтов это может становиться узким местом.
            </li>
            <li>
              <strong>Не всегда максимально эффективен</strong>: тонкая
              реактивность или компиляция могут сразу «стрелять» в нужный
              DOM‑узел, не тратя время на проход по всему дереву и сравнение.
            </li>
            <li>
              <strong>Сложность реализации и размер бандла</strong>: полноценный
              Virtual DOM‑движок усложняет код фреймворка и увеличивает размер
              библиотеки, тогда как компилируемые решения могут генерировать
              более простой и узкоспециализированный JS.
            </li>
            <li>
              <strong>Новые подходы дают лучшую производительность</strong>:
              современные фреймворки показывают, что можно добиться равной или
              лучшей скорости без общего Virtual DOM, за счёт предварительной
              компиляции и более прямого управления DOM.
            </li>
            <li>
              <strong
                >Ментальная модель не обязана быть привязана к Virtual
                DOM</strong
              >: можно сохранить декларативный стиль «UI = f(state)», но под
              капотом реализовать его без диффинга двух деревьев.
            </li>
          </ul>
        </div>

        <div class="subtopic">
          <h4>6. Кратко</h4>
          <ul>
            <li>
              Virtual DOM — это in-memory дерево, которое позволяет декларативно
              описывать UI и эффективно минимизировать количество операций над
              реальным DOM.
            </li>
            <li>
              Изначально он решал проблему сложного и дорогого ручного
              управления DOM: сгруппировал выполнение изменений и упростил
              модель программирования.
            </li>
            <li>
              Подход No Virtual DOM избегает общего диффинга: использует
              компиляцию или точечную реактивность, чтобы обновлять только те
              узлы, которые зависят от изменившихся данных.
            </li>
            <li>
              От Virtual DOM частично отказываются, потому что его собственный
              оверхед и diffинг не всегда оптимальны по сравнению с более
              прямыми, компилируемыми подходами.
            </li>
            <li>
              Современные фреймворки показывают, что можно сохранить удобную
              декларативную модель UI, не опираясь на общий Virtual DOM, и при
              этом выиграть в производительности и размере бандла.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>12. Что такое slots и какие типы slots существуют?</h3>

        <div class="subtopic">
          <h4>1. Что такое slots</h4>
          <p>
            <strong>Slots</strong> во Vue — это «места для вставки контента»
            внутри компонента: дочерний компонент оставляет в шаблоне «дырки»
            (слоты), а родительский компонент может заполнить эти места своим
            произвольным HTML, разметкой и другими компонентами.
          </p>
          <p>
            Слоты позволяют делать компоненты более гибкими и переиспользуемыми:
            структура и логика остаются в дочернем компоненте, а конкретный
            контент в определённых областях задаётся родителем.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- ChildComponent.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;div class=&quot;card&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;Дефолтный текст&lt;/slot&gt;
            <br />
            &nbsp;&nbsp;&lt;/div&gt; <br />
            &lt;/template&gt; <br />
            <br />
            &lt;!-- Parent.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;ChildComponent&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Свой контент внутри
            карточки&lt;/p&gt; <br />
            &nbsp;&nbsp;&lt;/ChildComponent&gt; <br />
            &lt;/template&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>2. Default slot (дефолтный слот)</h4>
          <p>
            <strong>Default slot</strong> (дефолтный слот) — это слот без имени.
            Он используется, когда компонент имеет одну основную область для
            пользовательского контента.
          </p>
          <p>
            Если родитель не передал контент в слот, можно указать дефолтное
            содержимое внутри <code>&lt;slot&gt;...&lt;/slot&gt;</code>, которое
            будет использовано как запасной вариант.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Дочерний компонент --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;div class=&quot;alert&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;Сообщение по
            умолчанию&lt;/slot&gt; <br />
            &nbsp;&nbsp;&lt;/div&gt; <br />
            &lt;/template&gt; <br />
            <br />
            &lt;!-- Родительский компонент --&gt; <br />
            &lt;Alert&gt; <br />
            &nbsp;&nbsp;&lt;strong&gt;Внимание!&lt;/strong&gt; Что-то произошло.
            <br />
            &lt;/Alert&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. Named slots (именованные слоты)</h4>
          <p>
            <strong>Named slots</strong> позволяют определить в компоненте
            несколько разных областей для контента — каждая область имеет своё
            имя, и родитель может заполнять их независимо друг от друга.
          </p>
          <p>
            Именованные слоты объявляются через
            <code>&lt;slot name="header"&gt;</code> и подобные, а в родителе
            контент передаётся через
            <code>&lt;template v-slot:header&gt;</code> или сокращение
            <code>#header</code>.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Layout.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;header&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;slot
            name=&quot;header&quot;&gt;Заголовок по умолчанию&lt;/slot&gt;
            <br />
            &nbsp;&nbsp;&lt;/header&gt; <br />
            &nbsp;&nbsp;&lt;main&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;Основной контент по
            умолчанию&lt;/slot&gt; <br />
            &nbsp;&nbsp;&lt;/main&gt; <br />
            &nbsp;&nbsp;&lt;footer&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;slot name=&quot;footer&quot;&gt;Футер по
            умолчанию&lt;/slot&gt; <br />
            &nbsp;&nbsp;&lt;/footer&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Родитель --&gt; <br />
            &lt;Layout&gt; <br />
            &nbsp;&nbsp;&lt;template #header&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Мой заголовок&lt;/h1&gt; <br />
            &nbsp;&nbsp;&lt;/template&gt; <br />
            <br />
            &nbsp;&nbsp;&lt;p&gt;Основной контент страницы&lt;/p&gt; <br />
            <br />
            &nbsp;&nbsp;&lt;template #footer&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;small&gt;Мой кастомный
            футер&lt;/small&gt; <br />
            &nbsp;&nbsp;&lt;/template&gt; <br />
            &lt;/Layout&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. Scoped slots (слоты с параметрами / пропсами)</h4>
          <p>
            <strong>Scoped slots</strong> (слоты с областью видимости) позволяют
            дочернему компоненту передать данные в слот, чтобы родитель мог
            использовать эти данные при рендере своего контента внутри этого
            слота.
          </p>
          <p>
            Дочерний компонент «пробрасывает» данные через атрибуты
            <code>&lt;slot :user="user"&gt;</code>, а родитель принимает их
            через <code>v-slot="slotProps"</code> и использует внутри шаблона,
            как обычные переменные.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- ChildList.vue --&gt; <br />
            &lt;template&gt; <br />
            &nbsp;&nbsp;&lt;ul&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;li v-for=&quot;user in users&quot;
            :key=&quot;user.id&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot
            :user=&quot;user&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&#123;
            user.name &#125;&#125; &lt;!-- дефолтный рендер --&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/li&gt; <br />
            &nbsp;&nbsp;&lt;/ul&gt; <br />
            &lt;/template&gt; <br />
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Родитель --&gt; <br />
            &lt;ChildList v-slot=&quot;slotProps&quot;&gt; <br />
            &nbsp;&nbsp;&lt;strong&gt;&#123;&#123; slotProps.user.name
            &#125;&#125;&lt;/strong&gt; (&#123;&#123; slotProps.user.email
            &#125;&#125;) <br />
            &lt;/ChildList&gt; <br />
          </p>

          <p>
            Таким образом, дочерний компонент управляет тем, какие данные
            доступны в слоте, а родитель управляет тем, КАК эти данные
            отображаются.
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Итоги по типам слотов</h4>
          <ul>
            <li>
              <strong>Default slot</strong> — один основной слот без имени, для
              простых случаев «вставить контент внутрь компонента».
            </li>
            <li>
              <strong>Named slots</strong> — несколько слотов с именами для
              сложных шаблонов (header, footer, sidebar и т.п.).
            </li>
            <li>
              <strong>Scoped slots</strong> — слоты, которым дочерний компонент
              передаёт данные (slot props), а родитель использует эти данные при
              рендере контента.
            </li>
            <li>
              Именованный слот может одновременно быть и scoped (именованный
              scoped slot), когда у слота есть и имя, и пропсы.
            </li>
            <li>
              Slots — один из основных механизмов построения гибких,
              переиспользуемых и настраиваемых компонентов во Vue.
            </li>
          </ul>
        </div>
      </div>

      <div class="exam--card">
        <h3>13. Что такое SSG, SSR, CSR? Что такое гидрация?</h3>

        <div class="subtopic">
          <h4>1. Общая идея: где и когда рендерится HTML</h4>
          <p>
            SSG, SSR и CSR — это три подхода к тому, <strong>где</strong> и
            <strong>когда</strong> генерируется HTML‑разметка страницы: заранее
            на этапе сборки, на сервере при запросе или в браузере после
            загрузки.
          </p>
          <p>
            Гидрация связана с SSR/SSG и описывает момент, когда уже готовый
            HTML в браузере «оживает» и становится интерактивным благодаря
            JavaScript.
          </p>
        </div>

        <div class="subtopic">
          <h4>2. CSR — Client-Side Rendering</h4>
          <p>
            При <strong>CSR</strong> сервер отдаёт почти пустой HTML (обычно
            только корневой <code>&lt;div id="app"&gt;</code>) и большой
            JS‑бандл; весь реальный HTML строится уже в браузере после загрузки
            и выполнения JavaScript.
          </p>
          <p>
            Такой подход типичен для SPA: первый экран может загружаться
            медленнее, но приложение очень интерактивно, а переходы между
            страницами быстрые, потому что всё происходит на клиенте.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Ответ сервера при CSR --&gt; <br />
            &lt;html&gt; <br />
            &nbsp;&nbsp;&lt;body&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
            <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;script
            src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt; <br />
            &nbsp;&nbsp;&lt;/body&gt; <br />
            &lt;/html&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>3. SSG — Static Site Generation</h4>
          <p>
            При <strong>SSG</strong> HTML‑страницы генерируются
            <em>заранее</em> на этапе сборки проекта (build time): для каждого
            маршрута фреймворк создаёт готовый статический HTML, который потом
            просто отдаётся как файлы.
          </p>
          <p>
            Это даёт очень быстрый первый ответ от сервера и хорошее SEO, так
            как страница уже содержит контент; динамика и интерактивность
            добавляются поверх через JS (часто тоже через гидрацию).
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Пример готового HTML при SSG --&gt; <br />
            &lt;html&gt; <br />
            &nbsp;&nbsp;&lt;body&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div id=&quot;app&quot;&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Статья&lt;/h1&gt;
            <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Контент сгенерирован на
            этапе сборки.&lt;/p&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&lt;script
            src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt; <br />
            &nbsp;&nbsp;&lt;/body&gt; <br />
            &lt;/html&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>4. SSR — Server-Side Rendering</h4>
          <p>
            При <strong>SSR</strong> HTML‑страница генерируется на сервере
            <em>на каждый запрос</em>: при заходе пользователя фреймворк
            запускает рендер компонента на сервере и возвращает уже заполненный
            HTML.
          </p>
          <p>
            Это даёт быстрый первый отрисованный экран и хорошее SEO для
            динамического контента; после загрузки фронтенд‑JS «подхватывает»
            этот HTML и делает его интерактивным через гидрацию.
          </p>

          <p class="code--block" data-lang="HTML">
            &lt;!-- Ответ сервера при SSR --&gt; <br />
            &lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;
            <br />
            &nbsp;&nbsp;&lt;h1&gt;Привет, Иван&lt;/h1&gt; <br />
            &nbsp;&nbsp;&lt;p&gt;Это HTML, сгенерированный на сервере.&lt;/p&gt;
            <br />
            &lt;/div&gt; <br />
            &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt; <br />
          </p>
        </div>

        <div class="subtopic">
          <h4>5. Что такое гидрация</h4>
          <p>
            <strong>Гидрация</strong> — это процесс, при котором уже
            сгенерированный сервером (SSR/SSG) HTML в браузере становится
            интерактивным: фреймворк заново запускает приложение на клиенте,
            сопоставляет виртуальное дерево с текущим DOM и «пришивает»
            обработчики событий и состояние.
          </p>
          <p>
            Проще: сервер отдал готовую, но «мёртвую» HTML‑страницу, а гидрация
            — это этап, когда клиентский JS восстанавливает логику: клики,
            формы, реактивность, маршрутизацию и т.п.
          </p>

          <p class="code--block" data-lang="JS">
            // Условный пример для Vue SSR <br />
            import &#123; createSSRApp &#125; from 'vue'; <br />
            import App from './App.vue'; <br />
            <br />
            const app = createSSRApp(App); <br />
            // В HTML уже есть разметка #app, сгенерированная на сервере <br />
            app.mount('#app'); // вместо полного перерендера выполняется
            гидрация <br />
          </p>

          <p>
            Считается, что при классической гидрации страница как бы
            «отправляется дважды»: сначала как HTML, а потом как JS‑код, который
            ещё раз проходит по компонентам, чтобы восстановить состояние и
            обработчики.
          </p>
        </div>

        <div class="subtopic">
          <h4>6. Кратко</h4>
          <ul>
            <li>
              <strong>CSR</strong>: HTML собирается в браузере после загрузки
              JS; хорошо для SPA и очень интерактивных приложений, хуже первый
              рендер и SEO.
            </li>
            <li>
              <strong>SSG</strong>: HTML генерируется на этапе сборки и отдаётся
              как статический; очень быстрый первый байт и отличное SEO для
              относительно статического контента.
            </li>
            <li>
              <strong>SSR</strong>: HTML генерируется на сервере при каждом
              запросе; хорошо подходит для динамических страниц с хорошим SEO.
            </li>
            <li>
              <strong>Гидрация</strong>: этап, когда уже готовый HTML (из
              SSR/SSG) подключается к клиентскому JS, становятся активными
              обработчики событий, восстанавливается реактивность и состояние.
            </li>
            <li>
              Все подходы можно комбинировать: одна часть сайта — SSG, другая —
              SSR, а внутри страниц отдельные виджеты работают как CSR.
            </li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section practice">
      <div class="exam--card">
        <h3>ПРАКТИКА</h3>
        <p>практический пример vue js:</p>
        <p class="code--block" data-lang="JS">
          import { ref } from 'vue' <br />
          const count = ref(0) <br />
          function increment() { <br />
          count++ <br />
          } <br />
        </p>
        <p>
          Почему этот код не работает и как его исправить? <br />

          Практика будет в таком же духе. Поэтому потренируйтесь с llm на
          базовых примерах. <br />

          практический пример БЭМ: <br />

          Описать по БЭМ. Примеры на практике могут быть сложнее, включая CSS и
          внешнюю геометрию. <br />
        </p>
        <p class="code--block" data-lang="HTML">
          &lt;article&gt;<br />
          &lt;h3&gt;Заголовок поста&lt;/h3&gt;<br />
          &lt;p&gt;Текст краткого содержания поста. Здесь может быть несколько
          предложений, описывающих основную тему...&lt;/p&gt;<br />
          &lt;/article&gt;
        </p>

        <div class="subtopic">
          <h3>БЭМ. Какие элементы внешней геометрии переносим</h3>
          <table>
            <thead>
              <tr>
                <th>Свойство (убираем из блока)</th>
                <th>Куда переносим (родитель)</th>
                <th>Пример</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>margin</td>
                <td>Элемент родителя</td>
                <td><code>.header__nav { margin-bottom: 20px; }</code></td>
              </tr>
              <tr>
                <td>margin-top / margin-right / margin-bottom / margin-left</td>
                <td>Элемент родителя</td>
                <td><code>.sidebar__menu { margin-left: 30px; }</code></td>
              </tr>
              <tr>
                <td>position: relative (для выравнивания блока снаружи)</td>
                <td>Элемент родителя</td>
                <td>
                  <code
                    >.container__card { position: relative; top: 10px; }</code
                  >
                </td>
              </tr>
              <tr>
                <td>float</td>
                <td>Элемент родителя</td>
                <td><code>.row__col { float: left; width: 50%; }</code></td>
              </tr>
              <tr>
                <td>position: absolute (внешнее позиционирование)</td>
                <td>Элемент родителя</td>
                <td>
                  <code>.hero__popup { position: absolute; top: 100px; }</code>
                </td>
              </tr>
              <tr>
                <td>top / right / bottom / left (внешние)</td>
                <td>Элемент родителя</td>
                <td>
                  <code>.navbar__logo { position: absolute; left: 20px; }</code>
                </td>
              </tr>
              <tr>
                <td>z-index (для слоя относительно окружения)</td>
                <td>Элемент родителя</td>
                <td><code>.dropdown__menu { z-index: 100; }</code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section>
      <ul id="menu">
        <li data-action="open">Открыть</li>
        <li data-action="save">Сохранить</li>
        <li data-action="exit">Выход</li>
      </ul>
    </section>

    <section>
      <script src="main.js"></script>
      <script src="learning.js"></script>
    </section>
  </body>
</html>
